// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`exhaustive-schema 1`] = `
import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
  Sql,
  Decimal,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }
export { Decimal }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw, Sql }

/**
 * Prisma Client JS version: local
 * Query Engine version: local
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose \`select\` or \`include\`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * \`\`\`
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * \`\`\`
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findOne'
  | 'findMany'
  | 'findFirst'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The \`T\` type makes sure, that the \`return proceed\` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * \`\`\`
 * const prisma = new PrismaClient()
 * // Fetch zero or more Posts
 * const posts = await prisma.post.findMany()
 * \`\`\`
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * \`\`\`
   * const prisma = new PrismaClient()
   * // Fetch zero or more Posts
   * const posts = await prisma.post.findMany()
   * \`\`\`
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to \`$on\`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to \`$connect\`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to \`$disconnect\`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * \`\`\`
   * // With parameters use prisma.executeRaw\`\`, values will be escaped automatically
   * const result = await prisma.executeRaw\`UPDATE User SET cool = \${true} WHERE id = \${1};\`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * \`\`\`
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to \`$executeRaw\`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * \`\`\`
   * // With parameters use prisma.queryRaw\`\`, values will be escaped automatically
   * const result = await prisma.queryRaw\`SELECT * FROM User WHERE id = \${1} OR email = \${'ema.il'};\`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * \`\`\`
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to \`$queryRaw\`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray | Sql, ...values: any[]): Promise<T>;

  /**
   * \`prisma.post\`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * \`\`\`
    */
  get post(): PostDelegate;

  /**
   * \`prisma.user\`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * \`\`\`
    */
  get user(): UserDelegate;

  /**
   * \`prisma.m\`: Exposes CRUD operations for the **M** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Ms
    * const ms = await prisma.m.findMany()
    * \`\`\`
    */
  get m(): MDelegate;

  /**
   * \`prisma.n\`: Exposes CRUD operations for the **N** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Ns
    * const ns = await prisma.n.findMany()
    * \`\`\`
    */
  get n(): NDelegate;

  /**
   * \`prisma.oneOptional\`: Exposes CRUD operations for the **OneOptional** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more OneOptionals
    * const oneOptionals = await prisma.oneOptional.findMany()
    * \`\`\`
    */
  get oneOptional(): OneOptionalDelegate;

  /**
   * \`prisma.manyRequired\`: Exposes CRUD operations for the **ManyRequired** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more ManyRequireds
    * const manyRequireds = await prisma.manyRequired.findMany()
    * \`\`\`
    */
  get manyRequired(): ManyRequiredDelegate;

  /**
   * \`prisma.optionalSide1\`: Exposes CRUD operations for the **OptionalSide1** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more OptionalSide1s
    * const optionalSide1s = await prisma.optionalSide1.findMany()
    * \`\`\`
    */
  get optionalSide1(): OptionalSide1Delegate;

  /**
   * \`prisma.optionalSide2\`: Exposes CRUD operations for the **OptionalSide2** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more OptionalSide2s
    * const optionalSide2s = await prisma.optionalSide2.findMany()
    * \`\`\`
    */
  get optionalSide2(): OptionalSide2Delegate;

  /**
   * \`prisma.a\`: Exposes CRUD operations for the **A** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more As
    * const as = await prisma.a.findMany()
    * \`\`\`
    */
  get a(): ADelegate;

  /**
   * \`prisma.b\`: Exposes CRUD operations for the **B** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Bs
    * const bs = await prisma.b.findMany()
    * \`\`\`
    */
  get b(): BDelegate;

  /**
   * \`prisma.c\`: Exposes CRUD operations for the **C** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Cs
    * const cs = await prisma.c.findMany()
    * \`\`\`
    */
  get c(): CDelegate;

  /**
   * \`prisma.d\`: Exposes CRUD operations for the **D** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Ds
    * const ds = await prisma.d.findMany()
    * \`\`\`
    */
  get d(): DDelegate;

  /**
   * \`prisma.e\`: Exposes CRUD operations for the **E** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Es
    * const es = await prisma.e.findMany()
    * \`\`\`
    */
  get e(): EDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const PostDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  title: 'title',
  content: 'content',
  published: 'published',
  authorId: 'authorId'
};

export declare type PostDistinctFieldEnum = (typeof PostDistinctFieldEnum)[keyof typeof PostDistinctFieldEnum]


export declare const UserDistinctFieldEnum: {
  id: 'id',
  email: 'email',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

export declare type UserDistinctFieldEnum = (typeof UserDistinctFieldEnum)[keyof typeof UserDistinctFieldEnum]


export declare const MDistinctFieldEnum: {
  id: 'id',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

export declare type MDistinctFieldEnum = (typeof MDistinctFieldEnum)[keyof typeof MDistinctFieldEnum]


export declare const NDistinctFieldEnum: {
  id: 'id',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

export declare type NDistinctFieldEnum = (typeof NDistinctFieldEnum)[keyof typeof NDistinctFieldEnum]


export declare const OneOptionalDistinctFieldEnum: {
  id: 'id',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

export declare type OneOptionalDistinctFieldEnum = (typeof OneOptionalDistinctFieldEnum)[keyof typeof OneOptionalDistinctFieldEnum]


export declare const ManyRequiredDistinctFieldEnum: {
  id: 'id',
  oneOptionalId: 'oneOptionalId',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

export declare type ManyRequiredDistinctFieldEnum = (typeof ManyRequiredDistinctFieldEnum)[keyof typeof ManyRequiredDistinctFieldEnum]


export declare const OptionalSide1DistinctFieldEnum: {
  id: 'id',
  optionalSide2Id: 'optionalSide2Id',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

export declare type OptionalSide1DistinctFieldEnum = (typeof OptionalSide1DistinctFieldEnum)[keyof typeof OptionalSide1DistinctFieldEnum]


export declare const OptionalSide2DistinctFieldEnum: {
  id: 'id',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

export declare type OptionalSide2DistinctFieldEnum = (typeof OptionalSide2DistinctFieldEnum)[keyof typeof OptionalSide2DistinctFieldEnum]


export declare const ADistinctFieldEnum: {
  id: 'id',
  email: 'email',
  name: 'name',
  int: 'int',
  sInt: 'sInt',
  bInt: 'bInt',
  serial: 'serial',
  sSerial: 'sSerial',
  bSerial: 'bSerial',
  inc_int: 'inc_int',
  inc_sInt: 'inc_sInt',
  inc_bInt: 'inc_bInt'
};

export declare type ADistinctFieldEnum = (typeof ADistinctFieldEnum)[keyof typeof ADistinctFieldEnum]


export declare const BDistinctFieldEnum: {
  id: 'id',
  float: 'float',
  dFloat: 'dFloat',
  decFloat: 'decFloat',
  numFloat: 'numFloat'
};

export declare type BDistinctFieldEnum = (typeof BDistinctFieldEnum)[keyof typeof BDistinctFieldEnum]


export declare const CDistinctFieldEnum: {
  id: 'id',
  char: 'char',
  vChar: 'vChar',
  text: 'text',
  bit: 'bit',
  vBit: 'vBit',
  uuid: 'uuid'
};

export declare type CDistinctFieldEnum = (typeof CDistinctFieldEnum)[keyof typeof CDistinctFieldEnum]


export declare const DDistinctFieldEnum: {
  id: 'id',
  bool: 'bool',
  byteA: 'byteA',
  xml: 'xml',
  json: 'json',
  jsonb: 'jsonb'
};

export declare type DDistinctFieldEnum = (typeof DDistinctFieldEnum)[keyof typeof DDistinctFieldEnum]


export declare const EDistinctFieldEnum: {
  id: 'id',
  date: 'date',
  time: 'time',
  ts: 'ts'
};

export declare type EDistinctFieldEnum = (typeof EDistinctFieldEnum)[keyof typeof EDistinctFieldEnum]


export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export declare const ABeautifulEnum: {
  A: 'A',
  B: 'B',
  C: 'C'
};

export declare type ABeautifulEnum = (typeof ABeautifulEnum)[keyof typeof ABeautifulEnum]


export declare const QueryMode: {
  default: 'default',
  insensitive: 'insensitive'
};

export declare type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]



/**
 * Model Post
 */

export type Post = {
  id: number
  createdAt: Date
  title: string
  content: string | null
  published: boolean
  authorId: number
}


export type AggregatePost = {
  count: number
  avg: PostAvgAggregateOutputType | null
  sum: PostSumAggregateOutputType | null
  min: PostMinAggregateOutputType | null
  max: PostMaxAggregateOutputType | null
}

export type PostAvgAggregateOutputType = {
  id: number
  authorId: number
}

export type PostSumAggregateOutputType = {
  id: number
  authorId: number
}

export type PostMinAggregateOutputType = {
  id: number
  authorId: number
}

export type PostMaxAggregateOutputType = {
  id: number
  authorId: number
}


export type PostAvgAggregateInputType = {
  id?: true
  authorId?: true
}

export type PostSumAggregateInputType = {
  id?: true
  authorId?: true
}

export type PostMinAggregateInputType = {
  id?: true
  authorId?: true
}

export type PostMaxAggregateInputType = {
  id?: true
  authorId?: true
}

export type AggregatePostArgs = {
  where?: PostWhereInput
  orderBy?: Enumerable<PostOrderByInput> | PostOrderByInput
  cursor?: PostWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PostDistinctFieldEnum>
  count?: true
  avg?: PostAvgAggregateInputType
  sum?: PostSumAggregateInputType
  min?: PostMinAggregateInputType
  max?: PostMaxAggregateInputType
}

export type GetPostAggregateType<T extends AggregatePostArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetPostAggregateScalarType<T[P]>
}

export type GetPostAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof PostAvgAggregateOutputType ? PostAvgAggregateOutputType[P] : never
}
    
    

export type PostSelect = {
  id?: boolean
  createdAt?: boolean
  title?: boolean
  content?: boolean
  published?: boolean
  author?: boolean | UserArgs
  authorId?: boolean
}

export type PostInclude = {
  author?: boolean | UserArgs
}

export type PostGetPayload<
  S extends boolean | null | undefined | PostArgs,
  U = keyof S
> = S extends true
  ? Post
  : S extends undefined
  ? never
  : S extends PostArgs | FindManyPostArgs
  ? 'include' extends U
    ? Post  & {
      [P in TrueKeys<S['include']>]:
      P extends 'author'
      ? UserGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Post ? Post[P]
: 
      P extends 'author'
      ? UserGetPayload<S['select'][P]> : never
    }
  : Post
: Post


export interface PostDelegate {
  /**
   * Find zero or one Post that matches the filter.
   * @param {FindOnePostArgs} args - Arguments to find a Post
   * @example
   * // Get one Post
   * const post = await prisma.post.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnePostArgs>(
    args: Subset<T, FindOnePostArgs>
  ): CheckSelect<T, Prisma__PostClient<Post | null>, Prisma__PostClient<PostGetPayload<T> | null>>
  /**
   * Find the first Post that matches the filter.
   * @param {FindFirstPostArgs} args - Arguments to find a Post
   * @example
   * // Get one Post
   * const post = await prisma.post.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstPostArgs>(
    args?: Subset<T, FindFirstPostArgs>
  ): CheckSelect<T, Prisma__PostClient<Post | null>, Prisma__PostClient<PostGetPayload<T> | null>>
  /**
   * Find zero or more Posts that matches the filter.
   * @param {FindManyPostArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Posts
   * const posts = await prisma.post.findMany()
   * 
   * // Get first 10 Posts
   * const posts = await prisma.post.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyPostArgs>(
    args?: Subset<T, FindManyPostArgs>
  ): CheckSelect<T, Promise<Array<Post>>, Promise<Array<PostGetPayload<T>>>>
  /**
   * Create a Post.
   * @param {PostCreateArgs} args - Arguments to create a Post.
   * @example
   * // Create one Post
   * const Post = await prisma.post.create({
   *   data: {
   *     // ... data to create a Post
   *   }
   * })
   * 
  **/
  create<T extends PostCreateArgs>(
    args: Subset<T, PostCreateArgs>
  ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>
  /**
   * Delete a Post.
   * @param {PostDeleteArgs} args - Arguments to delete one Post.
   * @example
   * // Delete one Post
   * const Post = await prisma.post.delete({
   *   where: {
   *     // ... filter to delete one Post
   *   }
   * })
   * 
  **/
  delete<T extends PostDeleteArgs>(
    args: Subset<T, PostDeleteArgs>
  ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>
  /**
   * Update one Post.
   * @param {PostUpdateArgs} args - Arguments to update one Post.
   * @example
   * // Update one Post
   * const post = await prisma.post.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends PostUpdateArgs>(
    args: Subset<T, PostUpdateArgs>
  ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>
  /**
   * Delete zero or more Posts.
   * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
   * @example
   * // Delete a few Posts
   * const { count } = await prisma.post.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends PostDeleteManyArgs>(
    args: Subset<T, PostDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Posts.
   * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Posts
   * const post = await prisma.post.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends PostUpdateManyArgs>(
    args: Subset<T, PostUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Post.
   * @param {PostUpsertArgs} args - Arguments to update or create a Post.
   * @example
   * // Update or create a Post
   * const post = await prisma.post.upsert({
   *   create: {
   *     // ... data to create a Post
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Post we want to update
   *   }
   * })
  **/
  upsert<T extends PostUpsertArgs>(
    args: Subset<T, PostUpsertArgs>
  ): CheckSelect<T, Prisma__PostClient<Post>, Prisma__PostClient<PostGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyPostArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregatePostArgs>(args: Subset<T, AggregatePostArgs>): Promise<GetPostAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for Post.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * TEST_GITHUB_LINK
 */
export declare class Prisma__PostClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Post findOne
 */
export type FindOnePostArgs = {
  /**
   * Select specific fields to fetch from the Post
  **/
  select?: PostSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PostInclude | null
  /**
   * Filter, which Post to fetch.
  **/
  where: PostWhereUniqueInput
}


/**
 * Post findFirst
 */
export type FindFirstPostArgs = {
  /**
   * Select specific fields to fetch from the Post
  **/
  select?: PostSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PostInclude | null
  /**
   * Filter, which Post to fetch.
  **/
  where?: PostWhereInput
  orderBy?: Enumerable<PostOrderByInput> | PostOrderByInput
  cursor?: PostWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<PostDistinctFieldEnum>
}


/**
 * Post findMany
 */
export type FindManyPostArgs = {
  /**
   * Select specific fields to fetch from the Post
  **/
  select?: PostSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PostInclude | null
  /**
   * Filter, which Posts to fetch.
  **/
  where?: PostWhereInput
  /**
   * Determine the order of the Posts to fetch.
  **/
  orderBy?: Enumerable<PostOrderByInput> | PostOrderByInput
  /**
   * Sets the position for listing Posts.
  **/
  cursor?: PostWhereUniqueInput
  /**
   * The number of Posts to fetch. If negative number, it will take Posts before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` Posts.
  **/
  skip?: number
  distinct?: Enumerable<PostDistinctFieldEnum>
}


/**
 * Post create
 */
export type PostCreateArgs = {
  /**
   * Select specific fields to fetch from the Post
  **/
  select?: PostSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PostInclude | null
  /**
   * The data needed to create a Post.
  **/
  data: PostCreateInput
}


/**
 * Post update
 */
export type PostUpdateArgs = {
  /**
   * Select specific fields to fetch from the Post
  **/
  select?: PostSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PostInclude | null
  /**
   * The data needed to update a Post.
  **/
  data: PostUpdateInput
  /**
   * Choose, which Post to update.
  **/
  where: PostWhereUniqueInput
}


/**
 * Post updateMany
 */
export type PostUpdateManyArgs = {
  data: PostUpdateManyMutationInput
  where?: PostWhereInput
}


/**
 * Post upsert
 */
export type PostUpsertArgs = {
  /**
   * Select specific fields to fetch from the Post
  **/
  select?: PostSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PostInclude | null
  /**
   * The filter to search for the Post to update in case it exists.
  **/
  where: PostWhereUniqueInput
  /**
   * In case the Post found by the \`where\` argument doesn't exist, create a new Post with this data.
  **/
  create: PostCreateInput
  /**
   * In case the Post was found with the provided \`where\` argument, update it with this data.
  **/
  update: PostUpdateInput
}


/**
 * Post delete
 */
export type PostDeleteArgs = {
  /**
   * Select specific fields to fetch from the Post
  **/
  select?: PostSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PostInclude | null
  /**
   * Filter which Post to delete.
  **/
  where: PostWhereUniqueInput
}


/**
 * Post deleteMany
 */
export type PostDeleteManyArgs = {
  where?: PostWhereInput
}


/**
 * Post without action
 */
export type PostArgs = {
  /**
   * Select specific fields to fetch from the Post
  **/
  select?: PostSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: PostInclude | null
}



/**
 * Model User
 */

export type User = {
  id: number
  email: string
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
  string: string
  optionalString: string | null
  json: JsonValue
  optionalJson: JsonValue | null
  enum: ABeautifulEnum
  optionalEnum: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean: boolean | null
}


export type AggregateUser = {
  count: number
  avg: UserAvgAggregateOutputType | null
  sum: UserSumAggregateOutputType | null
  min: UserMinAggregateOutputType | null
  max: UserMaxAggregateOutputType | null
}

export type UserAvgAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type UserSumAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type UserMinAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type UserMaxAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}


export type UserAvgAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type UserSumAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type UserMinAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type UserMaxAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type AggregateUserArgs = {
  where?: UserWhereInput
  orderBy?: Enumerable<UserOrderByInput> | UserOrderByInput
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
  count?: true
  avg?: UserAvgAggregateInputType
  sum?: UserSumAggregateInputType
  min?: UserMinAggregateInputType
  max?: UserMaxAggregateInputType
}

export type GetUserAggregateType<T extends AggregateUserArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetUserAggregateScalarType<T[P]>
}

export type GetUserAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof UserAvgAggregateOutputType ? UserAvgAggregateOutputType[P] : never
}
    
    

export type UserSelect = {
  id?: boolean
  email?: boolean
  int?: boolean
  optionalInt?: boolean
  float?: boolean
  optionalFloat?: boolean
  string?: boolean
  optionalString?: boolean
  json?: boolean
  optionalJson?: boolean
  enum?: boolean
  optionalEnum?: boolean
  boolean?: boolean
  optionalBoolean?: boolean
  posts?: boolean | FindManyPostArgs
}

export type UserInclude = {
  posts?: boolean | FindManyPostArgs
}

export type UserGetPayload<
  S extends boolean | null | undefined | UserArgs,
  U = keyof S
> = S extends true
  ? User
  : S extends undefined
  ? never
  : S extends UserArgs | FindManyUserArgs
  ? 'include' extends U
    ? User  & {
      [P in TrueKeys<S['include']>]:
      P extends 'posts'
      ? Array<PostGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof User ? User[P]
: 
      P extends 'posts'
      ? Array<PostGetPayload<S['select'][P]>> : never
    }
  : User
: User


export interface UserDelegate {
  /**
   * Find zero or one User that matches the filter.
   * @param {FindOneUserArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneUserArgs>(
    args: Subset<T, FindOneUserArgs>
  ): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>
  /**
   * Find the first User that matches the filter.
   * @param {FindFirstUserArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstUserArgs>(
    args?: Subset<T, FindFirstUserArgs>
  ): CheckSelect<T, Prisma__UserClient<User | null>, Prisma__UserClient<UserGetPayload<T> | null>>
  /**
   * Find zero or more Users that matches the filter.
   * @param {FindManyUserArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Users
   * const users = await prisma.user.findMany()
   * 
   * // Get first 10 Users
   * const users = await prisma.user.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyUserArgs>(
    args?: Subset<T, FindManyUserArgs>
  ): CheckSelect<T, Promise<Array<User>>, Promise<Array<UserGetPayload<T>>>>
  /**
   * Create a User.
   * @param {UserCreateArgs} args - Arguments to create a User.
   * @example
   * // Create one User
   * const User = await prisma.user.create({
   *   data: {
   *     // ... data to create a User
   *   }
   * })
   * 
  **/
  create<T extends UserCreateArgs>(
    args: Subset<T, UserCreateArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Delete a User.
   * @param {UserDeleteArgs} args - Arguments to delete one User.
   * @example
   * // Delete one User
   * const User = await prisma.user.delete({
   *   where: {
   *     // ... filter to delete one User
   *   }
   * })
   * 
  **/
  delete<T extends UserDeleteArgs>(
    args: Subset<T, UserDeleteArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Update one User.
   * @param {UserUpdateArgs} args - Arguments to update one User.
   * @example
   * // Update one User
   * const user = await prisma.user.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends UserUpdateArgs>(
    args: Subset<T, UserUpdateArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Delete zero or more Users.
   * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
   * @example
   * // Delete a few Users
   * const { count } = await prisma.user.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends UserDeleteManyArgs>(
    args: Subset<T, UserDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Users.
   * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Users
   * const user = await prisma.user.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends UserUpdateManyArgs>(
    args: Subset<T, UserUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one User.
   * @param {UserUpsertArgs} args - Arguments to update or create a User.
   * @example
   * // Update or create a User
   * const user = await prisma.user.upsert({
   *   create: {
   *     // ... data to create a User
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the User we want to update
   *   }
   * })
  **/
  upsert<T extends UserUpsertArgs>(
    args: Subset<T, UserUpsertArgs>
  ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyUserArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateUserArgs>(args: Subset<T, AggregateUserArgs>): Promise<GetUserAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for User.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__UserClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  posts<T extends FindManyPostArgs = {}>(args?: Subset<T, FindManyPostArgs>): CheckSelect<T, Promise<Array<Post>>, Promise<Array<PostGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * User findOne
 */
export type FindOneUserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter, which User to fetch.
  **/
  where: UserWhereUniqueInput
}


/**
 * User findFirst
 */
export type FindFirstUserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter, which User to fetch.
  **/
  where?: UserWhereInput
  orderBy?: Enumerable<UserOrderByInput> | UserOrderByInput
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}


/**
 * User findMany
 */
export type FindManyUserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter, which Users to fetch.
  **/
  where?: UserWhereInput
  /**
   * Determine the order of the Users to fetch.
  **/
  orderBy?: Enumerable<UserOrderByInput> | UserOrderByInput
  /**
   * Sets the position for listing Users.
  **/
  cursor?: UserWhereUniqueInput
  /**
   * The number of Users to fetch. If negative number, it will take Users before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` Users.
  **/
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}


/**
 * User create
 */
export type UserCreateArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The data needed to create a User.
  **/
  data: UserCreateInput
}


/**
 * User update
 */
export type UserUpdateArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The data needed to update a User.
  **/
  data: UserUpdateInput
  /**
   * Choose, which User to update.
  **/
  where: UserWhereUniqueInput
}


/**
 * User updateMany
 */
export type UserUpdateManyArgs = {
  data: UserUpdateManyMutationInput
  where?: UserWhereInput
}


/**
 * User upsert
 */
export type UserUpsertArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * The filter to search for the User to update in case it exists.
  **/
  where: UserWhereUniqueInput
  /**
   * In case the User found by the \`where\` argument doesn't exist, create a new User with this data.
  **/
  create: UserCreateInput
  /**
   * In case the User was found with the provided \`where\` argument, update it with this data.
  **/
  update: UserUpdateInput
}


/**
 * User delete
 */
export type UserDeleteArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
  /**
   * Filter which User to delete.
  **/
  where: UserWhereUniqueInput
}


/**
 * User deleteMany
 */
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}


/**
 * User without action
 */
export type UserArgs = {
  /**
   * Select specific fields to fetch from the User
  **/
  select?: UserSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UserInclude | null
}



/**
 * Model M
 */

export type M = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
  string: string
  optionalString: string | null
  json: JsonValue
  optionalJson: JsonValue | null
  enum: ABeautifulEnum
  optionalEnum: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean: boolean | null
}


export type AggregateM = {
  count: number
  avg: MAvgAggregateOutputType | null
  sum: MSumAggregateOutputType | null
  min: MMinAggregateOutputType | null
  max: MMaxAggregateOutputType | null
}

export type MAvgAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type MSumAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type MMinAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type MMaxAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}


export type MAvgAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type MSumAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type MMinAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type MMaxAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type AggregateMArgs = {
  where?: MWhereInput
  orderBy?: Enumerable<MOrderByInput> | MOrderByInput
  cursor?: MWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MDistinctFieldEnum>
  count?: true
  avg?: MAvgAggregateInputType
  sum?: MSumAggregateInputType
  min?: MMinAggregateInputType
  max?: MMaxAggregateInputType
}

export type GetMAggregateType<T extends AggregateMArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetMAggregateScalarType<T[P]>
}

export type GetMAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof MAvgAggregateOutputType ? MAvgAggregateOutputType[P] : never
}
    
    

export type MSelect = {
  id?: boolean
  n?: boolean | FindManyNArgs
  int?: boolean
  optionalInt?: boolean
  float?: boolean
  optionalFloat?: boolean
  string?: boolean
  optionalString?: boolean
  json?: boolean
  optionalJson?: boolean
  enum?: boolean
  optionalEnum?: boolean
  boolean?: boolean
  optionalBoolean?: boolean
}

export type MInclude = {
  n?: boolean | FindManyNArgs
}

export type MGetPayload<
  S extends boolean | null | undefined | MArgs,
  U = keyof S
> = S extends true
  ? M
  : S extends undefined
  ? never
  : S extends MArgs | FindManyMArgs
  ? 'include' extends U
    ? M  & {
      [P in TrueKeys<S['include']>]:
      P extends 'n'
      ? Array<NGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof M ? M[P]
: 
      P extends 'n'
      ? Array<NGetPayload<S['select'][P]>> : never
    }
  : M
: M


export interface MDelegate {
  /**
   * Find zero or one M that matches the filter.
   * @param {FindOneMArgs} args - Arguments to find a M
   * @example
   * // Get one M
   * const m = await prisma.m.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneMArgs>(
    args: Subset<T, FindOneMArgs>
  ): CheckSelect<T, Prisma__MClient<M | null>, Prisma__MClient<MGetPayload<T> | null>>
  /**
   * Find the first M that matches the filter.
   * @param {FindFirstMArgs} args - Arguments to find a M
   * @example
   * // Get one M
   * const m = await prisma.m.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstMArgs>(
    args?: Subset<T, FindFirstMArgs>
  ): CheckSelect<T, Prisma__MClient<M | null>, Prisma__MClient<MGetPayload<T> | null>>
  /**
   * Find zero or more Ms that matches the filter.
   * @param {FindManyMArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Ms
   * const ms = await prisma.m.findMany()
   * 
   * // Get first 10 Ms
   * const ms = await prisma.m.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const mWithIdOnly = await prisma.m.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyMArgs>(
    args?: Subset<T, FindManyMArgs>
  ): CheckSelect<T, Promise<Array<M>>, Promise<Array<MGetPayload<T>>>>
  /**
   * Create a M.
   * @param {MCreateArgs} args - Arguments to create a M.
   * @example
   * // Create one M
   * const M = await prisma.m.create({
   *   data: {
   *     // ... data to create a M
   *   }
   * })
   * 
  **/
  create<T extends MCreateArgs>(
    args: Subset<T, MCreateArgs>
  ): CheckSelect<T, Prisma__MClient<M>, Prisma__MClient<MGetPayload<T>>>
  /**
   * Delete a M.
   * @param {MDeleteArgs} args - Arguments to delete one M.
   * @example
   * // Delete one M
   * const M = await prisma.m.delete({
   *   where: {
   *     // ... filter to delete one M
   *   }
   * })
   * 
  **/
  delete<T extends MDeleteArgs>(
    args: Subset<T, MDeleteArgs>
  ): CheckSelect<T, Prisma__MClient<M>, Prisma__MClient<MGetPayload<T>>>
  /**
   * Update one M.
   * @param {MUpdateArgs} args - Arguments to update one M.
   * @example
   * // Update one M
   * const m = await prisma.m.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends MUpdateArgs>(
    args: Subset<T, MUpdateArgs>
  ): CheckSelect<T, Prisma__MClient<M>, Prisma__MClient<MGetPayload<T>>>
  /**
   * Delete zero or more Ms.
   * @param {MDeleteManyArgs} args - Arguments to filter Ms to delete.
   * @example
   * // Delete a few Ms
   * const { count } = await prisma.m.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends MDeleteManyArgs>(
    args: Subset<T, MDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Ms.
   * @param {MUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Ms
   * const m = await prisma.m.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends MUpdateManyArgs>(
    args: Subset<T, MUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one M.
   * @param {MUpsertArgs} args - Arguments to update or create a M.
   * @example
   * // Update or create a M
   * const m = await prisma.m.upsert({
   *   create: {
   *     // ... data to create a M
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the M we want to update
   *   }
   * })
  **/
  upsert<T extends MUpsertArgs>(
    args: Subset<T, MUpsertArgs>
  ): CheckSelect<T, Prisma__MClient<M>, Prisma__MClient<MGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyMArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateMArgs>(args: Subset<T, AggregateMArgs>): Promise<GetMAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for M.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__MClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  n<T extends FindManyNArgs = {}>(args?: Subset<T, FindManyNArgs>): CheckSelect<T, Promise<Array<N>>, Promise<Array<NGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * M findOne
 */
export type FindOneMArgs = {
  /**
   * Select specific fields to fetch from the M
  **/
  select?: MSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MInclude | null
  /**
   * Filter, which M to fetch.
  **/
  where: MWhereUniqueInput
}


/**
 * M findFirst
 */
export type FindFirstMArgs = {
  /**
   * Select specific fields to fetch from the M
  **/
  select?: MSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MInclude | null
  /**
   * Filter, which M to fetch.
  **/
  where?: MWhereInput
  orderBy?: Enumerable<MOrderByInput> | MOrderByInput
  cursor?: MWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<MDistinctFieldEnum>
}


/**
 * M findMany
 */
export type FindManyMArgs = {
  /**
   * Select specific fields to fetch from the M
  **/
  select?: MSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MInclude | null
  /**
   * Filter, which MS to fetch.
  **/
  where?: MWhereInput
  /**
   * Determine the order of the MS to fetch.
  **/
  orderBy?: Enumerable<MOrderByInput> | MOrderByInput
  /**
   * Sets the position for listing MS.
  **/
  cursor?: MWhereUniqueInput
  /**
   * The number of MS to fetch. If negative number, it will take MS before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` MS.
  **/
  skip?: number
  distinct?: Enumerable<MDistinctFieldEnum>
}


/**
 * M create
 */
export type MCreateArgs = {
  /**
   * Select specific fields to fetch from the M
  **/
  select?: MSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MInclude | null
  /**
   * The data needed to create a M.
  **/
  data: MCreateInput
}


/**
 * M update
 */
export type MUpdateArgs = {
  /**
   * Select specific fields to fetch from the M
  **/
  select?: MSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MInclude | null
  /**
   * The data needed to update a M.
  **/
  data: MUpdateInput
  /**
   * Choose, which M to update.
  **/
  where: MWhereUniqueInput
}


/**
 * M updateMany
 */
export type MUpdateManyArgs = {
  data: MUpdateManyMutationInput
  where?: MWhereInput
}


/**
 * M upsert
 */
export type MUpsertArgs = {
  /**
   * Select specific fields to fetch from the M
  **/
  select?: MSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MInclude | null
  /**
   * The filter to search for the M to update in case it exists.
  **/
  where: MWhereUniqueInput
  /**
   * In case the M found by the \`where\` argument doesn't exist, create a new M with this data.
  **/
  create: MCreateInput
  /**
   * In case the M was found with the provided \`where\` argument, update it with this data.
  **/
  update: MUpdateInput
}


/**
 * M delete
 */
export type MDeleteArgs = {
  /**
   * Select specific fields to fetch from the M
  **/
  select?: MSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MInclude | null
  /**
   * Filter which M to delete.
  **/
  where: MWhereUniqueInput
}


/**
 * M deleteMany
 */
export type MDeleteManyArgs = {
  where?: MWhereInput
}


/**
 * M without action
 */
export type MArgs = {
  /**
   * Select specific fields to fetch from the M
  **/
  select?: MSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: MInclude | null
}



/**
 * Model N
 */

export type N = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
  string: string
  optionalString: string | null
  json: JsonValue
  optionalJson: JsonValue | null
  enum: ABeautifulEnum
  optionalEnum: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean: boolean | null
}


export type AggregateN = {
  count: number
  avg: NAvgAggregateOutputType | null
  sum: NSumAggregateOutputType | null
  min: NMinAggregateOutputType | null
  max: NMaxAggregateOutputType | null
}

export type NAvgAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type NSumAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type NMinAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type NMaxAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}


export type NAvgAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type NSumAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type NMinAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type NMaxAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type AggregateNArgs = {
  where?: NWhereInput
  orderBy?: Enumerable<NOrderByInput> | NOrderByInput
  cursor?: NWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<NDistinctFieldEnum>
  count?: true
  avg?: NAvgAggregateInputType
  sum?: NSumAggregateInputType
  min?: NMinAggregateInputType
  max?: NMaxAggregateInputType
}

export type GetNAggregateType<T extends AggregateNArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetNAggregateScalarType<T[P]>
}

export type GetNAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof NAvgAggregateOutputType ? NAvgAggregateOutputType[P] : never
}
    
    

export type NSelect = {
  id?: boolean
  m?: boolean | FindManyMArgs
  int?: boolean
  optionalInt?: boolean
  float?: boolean
  optionalFloat?: boolean
  string?: boolean
  optionalString?: boolean
  json?: boolean
  optionalJson?: boolean
  enum?: boolean
  optionalEnum?: boolean
  boolean?: boolean
  optionalBoolean?: boolean
}

export type NInclude = {
  m?: boolean | FindManyMArgs
}

export type NGetPayload<
  S extends boolean | null | undefined | NArgs,
  U = keyof S
> = S extends true
  ? N
  : S extends undefined
  ? never
  : S extends NArgs | FindManyNArgs
  ? 'include' extends U
    ? N  & {
      [P in TrueKeys<S['include']>]:
      P extends 'm'
      ? Array<MGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof N ? N[P]
: 
      P extends 'm'
      ? Array<MGetPayload<S['select'][P]>> : never
    }
  : N
: N


export interface NDelegate {
  /**
   * Find zero or one N that matches the filter.
   * @param {FindOneNArgs} args - Arguments to find a N
   * @example
   * // Get one N
   * const n = await prisma.n.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneNArgs>(
    args: Subset<T, FindOneNArgs>
  ): CheckSelect<T, Prisma__NClient<N | null>, Prisma__NClient<NGetPayload<T> | null>>
  /**
   * Find the first N that matches the filter.
   * @param {FindFirstNArgs} args - Arguments to find a N
   * @example
   * // Get one N
   * const n = await prisma.n.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstNArgs>(
    args?: Subset<T, FindFirstNArgs>
  ): CheckSelect<T, Prisma__NClient<N | null>, Prisma__NClient<NGetPayload<T> | null>>
  /**
   * Find zero or more Ns that matches the filter.
   * @param {FindManyNArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Ns
   * const ns = await prisma.n.findMany()
   * 
   * // Get first 10 Ns
   * const ns = await prisma.n.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const nWithIdOnly = await prisma.n.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyNArgs>(
    args?: Subset<T, FindManyNArgs>
  ): CheckSelect<T, Promise<Array<N>>, Promise<Array<NGetPayload<T>>>>
  /**
   * Create a N.
   * @param {NCreateArgs} args - Arguments to create a N.
   * @example
   * // Create one N
   * const N = await prisma.n.create({
   *   data: {
   *     // ... data to create a N
   *   }
   * })
   * 
  **/
  create<T extends NCreateArgs>(
    args: Subset<T, NCreateArgs>
  ): CheckSelect<T, Prisma__NClient<N>, Prisma__NClient<NGetPayload<T>>>
  /**
   * Delete a N.
   * @param {NDeleteArgs} args - Arguments to delete one N.
   * @example
   * // Delete one N
   * const N = await prisma.n.delete({
   *   where: {
   *     // ... filter to delete one N
   *   }
   * })
   * 
  **/
  delete<T extends NDeleteArgs>(
    args: Subset<T, NDeleteArgs>
  ): CheckSelect<T, Prisma__NClient<N>, Prisma__NClient<NGetPayload<T>>>
  /**
   * Update one N.
   * @param {NUpdateArgs} args - Arguments to update one N.
   * @example
   * // Update one N
   * const n = await prisma.n.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends NUpdateArgs>(
    args: Subset<T, NUpdateArgs>
  ): CheckSelect<T, Prisma__NClient<N>, Prisma__NClient<NGetPayload<T>>>
  /**
   * Delete zero or more Ns.
   * @param {NDeleteManyArgs} args - Arguments to filter Ns to delete.
   * @example
   * // Delete a few Ns
   * const { count } = await prisma.n.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends NDeleteManyArgs>(
    args: Subset<T, NDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Ns.
   * @param {NUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Ns
   * const n = await prisma.n.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends NUpdateManyArgs>(
    args: Subset<T, NUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one N.
   * @param {NUpsertArgs} args - Arguments to update or create a N.
   * @example
   * // Update or create a N
   * const n = await prisma.n.upsert({
   *   create: {
   *     // ... data to create a N
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the N we want to update
   *   }
   * })
  **/
  upsert<T extends NUpsertArgs>(
    args: Subset<T, NUpsertArgs>
  ): CheckSelect<T, Prisma__NClient<N>, Prisma__NClient<NGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyNArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateNArgs>(args: Subset<T, AggregateNArgs>): Promise<GetNAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for N.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__NClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  m<T extends FindManyMArgs = {}>(args?: Subset<T, FindManyMArgs>): CheckSelect<T, Promise<Array<M>>, Promise<Array<MGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * N findOne
 */
export type FindOneNArgs = {
  /**
   * Select specific fields to fetch from the N
  **/
  select?: NSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NInclude | null
  /**
   * Filter, which N to fetch.
  **/
  where: NWhereUniqueInput
}


/**
 * N findFirst
 */
export type FindFirstNArgs = {
  /**
   * Select specific fields to fetch from the N
  **/
  select?: NSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NInclude | null
  /**
   * Filter, which N to fetch.
  **/
  where?: NWhereInput
  orderBy?: Enumerable<NOrderByInput> | NOrderByInput
  cursor?: NWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<NDistinctFieldEnum>
}


/**
 * N findMany
 */
export type FindManyNArgs = {
  /**
   * Select specific fields to fetch from the N
  **/
  select?: NSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NInclude | null
  /**
   * Filter, which NS to fetch.
  **/
  where?: NWhereInput
  /**
   * Determine the order of the NS to fetch.
  **/
  orderBy?: Enumerable<NOrderByInput> | NOrderByInput
  /**
   * Sets the position for listing NS.
  **/
  cursor?: NWhereUniqueInput
  /**
   * The number of NS to fetch. If negative number, it will take NS before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` NS.
  **/
  skip?: number
  distinct?: Enumerable<NDistinctFieldEnum>
}


/**
 * N create
 */
export type NCreateArgs = {
  /**
   * Select specific fields to fetch from the N
  **/
  select?: NSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NInclude | null
  /**
   * The data needed to create a N.
  **/
  data: NCreateInput
}


/**
 * N update
 */
export type NUpdateArgs = {
  /**
   * Select specific fields to fetch from the N
  **/
  select?: NSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NInclude | null
  /**
   * The data needed to update a N.
  **/
  data: NUpdateInput
  /**
   * Choose, which N to update.
  **/
  where: NWhereUniqueInput
}


/**
 * N updateMany
 */
export type NUpdateManyArgs = {
  data: NUpdateManyMutationInput
  where?: NWhereInput
}


/**
 * N upsert
 */
export type NUpsertArgs = {
  /**
   * Select specific fields to fetch from the N
  **/
  select?: NSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NInclude | null
  /**
   * The filter to search for the N to update in case it exists.
  **/
  where: NWhereUniqueInput
  /**
   * In case the N found by the \`where\` argument doesn't exist, create a new N with this data.
  **/
  create: NCreateInput
  /**
   * In case the N was found with the provided \`where\` argument, update it with this data.
  **/
  update: NUpdateInput
}


/**
 * N delete
 */
export type NDeleteArgs = {
  /**
   * Select specific fields to fetch from the N
  **/
  select?: NSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NInclude | null
  /**
   * Filter which N to delete.
  **/
  where: NWhereUniqueInput
}


/**
 * N deleteMany
 */
export type NDeleteManyArgs = {
  where?: NWhereInput
}


/**
 * N without action
 */
export type NArgs = {
  /**
   * Select specific fields to fetch from the N
  **/
  select?: NSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: NInclude | null
}



/**
 * Model OneOptional
 */

export type OneOptional = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
  string: string
  optionalString: string | null
  json: JsonValue
  optionalJson: JsonValue | null
  enum: ABeautifulEnum
  optionalEnum: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean: boolean | null
}


export type AggregateOneOptional = {
  count: number
  avg: OneOptionalAvgAggregateOutputType | null
  sum: OneOptionalSumAggregateOutputType | null
  min: OneOptionalMinAggregateOutputType | null
  max: OneOptionalMaxAggregateOutputType | null
}

export type OneOptionalAvgAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type OneOptionalSumAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type OneOptionalMinAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type OneOptionalMaxAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}


export type OneOptionalAvgAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type OneOptionalSumAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type OneOptionalMinAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type OneOptionalMaxAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type AggregateOneOptionalArgs = {
  where?: OneOptionalWhereInput
  orderBy?: Enumerable<OneOptionalOrderByInput> | OneOptionalOrderByInput
  cursor?: OneOptionalWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OneOptionalDistinctFieldEnum>
  count?: true
  avg?: OneOptionalAvgAggregateInputType
  sum?: OneOptionalSumAggregateInputType
  min?: OneOptionalMinAggregateInputType
  max?: OneOptionalMaxAggregateInputType
}

export type GetOneOptionalAggregateType<T extends AggregateOneOptionalArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetOneOptionalAggregateScalarType<T[P]>
}

export type GetOneOptionalAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OneOptionalAvgAggregateOutputType ? OneOptionalAvgAggregateOutputType[P] : never
}
    
    

export type OneOptionalSelect = {
  id?: boolean
  many?: boolean | FindManyManyRequiredArgs
  int?: boolean
  optionalInt?: boolean
  float?: boolean
  optionalFloat?: boolean
  string?: boolean
  optionalString?: boolean
  json?: boolean
  optionalJson?: boolean
  enum?: boolean
  optionalEnum?: boolean
  boolean?: boolean
  optionalBoolean?: boolean
}

export type OneOptionalInclude = {
  many?: boolean | FindManyManyRequiredArgs
}

export type OneOptionalGetPayload<
  S extends boolean | null | undefined | OneOptionalArgs,
  U = keyof S
> = S extends true
  ? OneOptional
  : S extends undefined
  ? never
  : S extends OneOptionalArgs | FindManyOneOptionalArgs
  ? 'include' extends U
    ? OneOptional  & {
      [P in TrueKeys<S['include']>]:
      P extends 'many'
      ? Array<ManyRequiredGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof OneOptional ? OneOptional[P]
: 
      P extends 'many'
      ? Array<ManyRequiredGetPayload<S['select'][P]>> : never
    }
  : OneOptional
: OneOptional


export interface OneOptionalDelegate {
  /**
   * Find zero or one OneOptional that matches the filter.
   * @param {FindOneOneOptionalArgs} args - Arguments to find a OneOptional
   * @example
   * // Get one OneOptional
   * const oneOptional = await prisma.oneOptional.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneOneOptionalArgs>(
    args: Subset<T, FindOneOneOptionalArgs>
  ): CheckSelect<T, Prisma__OneOptionalClient<OneOptional | null>, Prisma__OneOptionalClient<OneOptionalGetPayload<T> | null>>
  /**
   * Find the first OneOptional that matches the filter.
   * @param {FindFirstOneOptionalArgs} args - Arguments to find a OneOptional
   * @example
   * // Get one OneOptional
   * const oneOptional = await prisma.oneOptional.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstOneOptionalArgs>(
    args?: Subset<T, FindFirstOneOptionalArgs>
  ): CheckSelect<T, Prisma__OneOptionalClient<OneOptional | null>, Prisma__OneOptionalClient<OneOptionalGetPayload<T> | null>>
  /**
   * Find zero or more OneOptionals that matches the filter.
   * @param {FindManyOneOptionalArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all OneOptionals
   * const oneOptionals = await prisma.oneOptional.findMany()
   * 
   * // Get first 10 OneOptionals
   * const oneOptionals = await prisma.oneOptional.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const oneOptionalWithIdOnly = await prisma.oneOptional.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyOneOptionalArgs>(
    args?: Subset<T, FindManyOneOptionalArgs>
  ): CheckSelect<T, Promise<Array<OneOptional>>, Promise<Array<OneOptionalGetPayload<T>>>>
  /**
   * Create a OneOptional.
   * @param {OneOptionalCreateArgs} args - Arguments to create a OneOptional.
   * @example
   * // Create one OneOptional
   * const OneOptional = await prisma.oneOptional.create({
   *   data: {
   *     // ... data to create a OneOptional
   *   }
   * })
   * 
  **/
  create<T extends OneOptionalCreateArgs>(
    args: Subset<T, OneOptionalCreateArgs>
  ): CheckSelect<T, Prisma__OneOptionalClient<OneOptional>, Prisma__OneOptionalClient<OneOptionalGetPayload<T>>>
  /**
   * Delete a OneOptional.
   * @param {OneOptionalDeleteArgs} args - Arguments to delete one OneOptional.
   * @example
   * // Delete one OneOptional
   * const OneOptional = await prisma.oneOptional.delete({
   *   where: {
   *     // ... filter to delete one OneOptional
   *   }
   * })
   * 
  **/
  delete<T extends OneOptionalDeleteArgs>(
    args: Subset<T, OneOptionalDeleteArgs>
  ): CheckSelect<T, Prisma__OneOptionalClient<OneOptional>, Prisma__OneOptionalClient<OneOptionalGetPayload<T>>>
  /**
   * Update one OneOptional.
   * @param {OneOptionalUpdateArgs} args - Arguments to update one OneOptional.
   * @example
   * // Update one OneOptional
   * const oneOptional = await prisma.oneOptional.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends OneOptionalUpdateArgs>(
    args: Subset<T, OneOptionalUpdateArgs>
  ): CheckSelect<T, Prisma__OneOptionalClient<OneOptional>, Prisma__OneOptionalClient<OneOptionalGetPayload<T>>>
  /**
   * Delete zero or more OneOptionals.
   * @param {OneOptionalDeleteManyArgs} args - Arguments to filter OneOptionals to delete.
   * @example
   * // Delete a few OneOptionals
   * const { count } = await prisma.oneOptional.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends OneOptionalDeleteManyArgs>(
    args: Subset<T, OneOptionalDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more OneOptionals.
   * @param {OneOptionalUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many OneOptionals
   * const oneOptional = await prisma.oneOptional.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends OneOptionalUpdateManyArgs>(
    args: Subset<T, OneOptionalUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one OneOptional.
   * @param {OneOptionalUpsertArgs} args - Arguments to update or create a OneOptional.
   * @example
   * // Update or create a OneOptional
   * const oneOptional = await prisma.oneOptional.upsert({
   *   create: {
   *     // ... data to create a OneOptional
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the OneOptional we want to update
   *   }
   * })
  **/
  upsert<T extends OneOptionalUpsertArgs>(
    args: Subset<T, OneOptionalUpsertArgs>
  ): CheckSelect<T, Prisma__OneOptionalClient<OneOptional>, Prisma__OneOptionalClient<OneOptionalGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyOneOptionalArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOneOptionalArgs>(args: Subset<T, AggregateOneOptionalArgs>): Promise<GetOneOptionalAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for OneOptional.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__OneOptionalClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  many<T extends FindManyManyRequiredArgs = {}>(args?: Subset<T, FindManyManyRequiredArgs>): CheckSelect<T, Promise<Array<ManyRequired>>, Promise<Array<ManyRequiredGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * OneOptional findOne
 */
export type FindOneOneOptionalArgs = {
  /**
   * Select specific fields to fetch from the OneOptional
  **/
  select?: OneOptionalSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OneOptionalInclude | null
  /**
   * Filter, which OneOptional to fetch.
  **/
  where: OneOptionalWhereUniqueInput
}


/**
 * OneOptional findFirst
 */
export type FindFirstOneOptionalArgs = {
  /**
   * Select specific fields to fetch from the OneOptional
  **/
  select?: OneOptionalSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OneOptionalInclude | null
  /**
   * Filter, which OneOptional to fetch.
  **/
  where?: OneOptionalWhereInput
  orderBy?: Enumerable<OneOptionalOrderByInput> | OneOptionalOrderByInput
  cursor?: OneOptionalWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OneOptionalDistinctFieldEnum>
}


/**
 * OneOptional findMany
 */
export type FindManyOneOptionalArgs = {
  /**
   * Select specific fields to fetch from the OneOptional
  **/
  select?: OneOptionalSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OneOptionalInclude | null
  /**
   * Filter, which OneOptionals to fetch.
  **/
  where?: OneOptionalWhereInput
  /**
   * Determine the order of the OneOptionals to fetch.
  **/
  orderBy?: Enumerable<OneOptionalOrderByInput> | OneOptionalOrderByInput
  /**
   * Sets the position for listing OneOptionals.
  **/
  cursor?: OneOptionalWhereUniqueInput
  /**
   * The number of OneOptionals to fetch. If negative number, it will take OneOptionals before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` OneOptionals.
  **/
  skip?: number
  distinct?: Enumerable<OneOptionalDistinctFieldEnum>
}


/**
 * OneOptional create
 */
export type OneOptionalCreateArgs = {
  /**
   * Select specific fields to fetch from the OneOptional
  **/
  select?: OneOptionalSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OneOptionalInclude | null
  /**
   * The data needed to create a OneOptional.
  **/
  data: OneOptionalCreateInput
}


/**
 * OneOptional update
 */
export type OneOptionalUpdateArgs = {
  /**
   * Select specific fields to fetch from the OneOptional
  **/
  select?: OneOptionalSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OneOptionalInclude | null
  /**
   * The data needed to update a OneOptional.
  **/
  data: OneOptionalUpdateInput
  /**
   * Choose, which OneOptional to update.
  **/
  where: OneOptionalWhereUniqueInput
}


/**
 * OneOptional updateMany
 */
export type OneOptionalUpdateManyArgs = {
  data: OneOptionalUpdateManyMutationInput
  where?: OneOptionalWhereInput
}


/**
 * OneOptional upsert
 */
export type OneOptionalUpsertArgs = {
  /**
   * Select specific fields to fetch from the OneOptional
  **/
  select?: OneOptionalSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OneOptionalInclude | null
  /**
   * The filter to search for the OneOptional to update in case it exists.
  **/
  where: OneOptionalWhereUniqueInput
  /**
   * In case the OneOptional found by the \`where\` argument doesn't exist, create a new OneOptional with this data.
  **/
  create: OneOptionalCreateInput
  /**
   * In case the OneOptional was found with the provided \`where\` argument, update it with this data.
  **/
  update: OneOptionalUpdateInput
}


/**
 * OneOptional delete
 */
export type OneOptionalDeleteArgs = {
  /**
   * Select specific fields to fetch from the OneOptional
  **/
  select?: OneOptionalSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OneOptionalInclude | null
  /**
   * Filter which OneOptional to delete.
  **/
  where: OneOptionalWhereUniqueInput
}


/**
 * OneOptional deleteMany
 */
export type OneOptionalDeleteManyArgs = {
  where?: OneOptionalWhereInput
}


/**
 * OneOptional without action
 */
export type OneOptionalArgs = {
  /**
   * Select specific fields to fetch from the OneOptional
  **/
  select?: OneOptionalSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OneOptionalInclude | null
}



/**
 * Model ManyRequired
 */

export type ManyRequired = {
  id: number
  oneOptionalId: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
  string: string
  optionalString: string | null
  json: JsonValue
  optionalJson: JsonValue | null
  enum: ABeautifulEnum
  optionalEnum: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean: boolean | null
}


export type AggregateManyRequired = {
  count: number
  avg: ManyRequiredAvgAggregateOutputType | null
  sum: ManyRequiredSumAggregateOutputType | null
  min: ManyRequiredMinAggregateOutputType | null
  max: ManyRequiredMaxAggregateOutputType | null
}

export type ManyRequiredAvgAggregateOutputType = {
  id: number
  oneOptionalId: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type ManyRequiredSumAggregateOutputType = {
  id: number
  oneOptionalId: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type ManyRequiredMinAggregateOutputType = {
  id: number
  oneOptionalId: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type ManyRequiredMaxAggregateOutputType = {
  id: number
  oneOptionalId: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}


export type ManyRequiredAvgAggregateInputType = {
  id?: true
  oneOptionalId?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type ManyRequiredSumAggregateInputType = {
  id?: true
  oneOptionalId?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type ManyRequiredMinAggregateInputType = {
  id?: true
  oneOptionalId?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type ManyRequiredMaxAggregateInputType = {
  id?: true
  oneOptionalId?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type AggregateManyRequiredArgs = {
  where?: ManyRequiredWhereInput
  orderBy?: Enumerable<ManyRequiredOrderByInput> | ManyRequiredOrderByInput
  cursor?: ManyRequiredWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ManyRequiredDistinctFieldEnum>
  count?: true
  avg?: ManyRequiredAvgAggregateInputType
  sum?: ManyRequiredSumAggregateInputType
  min?: ManyRequiredMinAggregateInputType
  max?: ManyRequiredMaxAggregateInputType
}

export type GetManyRequiredAggregateType<T extends AggregateManyRequiredArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetManyRequiredAggregateScalarType<T[P]>
}

export type GetManyRequiredAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ManyRequiredAvgAggregateOutputType ? ManyRequiredAvgAggregateOutputType[P] : never
}
    
    

export type ManyRequiredSelect = {
  id?: boolean
  one?: boolean | OneOptionalArgs
  oneOptionalId?: boolean
  int?: boolean
  optionalInt?: boolean
  float?: boolean
  optionalFloat?: boolean
  string?: boolean
  optionalString?: boolean
  json?: boolean
  optionalJson?: boolean
  enum?: boolean
  optionalEnum?: boolean
  boolean?: boolean
  optionalBoolean?: boolean
}

export type ManyRequiredInclude = {
  one?: boolean | OneOptionalArgs
}

export type ManyRequiredGetPayload<
  S extends boolean | null | undefined | ManyRequiredArgs,
  U = keyof S
> = S extends true
  ? ManyRequired
  : S extends undefined
  ? never
  : S extends ManyRequiredArgs | FindManyManyRequiredArgs
  ? 'include' extends U
    ? ManyRequired  & {
      [P in TrueKeys<S['include']>]:
      P extends 'one'
      ? OneOptionalGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof ManyRequired ? ManyRequired[P]
: 
      P extends 'one'
      ? OneOptionalGetPayload<S['select'][P]> | null : never
    }
  : ManyRequired
: ManyRequired


export interface ManyRequiredDelegate {
  /**
   * Find zero or one ManyRequired that matches the filter.
   * @param {FindOneManyRequiredArgs} args - Arguments to find a ManyRequired
   * @example
   * // Get one ManyRequired
   * const manyRequired = await prisma.manyRequired.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneManyRequiredArgs>(
    args: Subset<T, FindOneManyRequiredArgs>
  ): CheckSelect<T, Prisma__ManyRequiredClient<ManyRequired | null>, Prisma__ManyRequiredClient<ManyRequiredGetPayload<T> | null>>
  /**
   * Find the first ManyRequired that matches the filter.
   * @param {FindFirstManyRequiredArgs} args - Arguments to find a ManyRequired
   * @example
   * // Get one ManyRequired
   * const manyRequired = await prisma.manyRequired.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstManyRequiredArgs>(
    args?: Subset<T, FindFirstManyRequiredArgs>
  ): CheckSelect<T, Prisma__ManyRequiredClient<ManyRequired | null>, Prisma__ManyRequiredClient<ManyRequiredGetPayload<T> | null>>
  /**
   * Find zero or more ManyRequireds that matches the filter.
   * @param {FindManyManyRequiredArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ManyRequireds
   * const manyRequireds = await prisma.manyRequired.findMany()
   * 
   * // Get first 10 ManyRequireds
   * const manyRequireds = await prisma.manyRequired.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const manyRequiredWithIdOnly = await prisma.manyRequired.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyManyRequiredArgs>(
    args?: Subset<T, FindManyManyRequiredArgs>
  ): CheckSelect<T, Promise<Array<ManyRequired>>, Promise<Array<ManyRequiredGetPayload<T>>>>
  /**
   * Create a ManyRequired.
   * @param {ManyRequiredCreateArgs} args - Arguments to create a ManyRequired.
   * @example
   * // Create one ManyRequired
   * const ManyRequired = await prisma.manyRequired.create({
   *   data: {
   *     // ... data to create a ManyRequired
   *   }
   * })
   * 
  **/
  create<T extends ManyRequiredCreateArgs>(
    args: Subset<T, ManyRequiredCreateArgs>
  ): CheckSelect<T, Prisma__ManyRequiredClient<ManyRequired>, Prisma__ManyRequiredClient<ManyRequiredGetPayload<T>>>
  /**
   * Delete a ManyRequired.
   * @param {ManyRequiredDeleteArgs} args - Arguments to delete one ManyRequired.
   * @example
   * // Delete one ManyRequired
   * const ManyRequired = await prisma.manyRequired.delete({
   *   where: {
   *     // ... filter to delete one ManyRequired
   *   }
   * })
   * 
  **/
  delete<T extends ManyRequiredDeleteArgs>(
    args: Subset<T, ManyRequiredDeleteArgs>
  ): CheckSelect<T, Prisma__ManyRequiredClient<ManyRequired>, Prisma__ManyRequiredClient<ManyRequiredGetPayload<T>>>
  /**
   * Update one ManyRequired.
   * @param {ManyRequiredUpdateArgs} args - Arguments to update one ManyRequired.
   * @example
   * // Update one ManyRequired
   * const manyRequired = await prisma.manyRequired.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ManyRequiredUpdateArgs>(
    args: Subset<T, ManyRequiredUpdateArgs>
  ): CheckSelect<T, Prisma__ManyRequiredClient<ManyRequired>, Prisma__ManyRequiredClient<ManyRequiredGetPayload<T>>>
  /**
   * Delete zero or more ManyRequireds.
   * @param {ManyRequiredDeleteManyArgs} args - Arguments to filter ManyRequireds to delete.
   * @example
   * // Delete a few ManyRequireds
   * const { count } = await prisma.manyRequired.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ManyRequiredDeleteManyArgs>(
    args: Subset<T, ManyRequiredDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more ManyRequireds.
   * @param {ManyRequiredUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ManyRequireds
   * const manyRequired = await prisma.manyRequired.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ManyRequiredUpdateManyArgs>(
    args: Subset<T, ManyRequiredUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one ManyRequired.
   * @param {ManyRequiredUpsertArgs} args - Arguments to update or create a ManyRequired.
   * @example
   * // Update or create a ManyRequired
   * const manyRequired = await prisma.manyRequired.upsert({
   *   create: {
   *     // ... data to create a ManyRequired
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ManyRequired we want to update
   *   }
   * })
  **/
  upsert<T extends ManyRequiredUpsertArgs>(
    args: Subset<T, ManyRequiredUpsertArgs>
  ): CheckSelect<T, Prisma__ManyRequiredClient<ManyRequired>, Prisma__ManyRequiredClient<ManyRequiredGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyManyRequiredArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateManyRequiredArgs>(args: Subset<T, AggregateManyRequiredArgs>): Promise<GetManyRequiredAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for ManyRequired.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ManyRequiredClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  one<T extends OneOptionalArgs = {}>(args?: Subset<T, OneOptionalArgs>): CheckSelect<T, Prisma__OneOptionalClient<OneOptional | null>, Prisma__OneOptionalClient<OneOptionalGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * ManyRequired findOne
 */
export type FindOneManyRequiredArgs = {
  /**
   * Select specific fields to fetch from the ManyRequired
  **/
  select?: ManyRequiredSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ManyRequiredInclude | null
  /**
   * Filter, which ManyRequired to fetch.
  **/
  where: ManyRequiredWhereUniqueInput
}


/**
 * ManyRequired findFirst
 */
export type FindFirstManyRequiredArgs = {
  /**
   * Select specific fields to fetch from the ManyRequired
  **/
  select?: ManyRequiredSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ManyRequiredInclude | null
  /**
   * Filter, which ManyRequired to fetch.
  **/
  where?: ManyRequiredWhereInput
  orderBy?: Enumerable<ManyRequiredOrderByInput> | ManyRequiredOrderByInput
  cursor?: ManyRequiredWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ManyRequiredDistinctFieldEnum>
}


/**
 * ManyRequired findMany
 */
export type FindManyManyRequiredArgs = {
  /**
   * Select specific fields to fetch from the ManyRequired
  **/
  select?: ManyRequiredSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ManyRequiredInclude | null
  /**
   * Filter, which ManyRequireds to fetch.
  **/
  where?: ManyRequiredWhereInput
  /**
   * Determine the order of the ManyRequireds to fetch.
  **/
  orderBy?: Enumerable<ManyRequiredOrderByInput> | ManyRequiredOrderByInput
  /**
   * Sets the position for listing ManyRequireds.
  **/
  cursor?: ManyRequiredWhereUniqueInput
  /**
   * The number of ManyRequireds to fetch. If negative number, it will take ManyRequireds before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` ManyRequireds.
  **/
  skip?: number
  distinct?: Enumerable<ManyRequiredDistinctFieldEnum>
}


/**
 * ManyRequired create
 */
export type ManyRequiredCreateArgs = {
  /**
   * Select specific fields to fetch from the ManyRequired
  **/
  select?: ManyRequiredSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ManyRequiredInclude | null
  /**
   * The data needed to create a ManyRequired.
  **/
  data: ManyRequiredCreateInput
}


/**
 * ManyRequired update
 */
export type ManyRequiredUpdateArgs = {
  /**
   * Select specific fields to fetch from the ManyRequired
  **/
  select?: ManyRequiredSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ManyRequiredInclude | null
  /**
   * The data needed to update a ManyRequired.
  **/
  data: ManyRequiredUpdateInput
  /**
   * Choose, which ManyRequired to update.
  **/
  where: ManyRequiredWhereUniqueInput
}


/**
 * ManyRequired updateMany
 */
export type ManyRequiredUpdateManyArgs = {
  data: ManyRequiredUpdateManyMutationInput
  where?: ManyRequiredWhereInput
}


/**
 * ManyRequired upsert
 */
export type ManyRequiredUpsertArgs = {
  /**
   * Select specific fields to fetch from the ManyRequired
  **/
  select?: ManyRequiredSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ManyRequiredInclude | null
  /**
   * The filter to search for the ManyRequired to update in case it exists.
  **/
  where: ManyRequiredWhereUniqueInput
  /**
   * In case the ManyRequired found by the \`where\` argument doesn't exist, create a new ManyRequired with this data.
  **/
  create: ManyRequiredCreateInput
  /**
   * In case the ManyRequired was found with the provided \`where\` argument, update it with this data.
  **/
  update: ManyRequiredUpdateInput
}


/**
 * ManyRequired delete
 */
export type ManyRequiredDeleteArgs = {
  /**
   * Select specific fields to fetch from the ManyRequired
  **/
  select?: ManyRequiredSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ManyRequiredInclude | null
  /**
   * Filter which ManyRequired to delete.
  **/
  where: ManyRequiredWhereUniqueInput
}


/**
 * ManyRequired deleteMany
 */
export type ManyRequiredDeleteManyArgs = {
  where?: ManyRequiredWhereInput
}


/**
 * ManyRequired without action
 */
export type ManyRequiredArgs = {
  /**
   * Select specific fields to fetch from the ManyRequired
  **/
  select?: ManyRequiredSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ManyRequiredInclude | null
}



/**
 * Model OptionalSide1
 */

export type OptionalSide1 = {
  id: number
  optionalSide2Id: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
  string: string
  optionalString: string | null
  json: JsonValue
  optionalJson: JsonValue | null
  enum: ABeautifulEnum
  optionalEnum: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean: boolean | null
}


export type AggregateOptionalSide1 = {
  count: number
  avg: OptionalSide1AvgAggregateOutputType | null
  sum: OptionalSide1SumAggregateOutputType | null
  min: OptionalSide1MinAggregateOutputType | null
  max: OptionalSide1MaxAggregateOutputType | null
}

export type OptionalSide1AvgAggregateOutputType = {
  id: number
  optionalSide2Id: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type OptionalSide1SumAggregateOutputType = {
  id: number
  optionalSide2Id: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type OptionalSide1MinAggregateOutputType = {
  id: number
  optionalSide2Id: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type OptionalSide1MaxAggregateOutputType = {
  id: number
  optionalSide2Id: number | null
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}


export type OptionalSide1AvgAggregateInputType = {
  id?: true
  optionalSide2Id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type OptionalSide1SumAggregateInputType = {
  id?: true
  optionalSide2Id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type OptionalSide1MinAggregateInputType = {
  id?: true
  optionalSide2Id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type OptionalSide1MaxAggregateInputType = {
  id?: true
  optionalSide2Id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type AggregateOptionalSide1Args = {
  where?: OptionalSide1WhereInput
  orderBy?: Enumerable<OptionalSide1OrderByInput> | OptionalSide1OrderByInput
  cursor?: OptionalSide1WhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OptionalSide1DistinctFieldEnum>
  count?: true
  avg?: OptionalSide1AvgAggregateInputType
  sum?: OptionalSide1SumAggregateInputType
  min?: OptionalSide1MinAggregateInputType
  max?: OptionalSide1MaxAggregateInputType
}

export type GetOptionalSide1AggregateType<T extends AggregateOptionalSide1Args> = {
  [P in keyof T]: P extends 'count' ? number : GetOptionalSide1AggregateScalarType<T[P]>
}

export type GetOptionalSide1AggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OptionalSide1AvgAggregateOutputType ? OptionalSide1AvgAggregateOutputType[P] : never
}
    
    

export type OptionalSide1Select = {
  id?: boolean
  opti?: boolean | OptionalSide2Args
  optionalSide2Id?: boolean
  int?: boolean
  optionalInt?: boolean
  float?: boolean
  optionalFloat?: boolean
  string?: boolean
  optionalString?: boolean
  json?: boolean
  optionalJson?: boolean
  enum?: boolean
  optionalEnum?: boolean
  boolean?: boolean
  optionalBoolean?: boolean
}

export type OptionalSide1Include = {
  opti?: boolean | OptionalSide2Args
}

export type OptionalSide1GetPayload<
  S extends boolean | null | undefined | OptionalSide1Args,
  U = keyof S
> = S extends true
  ? OptionalSide1
  : S extends undefined
  ? never
  : S extends OptionalSide1Args | FindManyOptionalSide1Args
  ? 'include' extends U
    ? OptionalSide1  & {
      [P in TrueKeys<S['include']>]:
      P extends 'opti'
      ? OptionalSide2GetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof OptionalSide1 ? OptionalSide1[P]
: 
      P extends 'opti'
      ? OptionalSide2GetPayload<S['select'][P]> | null : never
    }
  : OptionalSide1
: OptionalSide1


export interface OptionalSide1Delegate {
  /**
   * Find zero or one OptionalSide1 that matches the filter.
   * @param {FindOneOptionalSide1Args} args - Arguments to find a OptionalSide1
   * @example
   * // Get one OptionalSide1
   * const optionalSide1 = await prisma.optionalSide1.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneOptionalSide1Args>(
    args: Subset<T, FindOneOptionalSide1Args>
  ): CheckSelect<T, Prisma__OptionalSide1Client<OptionalSide1 | null>, Prisma__OptionalSide1Client<OptionalSide1GetPayload<T> | null>>
  /**
   * Find the first OptionalSide1 that matches the filter.
   * @param {FindFirstOptionalSide1Args} args - Arguments to find a OptionalSide1
   * @example
   * // Get one OptionalSide1
   * const optionalSide1 = await prisma.optionalSide1.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstOptionalSide1Args>(
    args?: Subset<T, FindFirstOptionalSide1Args>
  ): CheckSelect<T, Prisma__OptionalSide1Client<OptionalSide1 | null>, Prisma__OptionalSide1Client<OptionalSide1GetPayload<T> | null>>
  /**
   * Find zero or more OptionalSide1s that matches the filter.
   * @param {FindManyOptionalSide1Args=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all OptionalSide1s
   * const optionalSide1s = await prisma.optionalSide1.findMany()
   * 
   * // Get first 10 OptionalSide1s
   * const optionalSide1s = await prisma.optionalSide1.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const optionalSide1WithIdOnly = await prisma.optionalSide1.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyOptionalSide1Args>(
    args?: Subset<T, FindManyOptionalSide1Args>
  ): CheckSelect<T, Promise<Array<OptionalSide1>>, Promise<Array<OptionalSide1GetPayload<T>>>>
  /**
   * Create a OptionalSide1.
   * @param {OptionalSide1CreateArgs} args - Arguments to create a OptionalSide1.
   * @example
   * // Create one OptionalSide1
   * const OptionalSide1 = await prisma.optionalSide1.create({
   *   data: {
   *     // ... data to create a OptionalSide1
   *   }
   * })
   * 
  **/
  create<T extends OptionalSide1CreateArgs>(
    args: Subset<T, OptionalSide1CreateArgs>
  ): CheckSelect<T, Prisma__OptionalSide1Client<OptionalSide1>, Prisma__OptionalSide1Client<OptionalSide1GetPayload<T>>>
  /**
   * Delete a OptionalSide1.
   * @param {OptionalSide1DeleteArgs} args - Arguments to delete one OptionalSide1.
   * @example
   * // Delete one OptionalSide1
   * const OptionalSide1 = await prisma.optionalSide1.delete({
   *   where: {
   *     // ... filter to delete one OptionalSide1
   *   }
   * })
   * 
  **/
  delete<T extends OptionalSide1DeleteArgs>(
    args: Subset<T, OptionalSide1DeleteArgs>
  ): CheckSelect<T, Prisma__OptionalSide1Client<OptionalSide1>, Prisma__OptionalSide1Client<OptionalSide1GetPayload<T>>>
  /**
   * Update one OptionalSide1.
   * @param {OptionalSide1UpdateArgs} args - Arguments to update one OptionalSide1.
   * @example
   * // Update one OptionalSide1
   * const optionalSide1 = await prisma.optionalSide1.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends OptionalSide1UpdateArgs>(
    args: Subset<T, OptionalSide1UpdateArgs>
  ): CheckSelect<T, Prisma__OptionalSide1Client<OptionalSide1>, Prisma__OptionalSide1Client<OptionalSide1GetPayload<T>>>
  /**
   * Delete zero or more OptionalSide1s.
   * @param {OptionalSide1DeleteManyArgs} args - Arguments to filter OptionalSide1s to delete.
   * @example
   * // Delete a few OptionalSide1s
   * const { count } = await prisma.optionalSide1.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends OptionalSide1DeleteManyArgs>(
    args: Subset<T, OptionalSide1DeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more OptionalSide1s.
   * @param {OptionalSide1UpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many OptionalSide1s
   * const optionalSide1 = await prisma.optionalSide1.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends OptionalSide1UpdateManyArgs>(
    args: Subset<T, OptionalSide1UpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one OptionalSide1.
   * @param {OptionalSide1UpsertArgs} args - Arguments to update or create a OptionalSide1.
   * @example
   * // Update or create a OptionalSide1
   * const optionalSide1 = await prisma.optionalSide1.upsert({
   *   create: {
   *     // ... data to create a OptionalSide1
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the OptionalSide1 we want to update
   *   }
   * })
  **/
  upsert<T extends OptionalSide1UpsertArgs>(
    args: Subset<T, OptionalSide1UpsertArgs>
  ): CheckSelect<T, Prisma__OptionalSide1Client<OptionalSide1>, Prisma__OptionalSide1Client<OptionalSide1GetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyOptionalSide1Args, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOptionalSide1Args>(args: Subset<T, AggregateOptionalSide1Args>): Promise<GetOptionalSide1AggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for OptionalSide1.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__OptionalSide1Client<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  opti<T extends OptionalSide2Args = {}>(args?: Subset<T, OptionalSide2Args>): CheckSelect<T, Prisma__OptionalSide2Client<OptionalSide2 | null>, Prisma__OptionalSide2Client<OptionalSide2GetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * OptionalSide1 findOne
 */
export type FindOneOptionalSide1Args = {
  /**
   * Select specific fields to fetch from the OptionalSide1
  **/
  select?: OptionalSide1Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide1Include | null
  /**
   * Filter, which OptionalSide1 to fetch.
  **/
  where: OptionalSide1WhereUniqueInput
}


/**
 * OptionalSide1 findFirst
 */
export type FindFirstOptionalSide1Args = {
  /**
   * Select specific fields to fetch from the OptionalSide1
  **/
  select?: OptionalSide1Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide1Include | null
  /**
   * Filter, which OptionalSide1 to fetch.
  **/
  where?: OptionalSide1WhereInput
  orderBy?: Enumerable<OptionalSide1OrderByInput> | OptionalSide1OrderByInput
  cursor?: OptionalSide1WhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OptionalSide1DistinctFieldEnum>
}


/**
 * OptionalSide1 findMany
 */
export type FindManyOptionalSide1Args = {
  /**
   * Select specific fields to fetch from the OptionalSide1
  **/
  select?: OptionalSide1Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide1Include | null
  /**
   * Filter, which OptionalSide1s to fetch.
  **/
  where?: OptionalSide1WhereInput
  /**
   * Determine the order of the OptionalSide1s to fetch.
  **/
  orderBy?: Enumerable<OptionalSide1OrderByInput> | OptionalSide1OrderByInput
  /**
   * Sets the position for listing OptionalSide1s.
  **/
  cursor?: OptionalSide1WhereUniqueInput
  /**
   * The number of OptionalSide1s to fetch. If negative number, it will take OptionalSide1s before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` OptionalSide1s.
  **/
  skip?: number
  distinct?: Enumerable<OptionalSide1DistinctFieldEnum>
}


/**
 * OptionalSide1 create
 */
export type OptionalSide1CreateArgs = {
  /**
   * Select specific fields to fetch from the OptionalSide1
  **/
  select?: OptionalSide1Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide1Include | null
  /**
   * The data needed to create a OptionalSide1.
  **/
  data: OptionalSide1CreateInput
}


/**
 * OptionalSide1 update
 */
export type OptionalSide1UpdateArgs = {
  /**
   * Select specific fields to fetch from the OptionalSide1
  **/
  select?: OptionalSide1Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide1Include | null
  /**
   * The data needed to update a OptionalSide1.
  **/
  data: OptionalSide1UpdateInput
  /**
   * Choose, which OptionalSide1 to update.
  **/
  where: OptionalSide1WhereUniqueInput
}


/**
 * OptionalSide1 updateMany
 */
export type OptionalSide1UpdateManyArgs = {
  data: OptionalSide1UpdateManyMutationInput
  where?: OptionalSide1WhereInput
}


/**
 * OptionalSide1 upsert
 */
export type OptionalSide1UpsertArgs = {
  /**
   * Select specific fields to fetch from the OptionalSide1
  **/
  select?: OptionalSide1Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide1Include | null
  /**
   * The filter to search for the OptionalSide1 to update in case it exists.
  **/
  where: OptionalSide1WhereUniqueInput
  /**
   * In case the OptionalSide1 found by the \`where\` argument doesn't exist, create a new OptionalSide1 with this data.
  **/
  create: OptionalSide1CreateInput
  /**
   * In case the OptionalSide1 was found with the provided \`where\` argument, update it with this data.
  **/
  update: OptionalSide1UpdateInput
}


/**
 * OptionalSide1 delete
 */
export type OptionalSide1DeleteArgs = {
  /**
   * Select specific fields to fetch from the OptionalSide1
  **/
  select?: OptionalSide1Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide1Include | null
  /**
   * Filter which OptionalSide1 to delete.
  **/
  where: OptionalSide1WhereUniqueInput
}


/**
 * OptionalSide1 deleteMany
 */
export type OptionalSide1DeleteManyArgs = {
  where?: OptionalSide1WhereInput
}


/**
 * OptionalSide1 without action
 */
export type OptionalSide1Args = {
  /**
   * Select specific fields to fetch from the OptionalSide1
  **/
  select?: OptionalSide1Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide1Include | null
}



/**
 * Model OptionalSide2
 */

export type OptionalSide2 = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
  string: string
  optionalString: string | null
  json: JsonValue
  optionalJson: JsonValue | null
  enum: ABeautifulEnum
  optionalEnum: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean: boolean | null
}


export type AggregateOptionalSide2 = {
  count: number
  avg: OptionalSide2AvgAggregateOutputType | null
  sum: OptionalSide2SumAggregateOutputType | null
  min: OptionalSide2MinAggregateOutputType | null
  max: OptionalSide2MaxAggregateOutputType | null
}

export type OptionalSide2AvgAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type OptionalSide2SumAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type OptionalSide2MinAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}

export type OptionalSide2MaxAggregateOutputType = {
  id: number
  int: number
  optionalInt: number | null
  float: number
  optionalFloat: number | null
}


export type OptionalSide2AvgAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type OptionalSide2SumAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type OptionalSide2MinAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type OptionalSide2MaxAggregateInputType = {
  id?: true
  int?: true
  optionalInt?: true
  float?: true
  optionalFloat?: true
}

export type AggregateOptionalSide2Args = {
  where?: OptionalSide2WhereInput
  orderBy?: Enumerable<OptionalSide2OrderByInput> | OptionalSide2OrderByInput
  cursor?: OptionalSide2WhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OptionalSide2DistinctFieldEnum>
  count?: true
  avg?: OptionalSide2AvgAggregateInputType
  sum?: OptionalSide2SumAggregateInputType
  min?: OptionalSide2MinAggregateInputType
  max?: OptionalSide2MaxAggregateInputType
}

export type GetOptionalSide2AggregateType<T extends AggregateOptionalSide2Args> = {
  [P in keyof T]: P extends 'count' ? number : GetOptionalSide2AggregateScalarType<T[P]>
}

export type GetOptionalSide2AggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OptionalSide2AvgAggregateOutputType ? OptionalSide2AvgAggregateOutputType[P] : never
}
    
    

export type OptionalSide2Select = {
  id?: boolean
  opti?: boolean | OptionalSide1Args
  int?: boolean
  optionalInt?: boolean
  float?: boolean
  optionalFloat?: boolean
  string?: boolean
  optionalString?: boolean
  json?: boolean
  optionalJson?: boolean
  enum?: boolean
  optionalEnum?: boolean
  boolean?: boolean
  optionalBoolean?: boolean
}

export type OptionalSide2Include = {
  opti?: boolean | OptionalSide1Args
}

export type OptionalSide2GetPayload<
  S extends boolean | null | undefined | OptionalSide2Args,
  U = keyof S
> = S extends true
  ? OptionalSide2
  : S extends undefined
  ? never
  : S extends OptionalSide2Args | FindManyOptionalSide2Args
  ? 'include' extends U
    ? OptionalSide2  & {
      [P in TrueKeys<S['include']>]:
      P extends 'opti'
      ? OptionalSide1GetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof OptionalSide2 ? OptionalSide2[P]
: 
      P extends 'opti'
      ? OptionalSide1GetPayload<S['select'][P]> | null : never
    }
  : OptionalSide2
: OptionalSide2


export interface OptionalSide2Delegate {
  /**
   * Find zero or one OptionalSide2 that matches the filter.
   * @param {FindOneOptionalSide2Args} args - Arguments to find a OptionalSide2
   * @example
   * // Get one OptionalSide2
   * const optionalSide2 = await prisma.optionalSide2.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneOptionalSide2Args>(
    args: Subset<T, FindOneOptionalSide2Args>
  ): CheckSelect<T, Prisma__OptionalSide2Client<OptionalSide2 | null>, Prisma__OptionalSide2Client<OptionalSide2GetPayload<T> | null>>
  /**
   * Find the first OptionalSide2 that matches the filter.
   * @param {FindFirstOptionalSide2Args} args - Arguments to find a OptionalSide2
   * @example
   * // Get one OptionalSide2
   * const optionalSide2 = await prisma.optionalSide2.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstOptionalSide2Args>(
    args?: Subset<T, FindFirstOptionalSide2Args>
  ): CheckSelect<T, Prisma__OptionalSide2Client<OptionalSide2 | null>, Prisma__OptionalSide2Client<OptionalSide2GetPayload<T> | null>>
  /**
   * Find zero or more OptionalSide2s that matches the filter.
   * @param {FindManyOptionalSide2Args=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all OptionalSide2s
   * const optionalSide2s = await prisma.optionalSide2.findMany()
   * 
   * // Get first 10 OptionalSide2s
   * const optionalSide2s = await prisma.optionalSide2.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const optionalSide2WithIdOnly = await prisma.optionalSide2.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyOptionalSide2Args>(
    args?: Subset<T, FindManyOptionalSide2Args>
  ): CheckSelect<T, Promise<Array<OptionalSide2>>, Promise<Array<OptionalSide2GetPayload<T>>>>
  /**
   * Create a OptionalSide2.
   * @param {OptionalSide2CreateArgs} args - Arguments to create a OptionalSide2.
   * @example
   * // Create one OptionalSide2
   * const OptionalSide2 = await prisma.optionalSide2.create({
   *   data: {
   *     // ... data to create a OptionalSide2
   *   }
   * })
   * 
  **/
  create<T extends OptionalSide2CreateArgs>(
    args: Subset<T, OptionalSide2CreateArgs>
  ): CheckSelect<T, Prisma__OptionalSide2Client<OptionalSide2>, Prisma__OptionalSide2Client<OptionalSide2GetPayload<T>>>
  /**
   * Delete a OptionalSide2.
   * @param {OptionalSide2DeleteArgs} args - Arguments to delete one OptionalSide2.
   * @example
   * // Delete one OptionalSide2
   * const OptionalSide2 = await prisma.optionalSide2.delete({
   *   where: {
   *     // ... filter to delete one OptionalSide2
   *   }
   * })
   * 
  **/
  delete<T extends OptionalSide2DeleteArgs>(
    args: Subset<T, OptionalSide2DeleteArgs>
  ): CheckSelect<T, Prisma__OptionalSide2Client<OptionalSide2>, Prisma__OptionalSide2Client<OptionalSide2GetPayload<T>>>
  /**
   * Update one OptionalSide2.
   * @param {OptionalSide2UpdateArgs} args - Arguments to update one OptionalSide2.
   * @example
   * // Update one OptionalSide2
   * const optionalSide2 = await prisma.optionalSide2.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends OptionalSide2UpdateArgs>(
    args: Subset<T, OptionalSide2UpdateArgs>
  ): CheckSelect<T, Prisma__OptionalSide2Client<OptionalSide2>, Prisma__OptionalSide2Client<OptionalSide2GetPayload<T>>>
  /**
   * Delete zero or more OptionalSide2s.
   * @param {OptionalSide2DeleteManyArgs} args - Arguments to filter OptionalSide2s to delete.
   * @example
   * // Delete a few OptionalSide2s
   * const { count } = await prisma.optionalSide2.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends OptionalSide2DeleteManyArgs>(
    args: Subset<T, OptionalSide2DeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more OptionalSide2s.
   * @param {OptionalSide2UpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many OptionalSide2s
   * const optionalSide2 = await prisma.optionalSide2.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends OptionalSide2UpdateManyArgs>(
    args: Subset<T, OptionalSide2UpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one OptionalSide2.
   * @param {OptionalSide2UpsertArgs} args - Arguments to update or create a OptionalSide2.
   * @example
   * // Update or create a OptionalSide2
   * const optionalSide2 = await prisma.optionalSide2.upsert({
   *   create: {
   *     // ... data to create a OptionalSide2
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the OptionalSide2 we want to update
   *   }
   * })
  **/
  upsert<T extends OptionalSide2UpsertArgs>(
    args: Subset<T, OptionalSide2UpsertArgs>
  ): CheckSelect<T, Prisma__OptionalSide2Client<OptionalSide2>, Prisma__OptionalSide2Client<OptionalSide2GetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyOptionalSide2Args, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOptionalSide2Args>(args: Subset<T, AggregateOptionalSide2Args>): Promise<GetOptionalSide2AggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for OptionalSide2.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__OptionalSide2Client<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  opti<T extends OptionalSide1Args = {}>(args?: Subset<T, OptionalSide1Args>): CheckSelect<T, Prisma__OptionalSide1Client<OptionalSide1 | null>, Prisma__OptionalSide1Client<OptionalSide1GetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * OptionalSide2 findOne
 */
export type FindOneOptionalSide2Args = {
  /**
   * Select specific fields to fetch from the OptionalSide2
  **/
  select?: OptionalSide2Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide2Include | null
  /**
   * Filter, which OptionalSide2 to fetch.
  **/
  where: OptionalSide2WhereUniqueInput
}


/**
 * OptionalSide2 findFirst
 */
export type FindFirstOptionalSide2Args = {
  /**
   * Select specific fields to fetch from the OptionalSide2
  **/
  select?: OptionalSide2Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide2Include | null
  /**
   * Filter, which OptionalSide2 to fetch.
  **/
  where?: OptionalSide2WhereInput
  orderBy?: Enumerable<OptionalSide2OrderByInput> | OptionalSide2OrderByInput
  cursor?: OptionalSide2WhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OptionalSide2DistinctFieldEnum>
}


/**
 * OptionalSide2 findMany
 */
export type FindManyOptionalSide2Args = {
  /**
   * Select specific fields to fetch from the OptionalSide2
  **/
  select?: OptionalSide2Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide2Include | null
  /**
   * Filter, which OptionalSide2s to fetch.
  **/
  where?: OptionalSide2WhereInput
  /**
   * Determine the order of the OptionalSide2s to fetch.
  **/
  orderBy?: Enumerable<OptionalSide2OrderByInput> | OptionalSide2OrderByInput
  /**
   * Sets the position for listing OptionalSide2s.
  **/
  cursor?: OptionalSide2WhereUniqueInput
  /**
   * The number of OptionalSide2s to fetch. If negative number, it will take OptionalSide2s before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` OptionalSide2s.
  **/
  skip?: number
  distinct?: Enumerable<OptionalSide2DistinctFieldEnum>
}


/**
 * OptionalSide2 create
 */
export type OptionalSide2CreateArgs = {
  /**
   * Select specific fields to fetch from the OptionalSide2
  **/
  select?: OptionalSide2Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide2Include | null
  /**
   * The data needed to create a OptionalSide2.
  **/
  data: OptionalSide2CreateInput
}


/**
 * OptionalSide2 update
 */
export type OptionalSide2UpdateArgs = {
  /**
   * Select specific fields to fetch from the OptionalSide2
  **/
  select?: OptionalSide2Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide2Include | null
  /**
   * The data needed to update a OptionalSide2.
  **/
  data: OptionalSide2UpdateInput
  /**
   * Choose, which OptionalSide2 to update.
  **/
  where: OptionalSide2WhereUniqueInput
}


/**
 * OptionalSide2 updateMany
 */
export type OptionalSide2UpdateManyArgs = {
  data: OptionalSide2UpdateManyMutationInput
  where?: OptionalSide2WhereInput
}


/**
 * OptionalSide2 upsert
 */
export type OptionalSide2UpsertArgs = {
  /**
   * Select specific fields to fetch from the OptionalSide2
  **/
  select?: OptionalSide2Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide2Include | null
  /**
   * The filter to search for the OptionalSide2 to update in case it exists.
  **/
  where: OptionalSide2WhereUniqueInput
  /**
   * In case the OptionalSide2 found by the \`where\` argument doesn't exist, create a new OptionalSide2 with this data.
  **/
  create: OptionalSide2CreateInput
  /**
   * In case the OptionalSide2 was found with the provided \`where\` argument, update it with this data.
  **/
  update: OptionalSide2UpdateInput
}


/**
 * OptionalSide2 delete
 */
export type OptionalSide2DeleteArgs = {
  /**
   * Select specific fields to fetch from the OptionalSide2
  **/
  select?: OptionalSide2Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide2Include | null
  /**
   * Filter which OptionalSide2 to delete.
  **/
  where: OptionalSide2WhereUniqueInput
}


/**
 * OptionalSide2 deleteMany
 */
export type OptionalSide2DeleteManyArgs = {
  where?: OptionalSide2WhereInput
}


/**
 * OptionalSide2 without action
 */
export type OptionalSide2Args = {
  /**
   * Select specific fields to fetch from the OptionalSide2
  **/
  select?: OptionalSide2Select | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OptionalSide2Include | null
}



/**
 * Model A
 */

export type A = {
  id: string
  email: string
  name: string | null
  int: number
  sInt: number
  bInt: number
  serial: number
  sSerial: number
  bSerial: number
  inc_int: number
  inc_sInt: number
  inc_bInt: number
}


export type AggregateA = {
  count: number
  avg: AAvgAggregateOutputType | null
  sum: ASumAggregateOutputType | null
  min: AMinAggregateOutputType | null
  max: AMaxAggregateOutputType | null
}

export type AAvgAggregateOutputType = {
  int: number
  sInt: number
  bInt: number
  serial: number
  sSerial: number
  bSerial: number
  inc_int: number
  inc_sInt: number
  inc_bInt: number
}

export type ASumAggregateOutputType = {
  int: number
  sInt: number
  bInt: number
  serial: number
  sSerial: number
  bSerial: number
  inc_int: number
  inc_sInt: number
  inc_bInt: number
}

export type AMinAggregateOutputType = {
  int: number
  sInt: number
  bInt: number
  serial: number
  sSerial: number
  bSerial: number
  inc_int: number
  inc_sInt: number
  inc_bInt: number
}

export type AMaxAggregateOutputType = {
  int: number
  sInt: number
  bInt: number
  serial: number
  sSerial: number
  bSerial: number
  inc_int: number
  inc_sInt: number
  inc_bInt: number
}


export type AAvgAggregateInputType = {
  int?: true
  sInt?: true
  bInt?: true
  serial?: true
  sSerial?: true
  bSerial?: true
  inc_int?: true
  inc_sInt?: true
  inc_bInt?: true
}

export type ASumAggregateInputType = {
  int?: true
  sInt?: true
  bInt?: true
  serial?: true
  sSerial?: true
  bSerial?: true
  inc_int?: true
  inc_sInt?: true
  inc_bInt?: true
}

export type AMinAggregateInputType = {
  int?: true
  sInt?: true
  bInt?: true
  serial?: true
  sSerial?: true
  bSerial?: true
  inc_int?: true
  inc_sInt?: true
  inc_bInt?: true
}

export type AMaxAggregateInputType = {
  int?: true
  sInt?: true
  bInt?: true
  serial?: true
  sSerial?: true
  bSerial?: true
  inc_int?: true
  inc_sInt?: true
  inc_bInt?: true
}

export type AggregateAArgs = {
  where?: AWhereInput
  orderBy?: Enumerable<AOrderByInput> | AOrderByInput
  cursor?: AWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ADistinctFieldEnum>
  count?: true
  avg?: AAvgAggregateInputType
  sum?: ASumAggregateInputType
  min?: AMinAggregateInputType
  max?: AMaxAggregateInputType
}

export type GetAAggregateType<T extends AggregateAArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetAAggregateScalarType<T[P]>
}

export type GetAAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof AAvgAggregateOutputType ? AAvgAggregateOutputType[P] : never
}
    
    

export type ASelect = {
  id?: boolean
  email?: boolean
  name?: boolean
  int?: boolean
  sInt?: boolean
  bInt?: boolean
  serial?: boolean
  sSerial?: boolean
  bSerial?: boolean
  inc_int?: boolean
  inc_sInt?: boolean
  inc_bInt?: boolean
}

export type AGetPayload<
  S extends boolean | null | undefined | AArgs,
  U = keyof S
> = S extends true
  ? A
  : S extends undefined
  ? never
  : S extends AArgs | FindManyAArgs
  ? 'include' extends U
    ? A 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof A ? A[P]
: 
 never
    }
  : A
: A


export interface ADelegate {
  /**
   * Find zero or one A that matches the filter.
   * @param {FindOneAArgs} args - Arguments to find a A
   * @example
   * // Get one A
   * const a = await prisma.a.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAArgs>(
    args: Subset<T, FindOneAArgs>
  ): CheckSelect<T, Prisma__AClient<A | null>, Prisma__AClient<AGetPayload<T> | null>>
  /**
   * Find the first A that matches the filter.
   * @param {FindFirstAArgs} args - Arguments to find a A
   * @example
   * // Get one A
   * const a = await prisma.a.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstAArgs>(
    args?: Subset<T, FindFirstAArgs>
  ): CheckSelect<T, Prisma__AClient<A | null>, Prisma__AClient<AGetPayload<T> | null>>
  /**
   * Find zero or more As that matches the filter.
   * @param {FindManyAArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all As
   * const as = await prisma.a.findMany()
   * 
   * // Get first 10 As
   * const as = await prisma.a.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const aWithIdOnly = await prisma.a.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAArgs>(
    args?: Subset<T, FindManyAArgs>
  ): CheckSelect<T, Promise<Array<A>>, Promise<Array<AGetPayload<T>>>>
  /**
   * Create a A.
   * @param {ACreateArgs} args - Arguments to create a A.
   * @example
   * // Create one A
   * const A = await prisma.a.create({
   *   data: {
   *     // ... data to create a A
   *   }
   * })
   * 
  **/
  create<T extends ACreateArgs>(
    args: Subset<T, ACreateArgs>
  ): CheckSelect<T, Prisma__AClient<A>, Prisma__AClient<AGetPayload<T>>>
  /**
   * Delete a A.
   * @param {ADeleteArgs} args - Arguments to delete one A.
   * @example
   * // Delete one A
   * const A = await prisma.a.delete({
   *   where: {
   *     // ... filter to delete one A
   *   }
   * })
   * 
  **/
  delete<T extends ADeleteArgs>(
    args: Subset<T, ADeleteArgs>
  ): CheckSelect<T, Prisma__AClient<A>, Prisma__AClient<AGetPayload<T>>>
  /**
   * Update one A.
   * @param {AUpdateArgs} args - Arguments to update one A.
   * @example
   * // Update one A
   * const a = await prisma.a.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AUpdateArgs>(
    args: Subset<T, AUpdateArgs>
  ): CheckSelect<T, Prisma__AClient<A>, Prisma__AClient<AGetPayload<T>>>
  /**
   * Delete zero or more As.
   * @param {ADeleteManyArgs} args - Arguments to filter As to delete.
   * @example
   * // Delete a few As
   * const { count } = await prisma.a.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ADeleteManyArgs>(
    args: Subset<T, ADeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more As.
   * @param {AUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many As
   * const a = await prisma.a.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AUpdateManyArgs>(
    args: Subset<T, AUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one A.
   * @param {AUpsertArgs} args - Arguments to update or create a A.
   * @example
   * // Update or create a A
   * const a = await prisma.a.upsert({
   *   create: {
   *     // ... data to create a A
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the A we want to update
   *   }
   * })
  **/
  upsert<T extends AUpsertArgs>(
    args: Subset<T, AUpsertArgs>
  ): CheckSelect<T, Prisma__AClient<A>, Prisma__AClient<AGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateAArgs>(args: Subset<T, AggregateAArgs>): Promise<GetAAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for A.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * A findOne
 */
export type FindOneAArgs = {
  /**
   * Select specific fields to fetch from the A
  **/
  select?: ASelect | null
  /**
   * Filter, which A to fetch.
  **/
  where: AWhereUniqueInput
}


/**
 * A findFirst
 */
export type FindFirstAArgs = {
  /**
   * Select specific fields to fetch from the A
  **/
  select?: ASelect | null
  /**
   * Filter, which A to fetch.
  **/
  where?: AWhereInput
  orderBy?: Enumerable<AOrderByInput> | AOrderByInput
  cursor?: AWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ADistinctFieldEnum>
}


/**
 * A findMany
 */
export type FindManyAArgs = {
  /**
   * Select specific fields to fetch from the A
  **/
  select?: ASelect | null
  /**
   * Filter, which AS to fetch.
  **/
  where?: AWhereInput
  /**
   * Determine the order of the AS to fetch.
  **/
  orderBy?: Enumerable<AOrderByInput> | AOrderByInput
  /**
   * Sets the position for listing AS.
  **/
  cursor?: AWhereUniqueInput
  /**
   * The number of AS to fetch. If negative number, it will take AS before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` AS.
  **/
  skip?: number
  distinct?: Enumerable<ADistinctFieldEnum>
}


/**
 * A create
 */
export type ACreateArgs = {
  /**
   * Select specific fields to fetch from the A
  **/
  select?: ASelect | null
  /**
   * The data needed to create a A.
  **/
  data: ACreateInput
}


/**
 * A update
 */
export type AUpdateArgs = {
  /**
   * Select specific fields to fetch from the A
  **/
  select?: ASelect | null
  /**
   * The data needed to update a A.
  **/
  data: AUpdateInput
  /**
   * Choose, which A to update.
  **/
  where: AWhereUniqueInput
}


/**
 * A updateMany
 */
export type AUpdateManyArgs = {
  data: AUpdateManyMutationInput
  where?: AWhereInput
}


/**
 * A upsert
 */
export type AUpsertArgs = {
  /**
   * Select specific fields to fetch from the A
  **/
  select?: ASelect | null
  /**
   * The filter to search for the A to update in case it exists.
  **/
  where: AWhereUniqueInput
  /**
   * In case the A found by the \`where\` argument doesn't exist, create a new A with this data.
  **/
  create: ACreateInput
  /**
   * In case the A was found with the provided \`where\` argument, update it with this data.
  **/
  update: AUpdateInput
}


/**
 * A delete
 */
export type ADeleteArgs = {
  /**
   * Select specific fields to fetch from the A
  **/
  select?: ASelect | null
  /**
   * Filter which A to delete.
  **/
  where: AWhereUniqueInput
}


/**
 * A deleteMany
 */
export type ADeleteManyArgs = {
  where?: AWhereInput
}


/**
 * A without action
 */
export type AArgs = {
  /**
   * Select specific fields to fetch from the A
  **/
  select?: ASelect | null
}



/**
 * Model B
 */

export type B = {
  id: string
  float: number
  dFloat: number
  decFloat: Decimal
  numFloat: Decimal
}


export type AggregateB = {
  count: number
  avg: BAvgAggregateOutputType | null
  sum: BSumAggregateOutputType | null
  min: BMinAggregateOutputType | null
  max: BMaxAggregateOutputType | null
}

export type BAvgAggregateOutputType = {
  float: number
  dFloat: number
  decFloat: Decimal
  numFloat: Decimal
}

export type BSumAggregateOutputType = {
  float: number
  dFloat: number
  decFloat: Decimal
  numFloat: Decimal
}

export type BMinAggregateOutputType = {
  float: number
  dFloat: number
  decFloat: Decimal
  numFloat: Decimal
}

export type BMaxAggregateOutputType = {
  float: number
  dFloat: number
  decFloat: Decimal
  numFloat: Decimal
}


export type BAvgAggregateInputType = {
  float?: true
  dFloat?: true
  decFloat?: true
  numFloat?: true
}

export type BSumAggregateInputType = {
  float?: true
  dFloat?: true
  decFloat?: true
  numFloat?: true
}

export type BMinAggregateInputType = {
  float?: true
  dFloat?: true
  decFloat?: true
  numFloat?: true
}

export type BMaxAggregateInputType = {
  float?: true
  dFloat?: true
  decFloat?: true
  numFloat?: true
}

export type AggregateBArgs = {
  where?: BWhereInput
  orderBy?: Enumerable<BOrderByInput> | BOrderByInput
  cursor?: BWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<BDistinctFieldEnum>
  count?: true
  avg?: BAvgAggregateInputType
  sum?: BSumAggregateInputType
  min?: BMinAggregateInputType
  max?: BMaxAggregateInputType
}

export type GetBAggregateType<T extends AggregateBArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetBAggregateScalarType<T[P]>
}

export type GetBAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof BAvgAggregateOutputType ? BAvgAggregateOutputType[P] : never
}
    
    

export type BSelect = {
  id?: boolean
  float?: boolean
  dFloat?: boolean
  decFloat?: boolean
  numFloat?: boolean
}

export type BGetPayload<
  S extends boolean | null | undefined | BArgs,
  U = keyof S
> = S extends true
  ? B
  : S extends undefined
  ? never
  : S extends BArgs | FindManyBArgs
  ? 'include' extends U
    ? B 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof B ? B[P]
: 
 never
    }
  : B
: B


export interface BDelegate {
  /**
   * Find zero or one B that matches the filter.
   * @param {FindOneBArgs} args - Arguments to find a B
   * @example
   * // Get one B
   * const b = await prisma.b.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneBArgs>(
    args: Subset<T, FindOneBArgs>
  ): CheckSelect<T, Prisma__BClient<B | null>, Prisma__BClient<BGetPayload<T> | null>>
  /**
   * Find the first B that matches the filter.
   * @param {FindFirstBArgs} args - Arguments to find a B
   * @example
   * // Get one B
   * const b = await prisma.b.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstBArgs>(
    args?: Subset<T, FindFirstBArgs>
  ): CheckSelect<T, Prisma__BClient<B | null>, Prisma__BClient<BGetPayload<T> | null>>
  /**
   * Find zero or more Bs that matches the filter.
   * @param {FindManyBArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Bs
   * const bs = await prisma.b.findMany()
   * 
   * // Get first 10 Bs
   * const bs = await prisma.b.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const bWithIdOnly = await prisma.b.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyBArgs>(
    args?: Subset<T, FindManyBArgs>
  ): CheckSelect<T, Promise<Array<B>>, Promise<Array<BGetPayload<T>>>>
  /**
   * Create a B.
   * @param {BCreateArgs} args - Arguments to create a B.
   * @example
   * // Create one B
   * const B = await prisma.b.create({
   *   data: {
   *     // ... data to create a B
   *   }
   * })
   * 
  **/
  create<T extends BCreateArgs>(
    args: Subset<T, BCreateArgs>
  ): CheckSelect<T, Prisma__BClient<B>, Prisma__BClient<BGetPayload<T>>>
  /**
   * Delete a B.
   * @param {BDeleteArgs} args - Arguments to delete one B.
   * @example
   * // Delete one B
   * const B = await prisma.b.delete({
   *   where: {
   *     // ... filter to delete one B
   *   }
   * })
   * 
  **/
  delete<T extends BDeleteArgs>(
    args: Subset<T, BDeleteArgs>
  ): CheckSelect<T, Prisma__BClient<B>, Prisma__BClient<BGetPayload<T>>>
  /**
   * Update one B.
   * @param {BUpdateArgs} args - Arguments to update one B.
   * @example
   * // Update one B
   * const b = await prisma.b.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends BUpdateArgs>(
    args: Subset<T, BUpdateArgs>
  ): CheckSelect<T, Prisma__BClient<B>, Prisma__BClient<BGetPayload<T>>>
  /**
   * Delete zero or more Bs.
   * @param {BDeleteManyArgs} args - Arguments to filter Bs to delete.
   * @example
   * // Delete a few Bs
   * const { count } = await prisma.b.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends BDeleteManyArgs>(
    args: Subset<T, BDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Bs.
   * @param {BUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Bs
   * const b = await prisma.b.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends BUpdateManyArgs>(
    args: Subset<T, BUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one B.
   * @param {BUpsertArgs} args - Arguments to update or create a B.
   * @example
   * // Update or create a B
   * const b = await prisma.b.upsert({
   *   create: {
   *     // ... data to create a B
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the B we want to update
   *   }
   * })
  **/
  upsert<T extends BUpsertArgs>(
    args: Subset<T, BUpsertArgs>
  ): CheckSelect<T, Prisma__BClient<B>, Prisma__BClient<BGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyBArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateBArgs>(args: Subset<T, AggregateBArgs>): Promise<GetBAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for B.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__BClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * B findOne
 */
export type FindOneBArgs = {
  /**
   * Select specific fields to fetch from the B
  **/
  select?: BSelect | null
  /**
   * Filter, which B to fetch.
  **/
  where: BWhereUniqueInput
}


/**
 * B findFirst
 */
export type FindFirstBArgs = {
  /**
   * Select specific fields to fetch from the B
  **/
  select?: BSelect | null
  /**
   * Filter, which B to fetch.
  **/
  where?: BWhereInput
  orderBy?: Enumerable<BOrderByInput> | BOrderByInput
  cursor?: BWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<BDistinctFieldEnum>
}


/**
 * B findMany
 */
export type FindManyBArgs = {
  /**
   * Select specific fields to fetch from the B
  **/
  select?: BSelect | null
  /**
   * Filter, which BS to fetch.
  **/
  where?: BWhereInput
  /**
   * Determine the order of the BS to fetch.
  **/
  orderBy?: Enumerable<BOrderByInput> | BOrderByInput
  /**
   * Sets the position for listing BS.
  **/
  cursor?: BWhereUniqueInput
  /**
   * The number of BS to fetch. If negative number, it will take BS before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` BS.
  **/
  skip?: number
  distinct?: Enumerable<BDistinctFieldEnum>
}


/**
 * B create
 */
export type BCreateArgs = {
  /**
   * Select specific fields to fetch from the B
  **/
  select?: BSelect | null
  /**
   * The data needed to create a B.
  **/
  data: BCreateInput
}


/**
 * B update
 */
export type BUpdateArgs = {
  /**
   * Select specific fields to fetch from the B
  **/
  select?: BSelect | null
  /**
   * The data needed to update a B.
  **/
  data: BUpdateInput
  /**
   * Choose, which B to update.
  **/
  where: BWhereUniqueInput
}


/**
 * B updateMany
 */
export type BUpdateManyArgs = {
  data: BUpdateManyMutationInput
  where?: BWhereInput
}


/**
 * B upsert
 */
export type BUpsertArgs = {
  /**
   * Select specific fields to fetch from the B
  **/
  select?: BSelect | null
  /**
   * The filter to search for the B to update in case it exists.
  **/
  where: BWhereUniqueInput
  /**
   * In case the B found by the \`where\` argument doesn't exist, create a new B with this data.
  **/
  create: BCreateInput
  /**
   * In case the B was found with the provided \`where\` argument, update it with this data.
  **/
  update: BUpdateInput
}


/**
 * B delete
 */
export type BDeleteArgs = {
  /**
   * Select specific fields to fetch from the B
  **/
  select?: BSelect | null
  /**
   * Filter which B to delete.
  **/
  where: BWhereUniqueInput
}


/**
 * B deleteMany
 */
export type BDeleteManyArgs = {
  where?: BWhereInput
}


/**
 * B without action
 */
export type BArgs = {
  /**
   * Select specific fields to fetch from the B
  **/
  select?: BSelect | null
}



/**
 * Model C
 */

export type C = {
  id: string
  char: string
  vChar: string
  text: string
  bit: string
  vBit: string
  uuid: string
}


export type AggregateC = {
  count: number
}



export type AggregateCArgs = {
  where?: CWhereInput
  orderBy?: Enumerable<COrderByInput> | COrderByInput
  cursor?: CWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<CDistinctFieldEnum>
  count?: true
}

export type GetCAggregateType<T extends AggregateCArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type CSelect = {
  id?: boolean
  char?: boolean
  vChar?: boolean
  text?: boolean
  bit?: boolean
  vBit?: boolean
  uuid?: boolean
}

export type CGetPayload<
  S extends boolean | null | undefined | CArgs,
  U = keyof S
> = S extends true
  ? C
  : S extends undefined
  ? never
  : S extends CArgs | FindManyCArgs
  ? 'include' extends U
    ? C 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof C ? C[P]
: 
 never
    }
  : C
: C


export interface CDelegate {
  /**
   * Find zero or one C that matches the filter.
   * @param {FindOneCArgs} args - Arguments to find a C
   * @example
   * // Get one C
   * const c = await prisma.c.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneCArgs>(
    args: Subset<T, FindOneCArgs>
  ): CheckSelect<T, Prisma__CClient<C | null>, Prisma__CClient<CGetPayload<T> | null>>
  /**
   * Find the first C that matches the filter.
   * @param {FindFirstCArgs} args - Arguments to find a C
   * @example
   * // Get one C
   * const c = await prisma.c.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstCArgs>(
    args?: Subset<T, FindFirstCArgs>
  ): CheckSelect<T, Prisma__CClient<C | null>, Prisma__CClient<CGetPayload<T> | null>>
  /**
   * Find zero or more Cs that matches the filter.
   * @param {FindManyCArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Cs
   * const cs = await prisma.c.findMany()
   * 
   * // Get first 10 Cs
   * const cs = await prisma.c.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const cWithIdOnly = await prisma.c.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyCArgs>(
    args?: Subset<T, FindManyCArgs>
  ): CheckSelect<T, Promise<Array<C>>, Promise<Array<CGetPayload<T>>>>
  /**
   * Create a C.
   * @param {CCreateArgs} args - Arguments to create a C.
   * @example
   * // Create one C
   * const C = await prisma.c.create({
   *   data: {
   *     // ... data to create a C
   *   }
   * })
   * 
  **/
  create<T extends CCreateArgs>(
    args: Subset<T, CCreateArgs>
  ): CheckSelect<T, Prisma__CClient<C>, Prisma__CClient<CGetPayload<T>>>
  /**
   * Delete a C.
   * @param {CDeleteArgs} args - Arguments to delete one C.
   * @example
   * // Delete one C
   * const C = await prisma.c.delete({
   *   where: {
   *     // ... filter to delete one C
   *   }
   * })
   * 
  **/
  delete<T extends CDeleteArgs>(
    args: Subset<T, CDeleteArgs>
  ): CheckSelect<T, Prisma__CClient<C>, Prisma__CClient<CGetPayload<T>>>
  /**
   * Update one C.
   * @param {CUpdateArgs} args - Arguments to update one C.
   * @example
   * // Update one C
   * const c = await prisma.c.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends CUpdateArgs>(
    args: Subset<T, CUpdateArgs>
  ): CheckSelect<T, Prisma__CClient<C>, Prisma__CClient<CGetPayload<T>>>
  /**
   * Delete zero or more Cs.
   * @param {CDeleteManyArgs} args - Arguments to filter Cs to delete.
   * @example
   * // Delete a few Cs
   * const { count } = await prisma.c.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends CDeleteManyArgs>(
    args: Subset<T, CDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Cs.
   * @param {CUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Cs
   * const c = await prisma.c.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends CUpdateManyArgs>(
    args: Subset<T, CUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one C.
   * @param {CUpsertArgs} args - Arguments to update or create a C.
   * @example
   * // Update or create a C
   * const c = await prisma.c.upsert({
   *   create: {
   *     // ... data to create a C
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the C we want to update
   *   }
   * })
  **/
  upsert<T extends CUpsertArgs>(
    args: Subset<T, CUpsertArgs>
  ): CheckSelect<T, Prisma__CClient<C>, Prisma__CClient<CGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyCArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateCArgs>(args: Subset<T, AggregateCArgs>): Promise<GetCAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for C.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__CClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * C findOne
 */
export type FindOneCArgs = {
  /**
   * Select specific fields to fetch from the C
  **/
  select?: CSelect | null
  /**
   * Filter, which C to fetch.
  **/
  where: CWhereUniqueInput
}


/**
 * C findFirst
 */
export type FindFirstCArgs = {
  /**
   * Select specific fields to fetch from the C
  **/
  select?: CSelect | null
  /**
   * Filter, which C to fetch.
  **/
  where?: CWhereInput
  orderBy?: Enumerable<COrderByInput> | COrderByInput
  cursor?: CWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<CDistinctFieldEnum>
}


/**
 * C findMany
 */
export type FindManyCArgs = {
  /**
   * Select specific fields to fetch from the C
  **/
  select?: CSelect | null
  /**
   * Filter, which CS to fetch.
  **/
  where?: CWhereInput
  /**
   * Determine the order of the CS to fetch.
  **/
  orderBy?: Enumerable<COrderByInput> | COrderByInput
  /**
   * Sets the position for listing CS.
  **/
  cursor?: CWhereUniqueInput
  /**
   * The number of CS to fetch. If negative number, it will take CS before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` CS.
  **/
  skip?: number
  distinct?: Enumerable<CDistinctFieldEnum>
}


/**
 * C create
 */
export type CCreateArgs = {
  /**
   * Select specific fields to fetch from the C
  **/
  select?: CSelect | null
  /**
   * The data needed to create a C.
  **/
  data: CCreateInput
}


/**
 * C update
 */
export type CUpdateArgs = {
  /**
   * Select specific fields to fetch from the C
  **/
  select?: CSelect | null
  /**
   * The data needed to update a C.
  **/
  data: CUpdateInput
  /**
   * Choose, which C to update.
  **/
  where: CWhereUniqueInput
}


/**
 * C updateMany
 */
export type CUpdateManyArgs = {
  data: CUpdateManyMutationInput
  where?: CWhereInput
}


/**
 * C upsert
 */
export type CUpsertArgs = {
  /**
   * Select specific fields to fetch from the C
  **/
  select?: CSelect | null
  /**
   * The filter to search for the C to update in case it exists.
  **/
  where: CWhereUniqueInput
  /**
   * In case the C found by the \`where\` argument doesn't exist, create a new C with this data.
  **/
  create: CCreateInput
  /**
   * In case the C was found with the provided \`where\` argument, update it with this data.
  **/
  update: CUpdateInput
}


/**
 * C delete
 */
export type CDeleteArgs = {
  /**
   * Select specific fields to fetch from the C
  **/
  select?: CSelect | null
  /**
   * Filter which C to delete.
  **/
  where: CWhereUniqueInput
}


/**
 * C deleteMany
 */
export type CDeleteManyArgs = {
  where?: CWhereInput
}


/**
 * C without action
 */
export type CArgs = {
  /**
   * Select specific fields to fetch from the C
  **/
  select?: CSelect | null
}



/**
 * Model D
 */

export type D = {
  id: string
  bool: boolean
  byteA: Buffer
  xml: string
  json: JsonValue
  jsonb: JsonValue
}


export type AggregateD = {
  count: number
}



export type AggregateDArgs = {
  where?: DWhereInput
  orderBy?: Enumerable<DOrderByInput> | DOrderByInput
  cursor?: DWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DDistinctFieldEnum>
  count?: true
}

export type GetDAggregateType<T extends AggregateDArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type DSelect = {
  id?: boolean
  bool?: boolean
  byteA?: boolean
  xml?: boolean
  json?: boolean
  jsonb?: boolean
}

export type DGetPayload<
  S extends boolean | null | undefined | DArgs,
  U = keyof S
> = S extends true
  ? D
  : S extends undefined
  ? never
  : S extends DArgs | FindManyDArgs
  ? 'include' extends U
    ? D 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof D ? D[P]
: 
 never
    }
  : D
: D


export interface DDelegate {
  /**
   * Find zero or one D that matches the filter.
   * @param {FindOneDArgs} args - Arguments to find a D
   * @example
   * // Get one D
   * const d = await prisma.d.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneDArgs>(
    args: Subset<T, FindOneDArgs>
  ): CheckSelect<T, Prisma__DClient<D | null>, Prisma__DClient<DGetPayload<T> | null>>
  /**
   * Find the first D that matches the filter.
   * @param {FindFirstDArgs} args - Arguments to find a D
   * @example
   * // Get one D
   * const d = await prisma.d.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstDArgs>(
    args?: Subset<T, FindFirstDArgs>
  ): CheckSelect<T, Prisma__DClient<D | null>, Prisma__DClient<DGetPayload<T> | null>>
  /**
   * Find zero or more Ds that matches the filter.
   * @param {FindManyDArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Ds
   * const ds = await prisma.d.findMany()
   * 
   * // Get first 10 Ds
   * const ds = await prisma.d.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const dWithIdOnly = await prisma.d.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyDArgs>(
    args?: Subset<T, FindManyDArgs>
  ): CheckSelect<T, Promise<Array<D>>, Promise<Array<DGetPayload<T>>>>
  /**
   * Create a D.
   * @param {DCreateArgs} args - Arguments to create a D.
   * @example
   * // Create one D
   * const D = await prisma.d.create({
   *   data: {
   *     // ... data to create a D
   *   }
   * })
   * 
  **/
  create<T extends DCreateArgs>(
    args: Subset<T, DCreateArgs>
  ): CheckSelect<T, Prisma__DClient<D>, Prisma__DClient<DGetPayload<T>>>
  /**
   * Delete a D.
   * @param {DDeleteArgs} args - Arguments to delete one D.
   * @example
   * // Delete one D
   * const D = await prisma.d.delete({
   *   where: {
   *     // ... filter to delete one D
   *   }
   * })
   * 
  **/
  delete<T extends DDeleteArgs>(
    args: Subset<T, DDeleteArgs>
  ): CheckSelect<T, Prisma__DClient<D>, Prisma__DClient<DGetPayload<T>>>
  /**
   * Update one D.
   * @param {DUpdateArgs} args - Arguments to update one D.
   * @example
   * // Update one D
   * const d = await prisma.d.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends DUpdateArgs>(
    args: Subset<T, DUpdateArgs>
  ): CheckSelect<T, Prisma__DClient<D>, Prisma__DClient<DGetPayload<T>>>
  /**
   * Delete zero or more Ds.
   * @param {DDeleteManyArgs} args - Arguments to filter Ds to delete.
   * @example
   * // Delete a few Ds
   * const { count } = await prisma.d.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends DDeleteManyArgs>(
    args: Subset<T, DDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Ds.
   * @param {DUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Ds
   * const d = await prisma.d.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends DUpdateManyArgs>(
    args: Subset<T, DUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one D.
   * @param {DUpsertArgs} args - Arguments to update or create a D.
   * @example
   * // Update or create a D
   * const d = await prisma.d.upsert({
   *   create: {
   *     // ... data to create a D
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the D we want to update
   *   }
   * })
  **/
  upsert<T extends DUpsertArgs>(
    args: Subset<T, DUpsertArgs>
  ): CheckSelect<T, Prisma__DClient<D>, Prisma__DClient<DGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyDArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateDArgs>(args: Subset<T, AggregateDArgs>): Promise<GetDAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for D.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__DClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * D findOne
 */
export type FindOneDArgs = {
  /**
   * Select specific fields to fetch from the D
  **/
  select?: DSelect | null
  /**
   * Filter, which D to fetch.
  **/
  where: DWhereUniqueInput
}


/**
 * D findFirst
 */
export type FindFirstDArgs = {
  /**
   * Select specific fields to fetch from the D
  **/
  select?: DSelect | null
  /**
   * Filter, which D to fetch.
  **/
  where?: DWhereInput
  orderBy?: Enumerable<DOrderByInput> | DOrderByInput
  cursor?: DWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DDistinctFieldEnum>
}


/**
 * D findMany
 */
export type FindManyDArgs = {
  /**
   * Select specific fields to fetch from the D
  **/
  select?: DSelect | null
  /**
   * Filter, which DS to fetch.
  **/
  where?: DWhereInput
  /**
   * Determine the order of the DS to fetch.
  **/
  orderBy?: Enumerable<DOrderByInput> | DOrderByInput
  /**
   * Sets the position for listing DS.
  **/
  cursor?: DWhereUniqueInput
  /**
   * The number of DS to fetch. If negative number, it will take DS before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` DS.
  **/
  skip?: number
  distinct?: Enumerable<DDistinctFieldEnum>
}


/**
 * D create
 */
export type DCreateArgs = {
  /**
   * Select specific fields to fetch from the D
  **/
  select?: DSelect | null
  /**
   * The data needed to create a D.
  **/
  data: DCreateInput
}


/**
 * D update
 */
export type DUpdateArgs = {
  /**
   * Select specific fields to fetch from the D
  **/
  select?: DSelect | null
  /**
   * The data needed to update a D.
  **/
  data: DUpdateInput
  /**
   * Choose, which D to update.
  **/
  where: DWhereUniqueInput
}


/**
 * D updateMany
 */
export type DUpdateManyArgs = {
  data: DUpdateManyMutationInput
  where?: DWhereInput
}


/**
 * D upsert
 */
export type DUpsertArgs = {
  /**
   * Select specific fields to fetch from the D
  **/
  select?: DSelect | null
  /**
   * The filter to search for the D to update in case it exists.
  **/
  where: DWhereUniqueInput
  /**
   * In case the D found by the \`where\` argument doesn't exist, create a new D with this data.
  **/
  create: DCreateInput
  /**
   * In case the D was found with the provided \`where\` argument, update it with this data.
  **/
  update: DUpdateInput
}


/**
 * D delete
 */
export type DDeleteArgs = {
  /**
   * Select specific fields to fetch from the D
  **/
  select?: DSelect | null
  /**
   * Filter which D to delete.
  **/
  where: DWhereUniqueInput
}


/**
 * D deleteMany
 */
export type DDeleteManyArgs = {
  where?: DWhereInput
}


/**
 * D without action
 */
export type DArgs = {
  /**
   * Select specific fields to fetch from the D
  **/
  select?: DSelect | null
}



/**
 * Model E
 */

export type E = {
  id: string
  date: Date
  time: Date
  ts: Date
}


export type AggregateE = {
  count: number
}



export type AggregateEArgs = {
  where?: EWhereInput
  orderBy?: Enumerable<EOrderByInput> | EOrderByInput
  cursor?: EWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EDistinctFieldEnum>
  count?: true
}

export type GetEAggregateType<T extends AggregateEArgs> = {
  [P in keyof T]: P extends 'count' ? number : never
}


    
    

export type ESelect = {
  id?: boolean
  date?: boolean
  time?: boolean
  ts?: boolean
}

export type EGetPayload<
  S extends boolean | null | undefined | EArgs,
  U = keyof S
> = S extends true
  ? E
  : S extends undefined
  ? never
  : S extends EArgs | FindManyEArgs
  ? 'include' extends U
    ? E 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof E ? E[P]
: 
 never
    }
  : E
: E


export interface EDelegate {
  /**
   * Find zero or one E that matches the filter.
   * @param {FindOneEArgs} args - Arguments to find a E
   * @example
   * // Get one E
   * const e = await prisma.e.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneEArgs>(
    args: Subset<T, FindOneEArgs>
  ): CheckSelect<T, Prisma__EClient<E | null>, Prisma__EClient<EGetPayload<T> | null>>
  /**
   * Find the first E that matches the filter.
   * @param {FindFirstEArgs} args - Arguments to find a E
   * @example
   * // Get one E
   * const e = await prisma.e.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstEArgs>(
    args?: Subset<T, FindFirstEArgs>
  ): CheckSelect<T, Prisma__EClient<E | null>, Prisma__EClient<EGetPayload<T> | null>>
  /**
   * Find zero or more Es that matches the filter.
   * @param {FindManyEArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Es
   * const es = await prisma.e.findMany()
   * 
   * // Get first 10 Es
   * const es = await prisma.e.findMany({ take: 10 })
   * 
   * // Only select the \`id\`
   * const eWithIdOnly = await prisma.e.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyEArgs>(
    args?: Subset<T, FindManyEArgs>
  ): CheckSelect<T, Promise<Array<E>>, Promise<Array<EGetPayload<T>>>>
  /**
   * Create a E.
   * @param {ECreateArgs} args - Arguments to create a E.
   * @example
   * // Create one E
   * const E = await prisma.e.create({
   *   data: {
   *     // ... data to create a E
   *   }
   * })
   * 
  **/
  create<T extends ECreateArgs>(
    args: Subset<T, ECreateArgs>
  ): CheckSelect<T, Prisma__EClient<E>, Prisma__EClient<EGetPayload<T>>>
  /**
   * Delete a E.
   * @param {EDeleteArgs} args - Arguments to delete one E.
   * @example
   * // Delete one E
   * const E = await prisma.e.delete({
   *   where: {
   *     // ... filter to delete one E
   *   }
   * })
   * 
  **/
  delete<T extends EDeleteArgs>(
    args: Subset<T, EDeleteArgs>
  ): CheckSelect<T, Prisma__EClient<E>, Prisma__EClient<EGetPayload<T>>>
  /**
   * Update one E.
   * @param {EUpdateArgs} args - Arguments to update one E.
   * @example
   * // Update one E
   * const e = await prisma.e.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends EUpdateArgs>(
    args: Subset<T, EUpdateArgs>
  ): CheckSelect<T, Prisma__EClient<E>, Prisma__EClient<EGetPayload<T>>>
  /**
   * Delete zero or more Es.
   * @param {EDeleteManyArgs} args - Arguments to filter Es to delete.
   * @example
   * // Delete a few Es
   * const { count } = await prisma.e.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends EDeleteManyArgs>(
    args: Subset<T, EDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Es.
   * @param {EUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Es
   * const e = await prisma.e.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends EUpdateManyArgs>(
    args: Subset<T, EUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one E.
   * @param {EUpsertArgs} args - Arguments to update or create a E.
   * @example
   * // Update or create a E
   * const e = await prisma.e.upsert({
   *   create: {
   *     // ... data to create a E
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the E we want to update
   *   }
   * })
  **/
  upsert<T extends EUpsertArgs>(
    args: Subset<T, EUpsertArgs>
  ): CheckSelect<T, Prisma__EClient<E>, Prisma__EClient<EGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyEArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateEArgs>(args: Subset<T, AggregateEArgs>): Promise<GetEAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for E.
 * Why is this prefixed with \`Prisma__\`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__EClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * E findOne
 */
export type FindOneEArgs = {
  /**
   * Select specific fields to fetch from the E
  **/
  select?: ESelect | null
  /**
   * Filter, which E to fetch.
  **/
  where: EWhereUniqueInput
}


/**
 * E findFirst
 */
export type FindFirstEArgs = {
  /**
   * Select specific fields to fetch from the E
  **/
  select?: ESelect | null
  /**
   * Filter, which E to fetch.
  **/
  where?: EWhereInput
  orderBy?: Enumerable<EOrderByInput> | EOrderByInput
  cursor?: EWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<EDistinctFieldEnum>
}


/**
 * E findMany
 */
export type FindManyEArgs = {
  /**
   * Select specific fields to fetch from the E
  **/
  select?: ESelect | null
  /**
   * Filter, which ES to fetch.
  **/
  where?: EWhereInput
  /**
   * Determine the order of the ES to fetch.
  **/
  orderBy?: Enumerable<EOrderByInput> | EOrderByInput
  /**
   * Sets the position for listing ES.
  **/
  cursor?: EWhereUniqueInput
  /**
   * The number of ES to fetch. If negative number, it will take ES before the \`cursor\`.
  **/
  take?: number
  /**
   * Skip the first \`n\` ES.
  **/
  skip?: number
  distinct?: Enumerable<EDistinctFieldEnum>
}


/**
 * E create
 */
export type ECreateArgs = {
  /**
   * Select specific fields to fetch from the E
  **/
  select?: ESelect | null
  /**
   * The data needed to create a E.
  **/
  data: ECreateInput
}


/**
 * E update
 */
export type EUpdateArgs = {
  /**
   * Select specific fields to fetch from the E
  **/
  select?: ESelect | null
  /**
   * The data needed to update a E.
  **/
  data: EUpdateInput
  /**
   * Choose, which E to update.
  **/
  where: EWhereUniqueInput
}


/**
 * E updateMany
 */
export type EUpdateManyArgs = {
  data: EUpdateManyMutationInput
  where?: EWhereInput
}


/**
 * E upsert
 */
export type EUpsertArgs = {
  /**
   * Select specific fields to fetch from the E
  **/
  select?: ESelect | null
  /**
   * The filter to search for the E to update in case it exists.
  **/
  where: EWhereUniqueInput
  /**
   * In case the E found by the \`where\` argument doesn't exist, create a new E with this data.
  **/
  create: ECreateInput
  /**
   * In case the E was found with the provided \`where\` argument, update it with this data.
  **/
  update: EUpdateInput
}


/**
 * E delete
 */
export type EDeleteArgs = {
  /**
   * Select specific fields to fetch from the E
  **/
  select?: ESelect | null
  /**
   * Filter which E to delete.
  **/
  where: EWhereUniqueInput
}


/**
 * E deleteMany
 */
export type EDeleteManyArgs = {
  where?: EWhereInput
}


/**
 * E without action
 */
export type EArgs = {
  /**
   * Select specific fields to fetch from the E
  **/
  select?: ESelect | null
}



/**
 * Deep Input Types
 */


export type PostWhereInput = {
  AND?: PostWhereInput | Enumerable<PostWhereInput>
  OR?: PostWhereInput | Enumerable<PostWhereInput>
  NOT?: PostWhereInput | Enumerable<PostWhereInput>
  id?: IntFilter | number
  createdAt?: DateTimeFilter | Date | string
  title?: StringFilter | string
  content?: StringNullableFilter | string | null
  published?: BoolFilter | boolean
  author?: UserRelationFilter | UserWhereInput
  authorId?: IntFilter | number
}

export type PostOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  title?: SortOrder
  content?: SortOrder
  published?: SortOrder
  authorId?: SortOrder
}

export type PostWhereUniqueInput = {
  id?: number
}

export type UserWhereInput = {
  AND?: UserWhereInput | Enumerable<UserWhereInput>
  OR?: UserWhereInput | Enumerable<UserWhereInput>
  NOT?: UserWhereInput | Enumerable<UserWhereInput>
  id?: IntFilter | number
  email?: StringFilter | string
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
  posts?: PostListRelationFilter
}

export type UserOrderByInput = {
  id?: SortOrder
  email?: SortOrder
  int?: SortOrder
  optionalInt?: SortOrder
  float?: SortOrder
  optionalFloat?: SortOrder
  string?: SortOrder
  optionalString?: SortOrder
  json?: SortOrder
  optionalJson?: SortOrder
  enum?: SortOrder
  optionalEnum?: SortOrder
  boolean?: SortOrder
  optionalBoolean?: SortOrder
}

export type UserWhereUniqueInput = {
  id?: number
  email?: string
}

export type MWhereInput = {
  AND?: MWhereInput | Enumerable<MWhereInput>
  OR?: MWhereInput | Enumerable<MWhereInput>
  NOT?: MWhereInput | Enumerable<MWhereInput>
  id?: IntFilter | number
  n?: NListRelationFilter
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
}

export type MOrderByInput = {
  id?: SortOrder
  int?: SortOrder
  optionalInt?: SortOrder
  float?: SortOrder
  optionalFloat?: SortOrder
  string?: SortOrder
  optionalString?: SortOrder
  json?: SortOrder
  optionalJson?: SortOrder
  enum?: SortOrder
  optionalEnum?: SortOrder
  boolean?: SortOrder
  optionalBoolean?: SortOrder
}

export type MWhereUniqueInput = {
  id?: number
}

export type NWhereInput = {
  AND?: NWhereInput | Enumerable<NWhereInput>
  OR?: NWhereInput | Enumerable<NWhereInput>
  NOT?: NWhereInput | Enumerable<NWhereInput>
  id?: IntFilter | number
  m?: MListRelationFilter
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
}

export type NOrderByInput = {
  id?: SortOrder
  int?: SortOrder
  optionalInt?: SortOrder
  float?: SortOrder
  optionalFloat?: SortOrder
  string?: SortOrder
  optionalString?: SortOrder
  json?: SortOrder
  optionalJson?: SortOrder
  enum?: SortOrder
  optionalEnum?: SortOrder
  boolean?: SortOrder
  optionalBoolean?: SortOrder
}

export type NWhereUniqueInput = {
  id?: number
}

export type OneOptionalWhereInput = {
  AND?: OneOptionalWhereInput | Enumerable<OneOptionalWhereInput>
  OR?: OneOptionalWhereInput | Enumerable<OneOptionalWhereInput>
  NOT?: OneOptionalWhereInput | Enumerable<OneOptionalWhereInput>
  id?: IntFilter | number
  many?: ManyRequiredListRelationFilter
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
}

export type OneOptionalOrderByInput = {
  id?: SortOrder
  int?: SortOrder
  optionalInt?: SortOrder
  float?: SortOrder
  optionalFloat?: SortOrder
  string?: SortOrder
  optionalString?: SortOrder
  json?: SortOrder
  optionalJson?: SortOrder
  enum?: SortOrder
  optionalEnum?: SortOrder
  boolean?: SortOrder
  optionalBoolean?: SortOrder
}

export type OneOptionalWhereUniqueInput = {
  id?: number
}

export type ManyRequiredWhereInput = {
  AND?: ManyRequiredWhereInput | Enumerable<ManyRequiredWhereInput>
  OR?: ManyRequiredWhereInput | Enumerable<ManyRequiredWhereInput>
  NOT?: ManyRequiredWhereInput | Enumerable<ManyRequiredWhereInput>
  id?: IntFilter | number
  one?: OneOptionalRelationFilter | OneOptionalWhereInput | null
  oneOptionalId?: IntNullableFilter | number | null
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
}

export type ManyRequiredOrderByInput = {
  id?: SortOrder
  oneOptionalId?: SortOrder
  int?: SortOrder
  optionalInt?: SortOrder
  float?: SortOrder
  optionalFloat?: SortOrder
  string?: SortOrder
  optionalString?: SortOrder
  json?: SortOrder
  optionalJson?: SortOrder
  enum?: SortOrder
  optionalEnum?: SortOrder
  boolean?: SortOrder
  optionalBoolean?: SortOrder
}

export type ManyRequiredWhereUniqueInput = {
  id?: number
}

export type OptionalSide1WhereInput = {
  AND?: OptionalSide1WhereInput | Enumerable<OptionalSide1WhereInput>
  OR?: OptionalSide1WhereInput | Enumerable<OptionalSide1WhereInput>
  NOT?: OptionalSide1WhereInput | Enumerable<OptionalSide1WhereInput>
  id?: IntFilter | number
  opti?: OptionalSide2RelationFilter | OptionalSide2WhereInput | null
  optionalSide2Id?: IntNullableFilter | number | null
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
}

export type OptionalSide1OrderByInput = {
  id?: SortOrder
  optionalSide2Id?: SortOrder
  int?: SortOrder
  optionalInt?: SortOrder
  float?: SortOrder
  optionalFloat?: SortOrder
  string?: SortOrder
  optionalString?: SortOrder
  json?: SortOrder
  optionalJson?: SortOrder
  enum?: SortOrder
  optionalEnum?: SortOrder
  boolean?: SortOrder
  optionalBoolean?: SortOrder
}

export type OptionalSide1WhereUniqueInput = {
  id?: number
}

export type OptionalSide2WhereInput = {
  AND?: OptionalSide2WhereInput | Enumerable<OptionalSide2WhereInput>
  OR?: OptionalSide2WhereInput | Enumerable<OptionalSide2WhereInput>
  NOT?: OptionalSide2WhereInput | Enumerable<OptionalSide2WhereInput>
  id?: IntFilter | number
  opti?: OptionalSide1RelationFilter | OptionalSide1WhereInput | null
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
}

export type OptionalSide2OrderByInput = {
  id?: SortOrder
  int?: SortOrder
  optionalInt?: SortOrder
  float?: SortOrder
  optionalFloat?: SortOrder
  string?: SortOrder
  optionalString?: SortOrder
  json?: SortOrder
  optionalJson?: SortOrder
  enum?: SortOrder
  optionalEnum?: SortOrder
  boolean?: SortOrder
  optionalBoolean?: SortOrder
}

export type OptionalSide2WhereUniqueInput = {
  id?: number
}

export type AWhereInput = {
  AND?: AWhereInput | Enumerable<AWhereInput>
  OR?: AWhereInput | Enumerable<AWhereInput>
  NOT?: AWhereInput | Enumerable<AWhereInput>
  id?: StringFilter | string
  email?: StringFilter | string
  name?: StringNullableFilter | string | null
  int?: IntFilter | number
  sInt?: IntFilter | number
  bInt?: IntFilter | number
  serial?: IntFilter | number
  sSerial?: IntFilter | number
  bSerial?: IntFilter | number
  inc_int?: IntFilter | number
  inc_sInt?: IntFilter | number
  inc_bInt?: IntFilter | number
}

export type AOrderByInput = {
  id?: SortOrder
  email?: SortOrder
  name?: SortOrder
  int?: SortOrder
  sInt?: SortOrder
  bInt?: SortOrder
  serial?: SortOrder
  sSerial?: SortOrder
  bSerial?: SortOrder
  inc_int?: SortOrder
  inc_sInt?: SortOrder
  inc_bInt?: SortOrder
}

export type AWhereUniqueInput = {
  id?: string
  email?: string
}

export type BWhereInput = {
  AND?: BWhereInput | Enumerable<BWhereInput>
  OR?: BWhereInput | Enumerable<BWhereInput>
  NOT?: BWhereInput | Enumerable<BWhereInput>
  id?: StringFilter | string
  float?: FloatFilter | number
  dFloat?: FloatFilter | number
  decFloat?: DecimalFilter | Decimal
  numFloat?: DecimalFilter | Decimal
}

export type BOrderByInput = {
  id?: SortOrder
  float?: SortOrder
  dFloat?: SortOrder
  decFloat?: SortOrder
  numFloat?: SortOrder
}

export type BWhereUniqueInput = {
  id?: string
}

export type CWhereInput = {
  AND?: CWhereInput | Enumerable<CWhereInput>
  OR?: CWhereInput | Enumerable<CWhereInput>
  NOT?: CWhereInput | Enumerable<CWhereInput>
  id?: StringFilter | string
  char?: StringFilter | string
  vChar?: StringFilter | string
  text?: StringFilter | string
  bit?: StringFilter | string
  vBit?: StringFilter | string
  uuid?: StringFilter | string
}

export type COrderByInput = {
  id?: SortOrder
  char?: SortOrder
  vChar?: SortOrder
  text?: SortOrder
  bit?: SortOrder
  vBit?: SortOrder
  uuid?: SortOrder
}

export type CWhereUniqueInput = {
  id?: string
}

export type DWhereInput = {
  AND?: DWhereInput | Enumerable<DWhereInput>
  OR?: DWhereInput | Enumerable<DWhereInput>
  NOT?: DWhereInput | Enumerable<DWhereInput>
  id?: StringFilter | string
  bool?: BoolFilter | boolean
  byteA?: BytesFilter | Buffer
  xml?: StringFilter | string
  json?: JsonFilter
  jsonb?: JsonFilter
}

export type DOrderByInput = {
  id?: SortOrder
  bool?: SortOrder
  byteA?: SortOrder
  xml?: SortOrder
  json?: SortOrder
  jsonb?: SortOrder
}

export type DWhereUniqueInput = {
  id?: string
}

export type EWhereInput = {
  AND?: EWhereInput | Enumerable<EWhereInput>
  OR?: EWhereInput | Enumerable<EWhereInput>
  NOT?: EWhereInput | Enumerable<EWhereInput>
  id?: StringFilter | string
  date?: DateTimeFilter | Date | string
  time?: DateTimeFilter | Date | string
  ts?: DateTimeFilter | Date | string
}

export type EOrderByInput = {
  id?: SortOrder
  date?: SortOrder
  time?: SortOrder
  ts?: SortOrder
}

export type EWhereUniqueInput = {
  id?: string
}

export type PostCreateInput = {
  createdAt?: Date | string
  title: string
  content?: string | null
  published?: boolean
  author: UserCreateOneWithoutPostsInput
}

export type PostUpdateInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  content?: string | NullableStringFieldUpdateOperationsInput | null
  published?: boolean | BoolFieldUpdateOperationsInput
  author?: UserUpdateOneRequiredWithoutPostsInput
}

export type PostUpdateManyMutationInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  content?: string | NullableStringFieldUpdateOperationsInput | null
  published?: boolean | BoolFieldUpdateOperationsInput
}

export type UserCreateInput = {
  email: string
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
  posts?: PostCreateManyWithoutAuthorInput
}

export type UserUpdateInput = {
  email?: string | StringFieldUpdateOperationsInput
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
  posts?: PostUpdateManyWithoutAuthorInput
}

export type UserUpdateManyMutationInput = {
  email?: string | StringFieldUpdateOperationsInput
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type MCreateInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
  n?: NCreateManyWithoutMInput
}

export type MUpdateInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
  n?: NUpdateManyWithoutMInput
}

export type MUpdateManyMutationInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type NCreateInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
  m?: MCreateManyWithoutNInput
}

export type NUpdateInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
  m?: MUpdateManyWithoutNInput
}

export type NUpdateManyMutationInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type OneOptionalCreateInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
  many?: ManyRequiredCreateManyWithoutOneInput
}

export type OneOptionalUpdateInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
  many?: ManyRequiredUpdateManyWithoutOneInput
}

export type OneOptionalUpdateManyMutationInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type ManyRequiredCreateInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
  one?: OneOptionalCreateOneWithoutManyInput
}

export type ManyRequiredUpdateInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
  one?: OneOptionalUpdateOneWithoutManyInput
}

export type ManyRequiredUpdateManyMutationInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type OptionalSide1CreateInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
  opti?: OptionalSide2CreateOneWithoutOptiInput
}

export type OptionalSide1UpdateInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
  opti?: OptionalSide2UpdateOneWithoutOptiInput
}

export type OptionalSide1UpdateManyMutationInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type OptionalSide2CreateInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
  opti?: OptionalSide1CreateOneWithoutOptiInput
}

export type OptionalSide2UpdateInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
  opti?: OptionalSide1UpdateOneWithoutOptiInput
}

export type OptionalSide2UpdateManyMutationInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type ACreateInput = {
  id?: string
  email: string
  name?: string | null
  int: number
  sInt: number
  bInt: number
  serial?: number
  sSerial?: number
  bSerial?: number
  inc_int?: number
  inc_sInt?: number
  inc_bInt?: number
}

export type AUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  int?: number | IntFieldUpdateOperationsInput
  sInt?: number | IntFieldUpdateOperationsInput
  bInt?: number | IntFieldUpdateOperationsInput
  serial?: number | IntFieldUpdateOperationsInput
  sSerial?: number | IntFieldUpdateOperationsInput
  bSerial?: number | IntFieldUpdateOperationsInput
  inc_int?: number | IntFieldUpdateOperationsInput
  inc_sInt?: number | IntFieldUpdateOperationsInput
  inc_bInt?: number | IntFieldUpdateOperationsInput
}

export type AUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  email?: string | StringFieldUpdateOperationsInput
  name?: string | NullableStringFieldUpdateOperationsInput | null
  int?: number | IntFieldUpdateOperationsInput
  sInt?: number | IntFieldUpdateOperationsInput
  bInt?: number | IntFieldUpdateOperationsInput
  serial?: number | IntFieldUpdateOperationsInput
  sSerial?: number | IntFieldUpdateOperationsInput
  bSerial?: number | IntFieldUpdateOperationsInput
  inc_int?: number | IntFieldUpdateOperationsInput
  inc_sInt?: number | IntFieldUpdateOperationsInput
  inc_bInt?: number | IntFieldUpdateOperationsInput
}

export type BCreateInput = {
  id?: string
  float: number
  dFloat: number
  decFloat: Decimal
  numFloat: Decimal
}

export type BUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  float?: number | FloatFieldUpdateOperationsInput
  dFloat?: number | FloatFieldUpdateOperationsInput
  decFloat?: Decimal | DecimalFieldUpdateOperationsInput
  numFloat?: Decimal | DecimalFieldUpdateOperationsInput
}

export type BUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  float?: number | FloatFieldUpdateOperationsInput
  dFloat?: number | FloatFieldUpdateOperationsInput
  decFloat?: Decimal | DecimalFieldUpdateOperationsInput
  numFloat?: Decimal | DecimalFieldUpdateOperationsInput
}

export type CCreateInput = {
  id?: string
  char: string
  vChar: string
  text: string
  bit: string
  vBit: string
  uuid: string
}

export type CUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  char?: string | StringFieldUpdateOperationsInput
  vChar?: string | StringFieldUpdateOperationsInput
  text?: string | StringFieldUpdateOperationsInput
  bit?: string | StringFieldUpdateOperationsInput
  vBit?: string | StringFieldUpdateOperationsInput
  uuid?: string | StringFieldUpdateOperationsInput
}

export type CUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  char?: string | StringFieldUpdateOperationsInput
  vChar?: string | StringFieldUpdateOperationsInput
  text?: string | StringFieldUpdateOperationsInput
  bit?: string | StringFieldUpdateOperationsInput
  vBit?: string | StringFieldUpdateOperationsInput
  uuid?: string | StringFieldUpdateOperationsInput
}

export type DCreateInput = {
  id?: string
  bool: boolean
  byteA: Buffer
  xml: string
  json: InputJsonValue
  jsonb: InputJsonValue
}

export type DUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  bool?: boolean | BoolFieldUpdateOperationsInput
  byteA?: Buffer | BytesFieldUpdateOperationsInput
  xml?: string | StringFieldUpdateOperationsInput
  json?: InputJsonValue
  jsonb?: InputJsonValue
}

export type DUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  bool?: boolean | BoolFieldUpdateOperationsInput
  byteA?: Buffer | BytesFieldUpdateOperationsInput
  xml?: string | StringFieldUpdateOperationsInput
  json?: InputJsonValue
  jsonb?: InputJsonValue
}

export type ECreateInput = {
  id?: string
  date: Date | string
  time: Date | string
  ts: Date | string
}

export type EUpdateInput = {
  id?: string | StringFieldUpdateOperationsInput
  date?: Date | string | DateTimeFieldUpdateOperationsInput
  time?: Date | string | DateTimeFieldUpdateOperationsInput
  ts?: Date | string | DateTimeFieldUpdateOperationsInput
}

export type EUpdateManyMutationInput = {
  id?: string | StringFieldUpdateOperationsInput
  date?: Date | string | DateTimeFieldUpdateOperationsInput
  time?: Date | string | DateTimeFieldUpdateOperationsInput
  ts?: Date | string | DateTimeFieldUpdateOperationsInput
}

export type IntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type DateTimeFilter = {
  equals?: Date | string
  in?: Enumerable<Date> | Enumerable<string>
  notIn?: Enumerable<Date> | Enumerable<string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeFilter
}

export type StringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  mode?: QueryMode
  not?: string | NestedStringFilter
}

export type StringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  mode?: QueryMode
  not?: string | NestedStringNullableFilter | null
}

export type BoolFilter = {
  equals?: boolean
  not?: boolean | NestedBoolFilter
}

export type UserRelationFilter = {
  is?: UserWhereInput
  isNot?: UserWhereInput
}

export type IntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type FloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatFilter
}

export type FloatNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatNullableFilter | null
}

export type JsonFilter = {
  equals?: InputJsonValue
  not?: InputJsonValue
}

export type JsonNullableFilter = {
  equals?: InputJsonValue | null
  not?: InputJsonValue | null
}

export type EnumABeautifulEnumFilter = {
  equals?: ABeautifulEnum
  in?: Enumerable<ABeautifulEnum>
  notIn?: Enumerable<ABeautifulEnum>
  not?: ABeautifulEnum | NestedEnumABeautifulEnumFilter
}

export type EnumABeautifulEnumNullableFilter = {
  equals?: ABeautifulEnum | null
  in?: Enumerable<ABeautifulEnum> | null
  notIn?: Enumerable<ABeautifulEnum> | null
  not?: ABeautifulEnum | NestedEnumABeautifulEnumNullableFilter | null
}

export type BoolNullableFilter = {
  equals?: boolean | null
  not?: boolean | NestedBoolNullableFilter | null
}

export type PostListRelationFilter = {
  every?: PostWhereInput
  some?: PostWhereInput
  none?: PostWhereInput
}

export type NListRelationFilter = {
  every?: NWhereInput
  some?: NWhereInput
  none?: NWhereInput
}

export type MListRelationFilter = {
  every?: MWhereInput
  some?: MWhereInput
  none?: MWhereInput
}

export type ManyRequiredListRelationFilter = {
  every?: ManyRequiredWhereInput
  some?: ManyRequiredWhereInput
  none?: ManyRequiredWhereInput
}

export type OneOptionalRelationFilter = {
  is?: OneOptionalWhereInput | null
  isNot?: OneOptionalWhereInput | null
}

export type OptionalSide2RelationFilter = {
  is?: OptionalSide2WhereInput | null
  isNot?: OptionalSide2WhereInput | null
}

export type OptionalSide1RelationFilter = {
  is?: OptionalSide1WhereInput | null
  isNot?: OptionalSide1WhereInput | null
}

export type DecimalFilter = {
  equals?: Decimal
  in?: Enumerable<Decimal>
  notIn?: Enumerable<Decimal>
  lt?: Decimal
  lte?: Decimal
  gt?: Decimal
  gte?: Decimal
  not?: Decimal | NestedDecimalFilter
}

export type BytesFilter = {
  equals?: Buffer
  not?: Buffer | NestedBytesFilter
}

export type UserCreateOneWithoutPostsInput = {
  create?: UserCreateWithoutPostsInput
  connect?: UserWhereUniqueInput
}

export type DateTimeFieldUpdateOperationsInput = {
  set?: Date | string
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type UserUpdateOneRequiredWithoutPostsInput = {
  create?: UserCreateWithoutPostsInput
  connect?: UserWhereUniqueInput
  update?: UserUpdateWithoutPostsDataInput
  upsert?: UserUpsertWithoutPostsInput
}

export type PostCreateManyWithoutAuthorInput = {
  create?: PostCreateWithoutAuthorInput | Enumerable<PostCreateWithoutAuthorInput>
  connect?: PostWhereUniqueInput | Enumerable<PostWhereUniqueInput>
}

export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type FloatFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type NullableFloatFieldUpdateOperationsInput = {
  set?: number | null
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type EnumABeautifulEnumFieldUpdateOperationsInput = {
  set?: ABeautifulEnum
}

export type NullableEnumABeautifulEnumFieldUpdateOperationsInput = {
  set?: ABeautifulEnum | null
}

export type NullableBoolFieldUpdateOperationsInput = {
  set?: boolean | null
}

export type PostUpdateManyWithoutAuthorInput = {
  create?: PostCreateWithoutAuthorInput | Enumerable<PostCreateWithoutAuthorInput>
  connect?: PostWhereUniqueInput | Enumerable<PostWhereUniqueInput>
  set?: PostWhereUniqueInput | Enumerable<PostWhereUniqueInput>
  disconnect?: PostWhereUniqueInput | Enumerable<PostWhereUniqueInput>
  delete?: PostWhereUniqueInput | Enumerable<PostWhereUniqueInput>
  update?: PostUpdateWithWhereUniqueWithoutAuthorInput | Enumerable<PostUpdateWithWhereUniqueWithoutAuthorInput>
  updateMany?: PostUpdateManyWithWhereNestedInput | Enumerable<PostUpdateManyWithWhereNestedInput>
  deleteMany?: PostScalarWhereInput | Enumerable<PostScalarWhereInput>
  upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | Enumerable<PostUpsertWithWhereUniqueWithoutAuthorInput>
}

export type NCreateManyWithoutMInput = {
  create?: NCreateWithoutMInput | Enumerable<NCreateWithoutMInput>
  connect?: NWhereUniqueInput | Enumerable<NWhereUniqueInput>
}

export type NUpdateManyWithoutMInput = {
  create?: NCreateWithoutMInput | Enumerable<NCreateWithoutMInput>
  connect?: NWhereUniqueInput | Enumerable<NWhereUniqueInput>
  set?: NWhereUniqueInput | Enumerable<NWhereUniqueInput>
  disconnect?: NWhereUniqueInput | Enumerable<NWhereUniqueInput>
  delete?: NWhereUniqueInput | Enumerable<NWhereUniqueInput>
  update?: NUpdateWithWhereUniqueWithoutMInput | Enumerable<NUpdateWithWhereUniqueWithoutMInput>
  updateMany?: NUpdateManyWithWhereNestedInput | Enumerable<NUpdateManyWithWhereNestedInput>
  deleteMany?: NScalarWhereInput | Enumerable<NScalarWhereInput>
  upsert?: NUpsertWithWhereUniqueWithoutMInput | Enumerable<NUpsertWithWhereUniqueWithoutMInput>
}

export type MCreateManyWithoutNInput = {
  create?: MCreateWithoutNInput | Enumerable<MCreateWithoutNInput>
  connect?: MWhereUniqueInput | Enumerable<MWhereUniqueInput>
}

export type MUpdateManyWithoutNInput = {
  create?: MCreateWithoutNInput | Enumerable<MCreateWithoutNInput>
  connect?: MWhereUniqueInput | Enumerable<MWhereUniqueInput>
  set?: MWhereUniqueInput | Enumerable<MWhereUniqueInput>
  disconnect?: MWhereUniqueInput | Enumerable<MWhereUniqueInput>
  delete?: MWhereUniqueInput | Enumerable<MWhereUniqueInput>
  update?: MUpdateWithWhereUniqueWithoutNInput | Enumerable<MUpdateWithWhereUniqueWithoutNInput>
  updateMany?: MUpdateManyWithWhereNestedInput | Enumerable<MUpdateManyWithWhereNestedInput>
  deleteMany?: MScalarWhereInput | Enumerable<MScalarWhereInput>
  upsert?: MUpsertWithWhereUniqueWithoutNInput | Enumerable<MUpsertWithWhereUniqueWithoutNInput>
}

export type ManyRequiredCreateManyWithoutOneInput = {
  create?: ManyRequiredCreateWithoutOneInput | Enumerable<ManyRequiredCreateWithoutOneInput>
  connect?: ManyRequiredWhereUniqueInput | Enumerable<ManyRequiredWhereUniqueInput>
}

export type ManyRequiredUpdateManyWithoutOneInput = {
  create?: ManyRequiredCreateWithoutOneInput | Enumerable<ManyRequiredCreateWithoutOneInput>
  connect?: ManyRequiredWhereUniqueInput | Enumerable<ManyRequiredWhereUniqueInput>
  set?: ManyRequiredWhereUniqueInput | Enumerable<ManyRequiredWhereUniqueInput>
  disconnect?: ManyRequiredWhereUniqueInput | Enumerable<ManyRequiredWhereUniqueInput>
  delete?: ManyRequiredWhereUniqueInput | Enumerable<ManyRequiredWhereUniqueInput>
  update?: ManyRequiredUpdateWithWhereUniqueWithoutOneInput | Enumerable<ManyRequiredUpdateWithWhereUniqueWithoutOneInput>
  updateMany?: ManyRequiredUpdateManyWithWhereNestedInput | Enumerable<ManyRequiredUpdateManyWithWhereNestedInput>
  deleteMany?: ManyRequiredScalarWhereInput | Enumerable<ManyRequiredScalarWhereInput>
  upsert?: ManyRequiredUpsertWithWhereUniqueWithoutOneInput | Enumerable<ManyRequiredUpsertWithWhereUniqueWithoutOneInput>
}

export type OneOptionalCreateOneWithoutManyInput = {
  create?: OneOptionalCreateWithoutManyInput
  connect?: OneOptionalWhereUniqueInput
}

export type OneOptionalUpdateOneWithoutManyInput = {
  create?: OneOptionalCreateWithoutManyInput
  connect?: OneOptionalWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: OneOptionalUpdateWithoutManyDataInput
  upsert?: OneOptionalUpsertWithoutManyInput
}

export type OptionalSide2CreateOneWithoutOptiInput = {
  create?: OptionalSide2CreateWithoutOptiInput
  connect?: OptionalSide2WhereUniqueInput
}

export type OptionalSide2UpdateOneWithoutOptiInput = {
  create?: OptionalSide2CreateWithoutOptiInput
  connect?: OptionalSide2WhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: OptionalSide2UpdateWithoutOptiDataInput
  upsert?: OptionalSide2UpsertWithoutOptiInput
}

export type OptionalSide1CreateOneWithoutOptiInput = {
  create?: OptionalSide1CreateWithoutOptiInput
  connect?: OptionalSide1WhereUniqueInput
}

export type OptionalSide1UpdateOneWithoutOptiInput = {
  create?: OptionalSide1CreateWithoutOptiInput
  connect?: OptionalSide1WhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: OptionalSide1UpdateWithoutOptiDataInput
  upsert?: OptionalSide1UpsertWithoutOptiInput
}

export type DecimalFieldUpdateOperationsInput = {
  set?: Decimal
  increment?: Decimal
  decrement?: Decimal
  multiply?: Decimal
  divide?: Decimal
}

export type BytesFieldUpdateOperationsInput = {
  set?: Buffer
}

export type NestedIntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type NestedDateTimeFilter = {
  equals?: Date | string
  in?: Enumerable<Date> | Enumerable<string>
  notIn?: Enumerable<Date> | Enumerable<string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeFilter
}

export type NestedStringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringFilter
}

export type NestedStringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringNullableFilter | null
}

export type NestedBoolFilter = {
  equals?: boolean
  not?: boolean | NestedBoolFilter
}

export type NestedIntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type NestedFloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatFilter
}

export type NestedFloatNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatNullableFilter | null
}

export type NestedEnumABeautifulEnumFilter = {
  equals?: ABeautifulEnum
  in?: Enumerable<ABeautifulEnum>
  notIn?: Enumerable<ABeautifulEnum>
  not?: ABeautifulEnum | NestedEnumABeautifulEnumFilter
}

export type NestedEnumABeautifulEnumNullableFilter = {
  equals?: ABeautifulEnum | null
  in?: Enumerable<ABeautifulEnum> | null
  notIn?: Enumerable<ABeautifulEnum> | null
  not?: ABeautifulEnum | NestedEnumABeautifulEnumNullableFilter | null
}

export type NestedBoolNullableFilter = {
  equals?: boolean | null
  not?: boolean | NestedBoolNullableFilter | null
}

export type NestedDecimalFilter = {
  equals?: Decimal
  in?: Enumerable<Decimal>
  notIn?: Enumerable<Decimal>
  lt?: Decimal
  lte?: Decimal
  gt?: Decimal
  gte?: Decimal
  not?: Decimal | NestedDecimalFilter
}

export type NestedBytesFilter = {
  equals?: Buffer
  not?: Buffer | NestedBytesFilter
}

export type UserCreateWithoutPostsInput = {
  email: string
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
}

export type UserUpdateWithoutPostsDataInput = {
  email?: string | StringFieldUpdateOperationsInput
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type UserUpsertWithoutPostsInput = {
  update: UserUpdateWithoutPostsDataInput
  create: UserCreateWithoutPostsInput
}

export type PostCreateWithoutAuthorInput = {
  createdAt?: Date | string
  title: string
  content?: string | null
  published?: boolean
}

export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
  where: PostWhereUniqueInput
  data: PostUpdateWithoutAuthorDataInput
}

export type PostUpdateManyWithWhereNestedInput = {
  where: PostScalarWhereInput
  data: PostUpdateManyDataInput
}

export type PostScalarWhereInput = {
  AND?: PostScalarWhereInput | Enumerable<PostScalarWhereInput>
  OR?: PostScalarWhereInput | Enumerable<PostScalarWhereInput>
  NOT?: PostScalarWhereInput | Enumerable<PostScalarWhereInput>
  id?: IntFilter | number
  createdAt?: DateTimeFilter | Date | string
  title?: StringFilter | string
  content?: StringNullableFilter | string | null
  published?: BoolFilter | boolean
  authorId?: IntFilter | number
}

export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
  where: PostWhereUniqueInput
  update: PostUpdateWithoutAuthorDataInput
  create: PostCreateWithoutAuthorInput
}

export type NCreateWithoutMInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
}

export type NUpdateWithWhereUniqueWithoutMInput = {
  where: NWhereUniqueInput
  data: NUpdateWithoutMDataInput
}

export type NUpdateManyWithWhereNestedInput = {
  where: NScalarWhereInput
  data: NUpdateManyDataInput
}

export type NScalarWhereInput = {
  AND?: NScalarWhereInput | Enumerable<NScalarWhereInput>
  OR?: NScalarWhereInput | Enumerable<NScalarWhereInput>
  NOT?: NScalarWhereInput | Enumerable<NScalarWhereInput>
  id?: IntFilter | number
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
}

export type NUpsertWithWhereUniqueWithoutMInput = {
  where: NWhereUniqueInput
  update: NUpdateWithoutMDataInput
  create: NCreateWithoutMInput
}

export type MCreateWithoutNInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
}

export type MUpdateWithWhereUniqueWithoutNInput = {
  where: MWhereUniqueInput
  data: MUpdateWithoutNDataInput
}

export type MUpdateManyWithWhereNestedInput = {
  where: MScalarWhereInput
  data: MUpdateManyDataInput
}

export type MScalarWhereInput = {
  AND?: MScalarWhereInput | Enumerable<MScalarWhereInput>
  OR?: MScalarWhereInput | Enumerable<MScalarWhereInput>
  NOT?: MScalarWhereInput | Enumerable<MScalarWhereInput>
  id?: IntFilter | number
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
}

export type MUpsertWithWhereUniqueWithoutNInput = {
  where: MWhereUniqueInput
  update: MUpdateWithoutNDataInput
  create: MCreateWithoutNInput
}

export type ManyRequiredCreateWithoutOneInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
}

export type ManyRequiredUpdateWithWhereUniqueWithoutOneInput = {
  where: ManyRequiredWhereUniqueInput
  data: ManyRequiredUpdateWithoutOneDataInput
}

export type ManyRequiredUpdateManyWithWhereNestedInput = {
  where: ManyRequiredScalarWhereInput
  data: ManyRequiredUpdateManyDataInput
}

export type ManyRequiredScalarWhereInput = {
  AND?: ManyRequiredScalarWhereInput | Enumerable<ManyRequiredScalarWhereInput>
  OR?: ManyRequiredScalarWhereInput | Enumerable<ManyRequiredScalarWhereInput>
  NOT?: ManyRequiredScalarWhereInput | Enumerable<ManyRequiredScalarWhereInput>
  id?: IntFilter | number
  oneOptionalId?: IntNullableFilter | number | null
  int?: IntFilter | number
  optionalInt?: IntNullableFilter | number | null
  float?: FloatFilter | number
  optionalFloat?: FloatNullableFilter | number | null
  string?: StringFilter | string
  optionalString?: StringNullableFilter | string | null
  json?: JsonFilter
  optionalJson?: JsonNullableFilter
  enum?: EnumABeautifulEnumFilter | ABeautifulEnum
  optionalEnum?: EnumABeautifulEnumNullableFilter | ABeautifulEnum | null
  boolean?: BoolFilter | boolean
  optionalBoolean?: BoolNullableFilter | boolean | null
}

export type ManyRequiredUpsertWithWhereUniqueWithoutOneInput = {
  where: ManyRequiredWhereUniqueInput
  update: ManyRequiredUpdateWithoutOneDataInput
  create: ManyRequiredCreateWithoutOneInput
}

export type OneOptionalCreateWithoutManyInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
}

export type OneOptionalUpdateWithoutManyDataInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type OneOptionalUpsertWithoutManyInput = {
  update: OneOptionalUpdateWithoutManyDataInput
  create: OneOptionalCreateWithoutManyInput
}

export type OptionalSide2CreateWithoutOptiInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
}

export type OptionalSide2UpdateWithoutOptiDataInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type OptionalSide2UpsertWithoutOptiInput = {
  update: OptionalSide2UpdateWithoutOptiDataInput
  create: OptionalSide2CreateWithoutOptiInput
}

export type OptionalSide1CreateWithoutOptiInput = {
  int: number
  optionalInt?: number | null
  float: number
  optionalFloat?: number | null
  string: string
  optionalString?: string | null
  json: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum: ABeautifulEnum
  optionalEnum?: ABeautifulEnum | null
  boolean: boolean
  optionalBoolean?: boolean | null
}

export type OptionalSide1UpdateWithoutOptiDataInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type OptionalSide1UpsertWithoutOptiInput = {
  update: OptionalSide1UpdateWithoutOptiDataInput
  create: OptionalSide1CreateWithoutOptiInput
}

export type PostUpdateWithoutAuthorDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  content?: string | NullableStringFieldUpdateOperationsInput | null
  published?: boolean | BoolFieldUpdateOperationsInput
}

export type PostUpdateManyDataInput = {
  createdAt?: Date | string | DateTimeFieldUpdateOperationsInput
  title?: string | StringFieldUpdateOperationsInput
  content?: string | NullableStringFieldUpdateOperationsInput | null
  published?: boolean | BoolFieldUpdateOperationsInput
}

export type NUpdateWithoutMDataInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type NUpdateManyDataInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type MUpdateWithoutNDataInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type MUpdateManyDataInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type ManyRequiredUpdateWithoutOneDataInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

export type ManyRequiredUpdateManyDataInput = {
  int?: number | IntFieldUpdateOperationsInput
  optionalInt?: number | NullableIntFieldUpdateOperationsInput | null
  float?: number | FloatFieldUpdateOperationsInput
  optionalFloat?: number | NullableFloatFieldUpdateOperationsInput | null
  string?: string | StringFieldUpdateOperationsInput
  optionalString?: string | NullableStringFieldUpdateOperationsInput | null
  json?: InputJsonValue
  optionalJson?: InputJsonValue | null
  enum?: ABeautifulEnum | EnumABeautifulEnumFieldUpdateOperationsInput
  optionalEnum?: ABeautifulEnum | NullableEnumABeautifulEnumFieldUpdateOperationsInput | null
  boolean?: boolean | BoolFieldUpdateOperationsInput
  optionalBoolean?: boolean | NullableBoolFieldUpdateOperationsInput | null
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};

`;
