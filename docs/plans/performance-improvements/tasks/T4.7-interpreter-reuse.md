# T4.7: Interpreter Instance Reuse

## Status
Not Started

## Priority
P2 (Medium)

## Goal
Reuse QueryInterpreter instances across queries to eliminate constructor overhead.

## Background

Profiling shows that creating a new QueryInterpreter for each query adds ~0.54μs of overhead. With interpreter reuse, we see 23-40% performance improvement.

## Current State

| Scenario | Without Reuse | With Reuse | Improvement |
|----------|---------------|------------|-------------|
| Simple select | 5.96μs (168k ops/sec) | 3.61μs (277k ops/sec) | 39.4% |
| findUnique | 7.28μs (137k ops/sec) | 5.59μs (179k ops/sec) | 23.2% |

## Analysis

The QueryInterpreter constructor:
1. Copies options to private fields
2. Creates a new GeneratorRegistry instance
3. Assigns closures to instance fields

While each operation is individually cheap (~0.54μs total), this adds up when processing thousands of queries per second.

## Proposed Solution

### Option 1: Interpreter Pool
Create a pool of pre-initialized interpreters that can be borrowed and returned:

```typescript
class InterpreterPool {
  private pool: QueryInterpreter[] = []
  private maxSize = 10

  acquire(options: QueryInterpreterOptions): QueryInterpreter {
    // Return existing or create new
  }

  release(interpreter: QueryInterpreter): void {
    // Reset and return to pool
  }
}
```

### Option 2: Per-Request Reuse
Reuse the same interpreter for all queries within a single client request:

```typescript
class ClientEngine {
  executeRequest(request: Request): Promise<Response> {
    const interpreter = this.createInterpreter(request)
    // Execute all queries in request with same interpreter
    return this.executeWithInterpreter(request, interpreter)
  }
}
```

### Option 3: Static Interpreter (Stateless)
Refactor interpreter to be stateless, allowing a single shared instance:

```typescript
const sharedInterpreter = QueryInterpreter.forSql({ ... })

// All queries use the same interpreter, passing per-query state
result = sharedInterpreter.run(plan, adapter, { placeholderValues, ... })
```

## Expected Outcome

- 20-40% improvement in interpreter execution time
- Reduced GC pressure from fewer object allocations
- Better memory locality

## Implementation Notes

The interpreter currently stores per-query state:
- `#placeholderValues` - Values for query parameters
- `#onQuery` - Query event callback
- `#generators` - Generator registry for auto-generated values

This state would need to be passed per-query rather than stored on the instance.

## Risks

- Thread safety concerns if interpreter is shared
- State leakage between queries if reset is incomplete
- Increased complexity in the query execution path

## Related Tasks

- T4.6: Interpreter Synchronous Fast Path
- T1.4: Interpreter Allocations (completed)
