# T2.1: Implement Proper Parameterization with Named Placeholders

**Priority**: P0  
**Track**: 2 - Query Plan Caching  
**Effort**: Large (5-8 days)  
**Impact**: Critical for correctness  
**Dependencies**: T1.1 (Strawman Query Plan Cache) - for validation

## Objective

Extend the strawman parameterization to generate properly named placeholders that match the query compiler's expectations, enabling correct value binding at query execution time.

## Background

The strawman implementation (T1.1) uses a simple `{ $type: "Param" }` placeholder. However, the query compiler expects named placeholders with specific paths that map to positions in the compiled query plan's SQL templates.

When the query compiler receives a parameterized query, it:

1. Parses the placeholder names from the query
2. Generates SQL with positional parameters (`?` or `$1`, etc.)
3. Records the mapping between placeholder names and SQL parameter positions
4. Outputs this mapping in the query plan for the interpreter to use

The interpreter then uses `placeholderValues` (a `Record<string, unknown>`) to bind concrete values.

## Technical Requirements

### 1. Named Placeholder Format

The query compiler expects placeholders in the format:

```typescript
{ $type: "Param", name: "unique_identifier" }
```

The name must be unique within the query and should be deterministic for the same query structure (to enable consistent caching).

**Naming strategy options**:

A. **Path-based names** (recommended for debuggability):

```typescript
// Query: { where: { id: 42, author: { name: "Alice" } } }
// Parameterized:
{
  where: {
    id: { $type: "Param", name: "where.id" },
    author: {
      name: { $type: "Param", name: "where.author.name" }
    }
  }
}
```

B. **Sequential names** (simpler, but less debuggable):

```typescript
{
  where: {
    id: { $type: "Param", name: "p0" },
    author: {
      name: { $type: "Param", name: "p1" }
    }
  }
}
```

### 2. Value Extraction

During parameterization, extract values into a map keyed by placeholder name:

```typescript
interface ParameterizeResult {
  parameterizedQuery: JsonQuery
  placeholderValues: Record<string, unknown>
}

// Example:
parameterizeQuery({
  modelName: 'User',
  action: 'findUnique',
  query: {
    arguments: { where: { id: 42 } },
    selection: { $scalars: true }
  }
})

// Returns:
{
  parameterizedQuery: {
    modelName: 'User',
    action: 'findUnique',
    query: {
      arguments: { where: { id: { $type: "Param", name: "args.where.id" } } },
      selection: { $scalars: true }
    }
  },
  placeholderValues: {
    "args.where.id": 42
  }
}
```

### 3. Handle Array Values

Arrays in filters (e.g., `{ in: [1, 2, 3] }`) need special handling:

**Option A**: Flatten to individual parameters

```typescript
// Input: { where: { id: { in: [1, 2, 3] } } }
// Output:
{
  where: {
    id: {
      in: [
        { $type: "Param", name: "args.where.id.in.0" },
        { $type: "Param", name: "args.where.id.in.1" },
        { $type: "Param", name: "args.where.id.in.2" }
      ]
    }
  }
}
```

**Option B**: Keep array as single parameter (if query compiler supports it)

```typescript
// Input: { where: { id: { in: [1, 2, 3] } } }
// Output:
{
  where: {
    id: {
      in: { $type: "Param", name: "args.where.id.in" }
    }
  }
}
// Values: { "args.where.id.in": [1, 2, 3] }
```

**Note**: Option A creates different cache keys for different array lengths. Option B requires query compiler support. Need to verify which the query compiler expects.

### 4. Preserve Structural Values

Certain values must NOT be parameterized:

| Value Type             | Example                            | Reason                     |
| ---------------------- | ---------------------------------- | -------------------------- |
| Selection flags        | `{ id: true }`                     | Determines query structure |
| Sort directions        | `{ orderBy: { name: 'asc' } }`     | Part of query shape        |
| Relation load strategy | `{ relationLoadStrategy: 'join' }` | Affects execution          |
| Pagination structure   | `{ take: 10, skip: 20 }`           | May affect SQL structure   |
| Mode flags             | `{ mode: 'insensitive' }`          | Affects SQL                |

Current strawman already handles some of these via `STRUCTURAL_VALUE_KEYS`:

```typescript
const STRUCTURAL_VALUE_KEYS = new Set(['take', 'skip', 'sort', 'nulls', 'mode', 'relationLoadStrategy', 'distinct'])
```

Review and extend this list as needed.

## Implementation Plan

### Phase 1: Core Parameterization (3 days)

1. **Create parameterization module**
   - File: `packages/client/src/runtime/core/engines/client/parameterize.ts`
   - Export `parameterizeQuery(query: JsonQuery): ParameterizeResult`

2. **Implement context-aware traversal**
   - Adapt from `sqlcommenter-query-insights/parameterize.ts`
   - Add path tracking for placeholder naming
   - Handle all value types correctly

3. **Add comprehensive unit tests**
   - Test all filter operators
   - Test nested relations
   - Test data mutations (create, update)
   - Test edge cases (null, undefined, empty arrays)

### Phase 2: Query Compiler Integration (2 days)

4. **Verify query compiler expectations**
   - Test parameterized queries against query compiler
   - Verify placeholder format is correct
   - Ensure compiled plans reference correct placeholder names

5. **Handle array parameters**
   - Determine correct array handling approach
   - Implement and test

6. **Update ClientEngine integration**
   - Replace strawman parameterization with proper implementation
   - Verify cache key generation still works
   - Run benchmarks to confirm no performance regression

### Phase 3: Testing & Documentation (2 days)

7. **Integration testing**
   - Run full functional test suite with caching enabled
   - Add caching-specific test cases
   - Test with all supported databases

8. **Document parameterization behavior**
   - Document which values are parameterized
   - Document placeholder naming scheme
   - Add examples to code comments

## Code Structure

```
packages/client/src/runtime/core/engines/client/
├── parameterize.ts           # Main parameterization logic
├── parameterize.test.ts      # Unit tests
├── QueryPlanCache.ts         # Cache implementation (from T1.1)
└── ClientEngine.ts           # Integration point
```

## Test Cases

### Unit Tests

```typescript
describe('parameterizeQuery', () => {
  describe('scalar values', () => {
    it('parameterizes string values')
    it('parameterizes number values')
    it('parameterizes boolean values in where clauses')
    it('parameterizes Date values')
    it('parameterizes BigInt values')
    it('parameterizes Decimal values')
    it('parameterizes null values')
    it('parameterizes Bytes values')
  })

  describe('filter operators', () => {
    it('parameterizes equals filter')
    it('parameterizes in filter with array')
    it('parameterizes notIn filter')
    it('parameterizes lt/lte/gt/gte filters')
    it('parameterizes contains filter')
    it('parameterizes startsWith/endsWith filters')
  })

  describe('structural values', () => {
    it('preserves selection booleans')
    it('preserves orderBy directions')
    it('preserves take/skip values')
    it('preserves mode flags')
    it('preserves distinct fields')
  })

  describe('nested queries', () => {
    it('parameterizes relation filter values')
    it('parameterizes nested where clauses')
    it('parameterizes nested data in create')
  })

  describe('placeholder naming', () => {
    it('generates deterministic names for same structure')
    it('generates unique names for different values')
    it('handles deeply nested paths')
  })
})
```

### Integration Tests

1. Execute parameterized queries and verify results match non-parameterized
2. Verify cache hits produce correct results with different values
3. Test with transactions
4. Test with raw queries (should not be parameterized)

## Success Criteria

- [ ] All filter operator types correctly parameterized
- [ ] Placeholder names match query compiler expectations
- [ ] Value extraction produces correct bindings
- [ ] Structural values preserved (no incorrect parameterization)
- [ ] Cache hit rate remains high (>90% for typical workloads)
- [ ] No performance regression vs strawman
- [ ] All functional tests pass
- [ ] Works with all database providers

## Risks

| Risk                                    | Likelihood | Impact | Mitigation                           |
| --------------------------------------- | ---------- | ------ | ------------------------------------ |
| Query compiler expects different format | Medium     | High   | Early integration testing            |
| Array handling differs by provider      | Medium     | Medium | Provider-specific handling if needed |
| Edge cases cause incorrect queries      | Medium     | High   | Comprehensive test coverage          |
| Performance overhead from path tracking | Low        | Medium | Benchmark and optimize               |

## Follow-up Tasks

- T2.2: Optimize cache key generation
- T3.1: Add parameterization metadata to DMMF (for schema-driven parameterization)
- Consider: Raw query parameterization (different approach needed)
