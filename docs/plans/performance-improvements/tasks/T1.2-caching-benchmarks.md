# T1.2: Add Query Plan Caching Benchmarks

**Priority**: P0 (Critical)  
**Track**: 2 - Query Plan Caching  
**Effort**: Small  
**Dependencies**: None (can be done before T1.1 to establish baseline)

## Objective

Add benchmarks that specifically measure the performance difference between cached and uncached query execution. This enables accurate measurement of caching effectiveness and identifies any cache-related overhead.

## Background

Current benchmarks measure end-to-end query performance but don't distinguish between:

1. First query (cache miss, requires compilation)
2. Repeated queries (cache hit, skip compilation)
3. Cache lookup overhead

We need to measure these separately to validate that query plan caching achieves the expected speedup.

## Tasks

### 1. Add Repeated Query Benchmarks

Modify `query-performance.bench.ts` to include variants that measure repeated identical queries:

```typescript
// Warm up the cache with one query
prisma.user.findUnique({ where: { id: 1 } })

// Benchmark repeated cached queries
suite.add(
  'findUnique by id (cached)',
  deferredBench(async () => {
    await prisma.user.findUnique({ where: { id: 1 } })
  }),
)
```

### 2. Add Cache Miss vs Hit Comparison

Create explicit comparison benchmarks:

```typescript
let queryCounter = 0

// Always cache miss (unique where clause)
suite.add(
  'findUnique (cache miss)',
  deferredBench(async () => {
    queryCounter++
    await prisma.user.findUnique({ where: { id: queryCounter % 1000 } })
  }),
)

// Always cache hit (same where clause structure)
suite.add(
  'findUnique (cache hit)',
  deferredBench(async () => {
    await prisma.user.findUnique({ where: { id: 1 } })
  }),
)
```

### 3. Add Batch Query Caching Benchmark

Measure caching effectiveness for batched queries:

```typescript
// Same query repeated in batch
suite.add(
  'batch same query (should cache)',
  deferredBench(async () => {
    await prisma.$transaction([
      prisma.user.findUnique({ where: { id: 1 } }),
      prisma.user.findUnique({ where: { id: 2 } }),
      prisma.user.findUnique({ where: { id: 3 } }),
    ])
  }),
)
```

### 4. Add Parameterization Overhead Benchmark

Measure the cost of parameterization itself:

```typescript
import { parameterizeQuery } from '../parameterize'

suite.add(
  'parameterize simple query',
  syncBench(() => {
    parameterizeQuery({
      modelName: 'User',
      action: 'findUnique',
      query: { arguments: { where: { id: 1 } }, selection: { $scalars: true } },
    })
  }),
)

suite.add(
  'parameterize complex query',
  syncBench(() => {
    parameterizeQuery({
      modelName: 'Post',
      action: 'findMany',
      query: {
        arguments: {
          where: { published: true, author: { name: { contains: 'test' } } },
          take: 10,
          orderBy: [{ createdAt: 'desc' }],
        },
        selection: { $scalars: true, author: { selection: { $scalars: true } } },
      },
    })
  }),
)
```

### 5. Add Cache Lookup Overhead Benchmark

Measure the overhead of cache operations:

```typescript
const cache = new QueryPlanCache({ maxSize: 1000 })
const key = '{"modelName":"User","action":"findUnique",...}'
const plan = {
  /* pre-compiled plan */
}

// Pre-populate cache
cache.set(key, plan)

suite.add(
  'cache lookup (hit)',
  syncBench(() => {
    cache.get(key)
  }),
)

suite.add(
  'cache set',
  syncBench(() => {
    cache.set(key, plan)
  }),
)
```

## Files to Modify

| File                                                                                    | Changes                                |
| --------------------------------------------------------------------------------------- | -------------------------------------- |
| `packages/client/src/__tests__/benchmarks/query-performance/query-performance.bench.ts` | Add cached vs uncached variants        |
| `packages/client/src/__tests__/benchmarks/query-performance/caching.bench.ts`           | New file for cache-specific benchmarks |

## Expected Results

Before caching implementation (baseline expectations):

- Cache miss and cache hit should show identical performance
- All queries require full compilation

After caching implementation (target expectations):

- Cache hit should be 10-50x faster than cache miss
- Parameterization overhead should be <10μs for simple queries
- Cache lookup overhead should be <1μs

## Success Metrics

| Metric                             | Current        | With Caching Target   |
| ---------------------------------- | -------------- | --------------------- |
| findUnique (first/uncached)        | ~5,800 ops/sec | ~5,800 ops/sec (same) |
| findUnique (repeated/cached)       | ~5,800 ops/sec | ~100,000+ ops/sec     |
| Cache hit ratio (typical workload) | N/A            | >90%                  |
| Parameterization overhead          | N/A            | <10μs                 |
| Cache lookup overhead              | N/A            | <1μs                  |

## Testing

1. Run benchmarks before caching implementation to establish baseline
2. Verify cached and uncached benchmarks show same performance initially
3. After caching implementation, verify expected speedup
4. Verify cache hit/miss metrics are accurate

## Notes

- These benchmarks should be added before T1.1 to establish a clear baseline
- The benchmarks themselves help validate the caching implementation
- Consider adding cache statistics output (hit rate, size, evictions)
