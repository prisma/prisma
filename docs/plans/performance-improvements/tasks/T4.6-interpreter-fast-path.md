# T4.6: Interpreter Synchronous Fast Path

## Status
Not Started

## Priority
P2 (Medium)

## Goal
Create a synchronous execution path for simple queries that don't require joins or complex operations, reducing async overhead.

## Background

With query plan caching now achieving 110x speedup, the interpreter (136-188k ops/sec) has become the primary bottleneck. The interpreter currently uses async/await throughout, which adds significant overhead for simple queries.

## Current State

- Interpreter simple select: 188k ops/sec
- Interpreter findUnique: 136k ops/sec
- Cached compilation: 795k ops/sec

The gap between cached compilation and interpreter execution represents the next optimization opportunity.

## Analysis

### Async Overhead

Every node interpretation involves:
1. Promise creation
2. Microtask queue scheduling
3. Promise resolution

For simple queries (value, query, dataMap nodes), this overhead is unnecessary.

### Opportunity

Simple queries like `findUnique` or `findMany` without joins often have query plans that:
- Have only a few nodes (query, unique, dataMap)
- Don't require parallel execution
- Don't have recursive joins

## Proposed Solution

### Phase 1: Detect Simple Query Plans

```typescript
function isSimpleQueryPlan(plan: QueryPlanNode): boolean {
  const simpleTypes = new Set(['value', 'query', 'unique', 'dataMap', 'get', 'seq'])
  return analyzeNodeTypes(plan, simpleTypes)
}
```

### Phase 2: Synchronous Interpreter

Create a `runSync` method that executes simple plans without async:

```typescript
runSync(queryPlan: QueryPlanNode, queryable: SyncSqlQueryable): unknown {
  // Synchronous execution for simple queries
}
```

### Phase 3: Hybrid Execution

Fall back to async for complex plans:

```typescript
async run(queryPlan: QueryPlanNode, queryable: SqlQueryable): Promise<unknown> {
  if (this.#canRunSync && isSimpleQueryPlan(queryPlan)) {
    return this.runSync(queryPlan, queryable)
  }
  return this.runAsync(queryPlan, queryable)
}
```

## Expected Outcome

- Simple query execution: 2x faster (from 136k to ~270k ops/sec)
- Reduced microtask overhead
- Better CPU cache utilization

## Risks

- Requires driver adapter changes for sync execution
- May not be applicable to all adapters
- Increased code complexity

## Related Tasks

- T4.5: Parameterization Optimization (completed)
- T1.4: Interpreter Allocations (completed)
