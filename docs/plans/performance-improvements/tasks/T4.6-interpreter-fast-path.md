# T4.6: Interpreter Synchronous Fast Path

## Status
Not Started

## Priority
P2 (Medium)

## Goal
Create a synchronous execution path for simple queries that don't require joins or complex operations, reducing async overhead.

## Background

With query plan caching now achieving 116x speedup and the withQuerySpanAndEvent optimization, the interpreter has improved but remains the primary bottleneck.

## Current State (Updated after T4.5 and tracing optimization)

- Interpreter simple select: 223k ops/sec
- Interpreter findUnique: 158k ops/sec
- Cached compilation: 902k ops/sec
- withQuerySpanAndEvent (no onQuery): 0.70μs (optimized fast path)

### Profiling Breakdown (findUnique, reusing interpreter)

| Component | Time (μs) | Notes |
|-----------|-----------|-------|
| renderQuery | 0.71 | SQL rendering |
| withQuerySpanAndEvent | 0.70 | Tracing wrapper (fast path) |
| mockAdapter.queryRaw | 0.42 | Mock DB query |
| serializeSql | 0.25 | Result serialization |
| applyDataMap | 0.51 | Data mapping |
| Recursive async overhead | ~0.35 | 3 async calls |
| Total measured | ~2.9 | |
| Actual measured | 5.59 | |
| Unexplained | ~2.7 | Switch dispatch, object creation |

The gap between cached compilation (902k ops/sec) and interpreter execution (~179k ops/sec) represents the next optimization opportunity.

## Analysis

### Async Overhead

Every node interpretation involves:
1. Promise creation
2. Microtask queue scheduling
3. Promise resolution

For simple queries (value, query, dataMap nodes), this overhead is unnecessary.

### Opportunity

Simple queries like `findUnique` or `findMany` without joins often have query plans that:
- Have only a few nodes (query, unique, dataMap)
- Don't require parallel execution
- Don't have recursive joins

## Proposed Solution

### Phase 1: Detect Simple Query Plans

```typescript
function isSimpleQueryPlan(plan: QueryPlanNode): boolean {
  const simpleTypes = new Set(['value', 'query', 'unique', 'dataMap', 'get', 'seq'])
  return analyzeNodeTypes(plan, simpleTypes)
}
```

### Phase 2: Synchronous Interpreter

Create a `runSync` method that executes simple plans without async:

```typescript
runSync(queryPlan: QueryPlanNode, queryable: SyncSqlQueryable): unknown {
  // Synchronous execution for simple queries
}
```

### Phase 3: Hybrid Execution

Fall back to async for complex plans:

```typescript
async run(queryPlan: QueryPlanNode, queryable: SqlQueryable): Promise<unknown> {
  if (this.#canRunSync && isSimpleQueryPlan(queryPlan)) {
    return this.runSync(queryPlan, queryable)
  }
  return this.runAsync(queryPlan, queryable)
}
```

## Expected Outcome

- Simple query execution: 2x faster (from 136k to ~270k ops/sec)
- Reduced microtask overhead
- Better CPU cache utilization

## Risks

- Requires driver adapter changes for sync execution
- May not be applicable to all adapters
- Increased code complexity

## Related Tasks

- T4.5: Parameterization Optimization (completed)
- T1.4: Interpreter Allocations (completed)
