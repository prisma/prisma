# T1.3: Optimize Data Mapper for Hot Paths

**Priority**: P1  
**Track**: 1 (Comprehensive Optimization)  
**Effort**: Medium  
**Impact**: Medium (10-20% improvement for large result sets)

## Summary

Optimize the data mapper's most frequently executed code paths to reduce overhead when processing query results, particularly for larger result sets where the current linear scaling becomes noticeable.

## Current State

**Location**: `packages/client-engine-runtime/src/interpreter/data-mapper.ts`

**Performance**:

- 10 rows: 155,396 ops/sec (~6.4μs)
- 50 rows: 24,419 ops/sec (~41μs)
- 100 rows: 12,321 ops/sec (~81μs)

The performance scales roughly linearly with row count, suggesting per-row overhead that can be optimized.

## Problem Analysis

### 1. Object Allocation in `mapObject()`

```typescript
function mapObject(
  data: PrismaObject,
  fields: Record<string, ResultNode>,
  enums: Record<string, Record<string, string>>,
): PrismaObject {
  const result = {} // ← New object per row
  for (const [name, node] of Object.entries(fields)) {
    // ← Creates array
    // ...
  }
  return result
}
```

Each row creates:

- A new result object
- An array from `Object.entries()`
- Array elements (2-tuples) for each field

### 2. Repeated Property Access

The `fields` structure is constant for all rows, but we iterate it fresh for each row:

```typescript
for (const [name, node] of Object.entries(fields)) {
  switch (
    node.type
    // ...
  ) {
  }
}
```

### 3. Type Conversion Overhead

`mapValue()` has a large switch statement executed for every field of every row:

```typescript
function mapValue(value, columnName, scalarType, enums): unknown {
  switch (scalarType.type) {
    case 'string': // ...
    case 'int': // ...
    case 'bigint': // ...
    // ... 12+ cases
  }
}
```

## Proposed Optimizations

### Optimization 1: Pre-compute Field Iteration Order

Instead of calling `Object.entries()` per row, pre-compute the entries once:

```typescript
// Before: O(fields) allocation per row
for (const [name, node] of Object.entries(fields)) { ... }

// After: O(1) per row (reuse pre-computed array)
const fieldEntries = Object.entries(fields)  // Compute once
for (let i = 0; i < fieldEntries.length; i++) {
  const [name, node] = fieldEntries[i]
  // ...
}
```

**Implementation approach**:

- Cache field entries in a WeakMap keyed by the `fields` object
- Or pass pre-computed entries through the recursion

### Optimization 2: Pre-allocate Result Arrays

For array results, pre-allocate the output array:

```typescript
// Before
if (Array.isArray(data)) {
  let rows = data as PrismaObject[]
  if (skipNulls) {
    rows = rows.filter((row) => row !== null)
  }
  return rows.map((row) => mapObject(row, fields, enums))
}

// After
if (Array.isArray(data)) {
  const rows = data as PrismaObject[]
  const result = new Array(skipNulls ? undefined : rows.length)
  let j = 0
  for (let i = 0; i < rows.length; i++) {
    if (rows[i] !== null || !skipNulls) {
      result[j++] = mapObject(rows[i], fields, enums)
    }
  }
  if (skipNulls) result.length = j
  return result
}
```

### Optimization 3: Inline Common Type Conversions

The most common types (`string`, `int`, `boolean`) can be inlined or fast-pathed:

```typescript
function mapField(value, columnName, fieldType, enums): unknown {
  if (value === null) {
    return fieldType.arity === 'list' ? [] : null
  }

  // Fast path for common scalar types
  if (fieldType.arity === 'scalar') {
    const type = fieldType.type
    if (type === 'string') return value
    if (type === 'int') return typeof value === 'number' ? Math.trunc(value) : mapIntValue(value, columnName)
    if (type === 'boolean') return typeof value === 'boolean' ? value : mapBoolValue(value, columnName)
  }

  // Fall through to general case
  return mapFieldGeneral(value, columnName, fieldType, enums)
}
```

### Optimization 4: Reduce Object Property Access

Cache frequently accessed properties:

```typescript
// Before
switch (node.type) {
  case 'object':
    if (node.serializedName !== null && !Object.hasOwn(data, node.serializedName)) { ... }
    const target = node.serializedName !== null ? data[node.serializedName] : data
    result[name] = mapArrayOrObject(target, node.fields, enums, node.skipNulls)

// After
switch (node.type) {
  case 'object': {
    const { serializedName, fields: nodeFields, skipNulls } = node
    if (serializedName !== null && !Object.hasOwn(data, serializedName)) { ... }
    const target = serializedName !== null ? data[serializedName] : data
    result[name] = mapArrayOrObject(target, nodeFields, enums, skipNulls)
  }
```

## Implementation Steps

1. **Benchmark before changes**: Run data-mapper benchmarks to establish baseline
2. **Implement field caching**: Add pre-computation of field entries
3. **Benchmark**: Measure impact
4. **Implement array pre-allocation**: Optimize array result handling
5. **Benchmark**: Measure impact
6. **Inline common types**: Fast-path string/int/boolean
7. **Benchmark**: Measure cumulative impact
8. **Profile for remaining hot spots**: Use V8 profiler to find remaining issues

## Testing Requirements

1. All existing data mapper tests must pass
2. Add edge case tests:
   - Empty result sets
   - Single row results
   - Large result sets (1000+ rows)
   - Deeply nested structures
3. Run functional tests to ensure no behavioral changes

## Success Criteria

- [ ] 10 rows benchmark: >200,000 ops/sec (30% improvement)
- [ ] 100 rows benchmark: >15,000 ops/sec (25% improvement)
- [ ] No performance regression for small result sets
- [ ] All tests passing

## Files to Modify

- `packages/client-engine-runtime/src/interpreter/data-mapper.ts`

## Related

- [T1.4: Reduce Object Allocations in Interpreter](./T1.4-reduce-interpreter-allocations.md)
- [Baseline Benchmarks](../baseline.md)
