# T1.4: Reduce Object Allocations in Interpreter

**Priority**: P1  
**Track**: 1 (Comprehensive Optimization)  
**Effort**: Medium  
**Impact**: Medium (5-15% overall improvement)  
**Status**: Not Started

## Objective

Minimize object creation in the query interpreter's hot paths to reduce garbage collection pressure and improve throughput.

## Background

The `QueryInterpreter` class processes query plans by recursively interpreting nodes. Currently, each query execution creates multiple intermediate objects:

- New `QueryInterpreter` instances per query
- New scope objects per node interpretation
- Intermediate value wrappers throughout the pipeline

At 337k ops/sec for `findUnique`, the interpreter is already efficient, but reducing allocations could provide an additional 5-15% improvement, especially for complex queries with many nodes.

## Current State

From `packages/client-engine-runtime/src/interpreter/query-interpreter.ts`:

1. **Interpreter instantiation**: A new `QueryInterpreter` is created for each query via `QueryInterpreter.forSql()`
2. **Scope bindings**: Each `interpretNode()` call may create new scope binding objects
3. **Generator snapshots**: `GeneratorRegistry.snapshot()` is called per query
4. **Intermediate values**: `IntermediateValue` objects are created throughout interpretation

Benchmark baseline:

- `interpreter: findUnique` - 337,297 ops/sec
- `interpreter: simple select` - 221,216 ops/sec
- `interpreter: deep nested join` - 34,935 ops/sec

## Proposed Changes

### 1. Pool QueryInterpreter Instances

Instead of creating a new interpreter per query, maintain a pool of reusable instances:

```typescript
// New file: interpreter-pool.ts
export class InterpreterPool {
  private readonly pool: QueryInterpreter[] = []
  private readonly maxSize: number

  acquire(options: QueryInterpreterOptions): QueryInterpreter {
    const interpreter = this.pool.pop()
    if (interpreter) {
      interpreter.reset(options)
      return interpreter
    }
    return new QueryInterpreter(options)
  }

  release(interpreter: QueryInterpreter): void {
    if (this.pool.length < this.maxSize) {
      this.pool.push(interpreter)
    }
  }
}
```

### 2. Reuse Scope Objects

Modify scope handling to reuse objects where possible:

```typescript
// Instead of creating new scope objects
const nestedScope = { ...scope, [binding]: value }

// Use a scope stack with object reuse
private scopeStack: ScopeBindings[] = []
private scopeStackIndex = 0

private pushScope(binding: string, value: unknown): void {
  const scope = this.scopeStack[this.scopeStackIndex] ?? {}
  // Clear and reuse...
}
```

### 3. Optimize Generator Registry Snapshots

The `GeneratorRegistry.snapshot()` creates a new object per query. Consider:

- Lazy snapshot creation (only when generators are actually used)
- Immutable snapshots that can be shared across queries

### 4. Reduce Intermediate Object Creation

Audit `interpretNode()` for unnecessary object allocations:

- Use tuple returns instead of objects where possible
- Pre-allocate arrays for known sizes
- Avoid spreading operators in hot paths

## Files to Modify

| File                                                                      | Changes                                   |
| ------------------------------------------------------------------------- | ----------------------------------------- |
| `packages/client-engine-runtime/src/interpreter/query-interpreter.ts`     | Add reset method, optimize scope handling |
| `packages/client-engine-runtime/src/interpreter/generator-registry.ts`    | Optimize snapshot creation                |
| `packages/client/src/runtime/core/engines/client/LocalExecutor.ts`        | Integrate interpreter pooling             |
| New: `packages/client-engine-runtime/src/interpreter/interpreter-pool.ts` | Pool implementation                       |

## Success Criteria

- [ ] `interpreter: findUnique` benchmark shows 5-15% improvement
- [ ] `interpreter: deep nested join` benchmark shows improvement
- [ ] No regression in correctness (all existing tests pass)
- [ ] Memory allocation per query reduced (measure with `--expose-gc` and heap snapshots)

## Testing Strategy

1. Run existing interpreter benchmarks before/after
2. Add micro-benchmark for interpreter instantiation overhead
3. Profile heap allocations with Chrome DevTools
4. Run full client functional test suite to verify correctness

## Risks and Mitigations

| Risk                                | Mitigation                                       |
| ----------------------------------- | ------------------------------------------------ |
| Object pooling adds complexity      | Keep pool implementation simple, well-tested     |
| Scope reuse could cause subtle bugs | Thorough testing, clear reset semantics          |
| May not provide expected gains      | Profile first to confirm allocation is the issue |

## Dependencies

- None (can be done independently)

## Follow-up Tasks

- T4.2: Implement Synchronous Fast Path (could leverage pooled interpreters)
- Investigate similar pooling for data mapper
