# T3.1: Extend DMMF with Parameterization Metadata

**Priority**: P1  
**Track**: 2 (Query Plan Caching)  
**Effort**: Large (1-2 weeks)  
**Impact**: High (enables correct, schema-driven parameterization)  
**Dependencies**: T2.1 (Proper Parameterization)  
**Requires**: Changes to prisma-engines repository

## Objective

Add metadata to the DMMF (Data Model Meta Format) that explicitly defines which query arguments can be parameterized. This enables the JavaScript client to correctly parameterize queries based on schema information rather than heuristics.

## Background

### Current State

The query compiler in prisma-engines currently hardcodes expectations about where `{ $type: "Param" }` placeholders can appear. From the prompt:

> Right now the query parser on Rust side hackily hardcodes the expectation for optional params in place of any scalars, which is wrong and must be driven by the query schema instead.

The JavaScript parameterization (T1.1, T2.1) uses context-based heuristics:

- Values in `where` clauses → parameterize
- Values in `data` objects → parameterize
- Values like `take`, `skip`, `mode` → preserve

This heuristic approach has limitations:

1. May incorrectly parameterize structural values
2. Doesn't know about database-specific limitations
3. Can't optimize based on field types

### Target State

DMMF includes explicit parameterization rules for each:

- Model field in filter contexts
- Model field in data/mutation contexts
- Aggregation arguments
- Relation operation arguments

The JavaScript client uses this metadata for 100% correct parameterization.

## Technical Design

### DMMF Schema Extensions

#### Option A: Per-Field Parameterization Flag

Add to existing field definitions:

```typescript
interface DMMF.Field {
  name: string
  type: string
  // ... existing fields ...

  // NEW: Parameterization metadata
  parameterizable: {
    inFilter: boolean      // Can parameterize in where clause
    inData: boolean        // Can parameterize in create/update data
    inOrderBy: boolean     // Can parameterize sort direction (usually false)
  }
}
```

#### Option B: Separate Parameterization Schema

Add a new top-level DMMF section:

```typescript
interface DMMF.Document {
  datamodel: DMMF.Datamodel
  schema: DMMF.Schema
  mappings: DMMF.Mappings

  // NEW: Parameterization rules
  parameterization: {
    models: Record<string, ModelParameterization>
    enums: Record<string, boolean>  // Whether enum values can be parameterized
  }
}

interface ModelParameterization {
  fields: Record<string, FieldParameterization>
  // Relations inherit from their target model
}

interface FieldParameterization {
  filter: FilterParameterization
  data: DataParameterization
}

interface FilterParameterization {
  equals: boolean
  in: boolean
  notIn: boolean
  lt: boolean
  lte: boolean
  gt: boolean
  gte: boolean
  contains: boolean
  startsWith: boolean
  endsWith: boolean
  // ... other filter operators
}

interface DataParameterization {
  set: boolean
  increment: boolean
  decrement: boolean
  multiply: boolean
  divide: boolean
  // ... other data operations
}
```

#### Option C: Operator-Level Rules (Recommended)

Most flexible approach - define rules at the operator level:

```typescript
interface DMMF.Schema {
  // ... existing fields ...

  // NEW: Query argument parameterization rules
  queryArgumentRules: QueryArgumentRules
}

interface QueryArgumentRules {
  // Which argument types can be parameterized
  parameterizableArguments: Set<ArgumentType>

  // Exceptions/overrides by context
  nonParameterizable: NonParameterizableRule[]
}

type ArgumentType =
  | 'scalarFilter'        // e.g., { equals: 42 }
  | 'scalarListFilter'    // e.g., { has: 42 }
  | 'scalarData'          // e.g., data: { name: "Alice" }
  | 'enumFilter'          // e.g., { role: 'ADMIN' }
  | 'enumData'            // e.g., data: { role: 'ADMIN' }
  | 'dateFilter'          // e.g., { createdAt: { gt: new Date() } }
  | 'jsonFilter'          // e.g., { metadata: { path: ['x'], equals: 1 } }
  | 'relationFilter'      // e.g., { author: { name: { contains: 'A' } } }

interface NonParameterizableRule {
  context: 'filter' | 'data' | 'orderBy' | 'pagination' | 'aggregation'
  field?: string          // Specific field, or undefined for all
  operator?: string       // Specific operator, or undefined for all
  reason: string          // For documentation/debugging
}
```

## Implementation in prisma-engines

### Changes Required

1. **schema crate**: Add parameterization metadata to query schema types
2. **query-structure**: Generate parameterization rules from schema
3. **dmmf crate**: Serialize rules to DMMF JSON output
4. **query-compiler**: Use schema-driven rules instead of hardcoded logic

### Schema Crate Changes

```rust
// schema/src/parameterization.rs

#[derive(Debug, Clone, Serialize)]
pub struct ParameterizationRules {
    /// Arguments that can always be parameterized
    pub scalar_filters: bool,
    pub scalar_data: bool,
    pub enum_values: bool,

    /// Structural values that must NOT be parameterized
    pub non_parameterizable: Vec<NonParameterizableContext>,
}

#[derive(Debug, Clone, Serialize)]
pub struct NonParameterizableContext {
    pub context: String,      // "orderBy", "pagination", "mode", etc.
    pub reason: String,
}

impl ParameterizationRules {
    pub fn from_schema(schema: &QuerySchema) -> Self {
        // Derive rules from schema analysis
    }
}
```

### DMMF Generation

```rust
// dmmf/src/lib.rs

fn render_parameterization(schema: &QuerySchema) -> serde_json::Value {
    let rules = ParameterizationRules::from_schema(schema);
    serde_json::to_value(rules).unwrap()
}
```

## JavaScript Client Integration

### Using Parameterization Metadata

```typescript
// packages/client/src/runtime/core/engines/client/parameterize.ts

import type { DMMF } from '@prisma/generator-helper'

export class SchemaAwareParameterizer {
  private rules: DMMF.QueryArgumentRules

  constructor(dmmf: DMMF.Document) {
    this.rules = dmmf.schema.queryArgumentRules
  }

  canParameterize(context: Context, key: string, value: unknown): boolean {
    // Check against schema-derived rules
    if (this.rules.nonParameterizable.some((rule) => rule.context === context && (!rule.field || rule.field === key))) {
      return false
    }

    // Check value type against allowed argument types
    return this.isParameterizableValue(value, context)
  }

  parameterize(query: JsonQuery): ParameterizeResult {
    // Use schema rules for correct parameterization
  }
}
```

### Generator Integration

The generated client includes parameterization rules:

```typescript
// Generated in @prisma/client

const dmmf: DMMF.Document = {
  // ... existing DMMF ...

  schema: {
    // ... existing schema ...

    queryArgumentRules: {
      parameterizableArguments: new Set(['scalarFilter', 'scalarData', 'enumFilter', 'enumData', 'dateFilter']),
      nonParameterizable: [
        { context: 'orderBy', reason: 'Sort direction affects query structure' },
        { context: 'pagination', field: 'cursor', reason: 'Cursor structure varies' },
        { context: 'filter', operator: 'mode', reason: 'Case sensitivity is structural' },
      ],
    },
  },
}
```

## Implementation Steps

### Phase 1: prisma-engines Changes (1 week)

1. **Design DMMF schema extension** (1 day)
   - Finalize schema format
   - Document in engines repo

2. **Implement schema analysis** (2 days)
   - Add `ParameterizationRules` type
   - Implement `from_schema()` derivation
   - Handle all field types and contexts

3. **Update DMMF generation** (1 day)
   - Add rules to DMMF output
   - Update TypeScript types in `@prisma/generator-helper`

4. **Update query compiler** (2 days)
   - Replace hardcoded param expectations
   - Use schema-driven validation

### Phase 2: JavaScript Client Integration (3-5 days)

5. **Update DMMF types** (0.5 day)
   - Add new types to `@prisma/generator-helper`
   - Regenerate type definitions

6. **Implement schema-aware parameterizer** (2 days)
   - Create `SchemaAwareParameterizer` class
   - Integrate with existing parameterization

7. **Update generators** (1 day)
   - Include parameterization rules in generated client
   - Update both `client-generator-js` and `client-generator-ts`

8. **Testing** (1-2 days)
   - Unit tests for rule application
   - Integration tests across providers
   - Verify no regressions

## Testing Strategy

### Unit Tests (prisma-engines)

```rust
#[test]
fn test_scalar_filter_parameterizable() {
    let schema = create_test_schema();
    let rules = ParameterizationRules::from_schema(&schema);

    assert!(rules.can_parameterize(Context::Filter, "equals", ScalarValue::Int(42)));
    assert!(rules.can_parameterize(Context::Filter, "in", ScalarValue::List(vec![])));
}

#[test]
fn test_structural_not_parameterizable() {
    let schema = create_test_schema();
    let rules = ParameterizationRules::from_schema(&schema);

    assert!(!rules.can_parameterize(Context::OrderBy, "sort", ScalarValue::String("asc")));
    assert!(!rules.can_parameterize(Context::Filter, "mode", ScalarValue::String("insensitive")));
}
```

### Integration Tests (JavaScript)

```typescript
describe('SchemaAwareParameterizer', () => {
  it('parameterizes scalar filter values', () => {
    const result = parameterizer.parameterize({
      modelName: 'User',
      action: 'findMany',
      query: {
        arguments: { where: { age: { gte: 18 } } },
        selection: { $scalars: true },
      },
    })

    expect(result.parameterizedQuery.query.arguments.where.age.gte).toEqual({
      $type: 'Param',
      name: 'args.where.age.gte',
    })
  })

  it('preserves mode flag', () => {
    const result = parameterizer.parameterize({
      modelName: 'User',
      action: 'findMany',
      query: {
        arguments: {
          where: {
            name: { contains: 'test', mode: 'insensitive' },
          },
        },
        selection: { $scalars: true },
      },
    })

    // 'contains' value is parameterized
    expect(result.parameterizedQuery.query.arguments.where.name.contains).toEqual({
      $type: 'Param',
      name: 'args.where.name.contains',
    })

    // 'mode' is preserved
    expect(result.parameterizedQuery.query.arguments.where.name.mode).toBe('insensitive')
  })
})
```

## Success Criteria

- [ ] DMMF includes parameterization rules
- [ ] Query compiler uses schema-driven validation
- [ ] JavaScript parameterizer uses DMMF rules
- [ ] All filter operators correctly categorized
- [ ] All structural values correctly preserved
- [ ] No false positives (incorrect parameterization)
- [ ] No false negatives (missed parameterization opportunities)
- [ ] All providers supported (PostgreSQL, MySQL, SQLite, SQL Server, MongoDB)

## Risks and Mitigations

| Risk                                    | Likelihood | Impact | Mitigation                                     |
| --------------------------------------- | ---------- | ------ | ---------------------------------------------- |
| Breaking change to DMMF format          | Low        | High   | Version DMMF, maintain backwards compatibility |
| Provider-specific rules needed          | Medium     | Medium | Include provider in rule context               |
| Performance overhead from rule checking | Low        | Low    | Pre-compute rules at client init               |
| Complex edge cases missed               | Medium     | Medium | Comprehensive test suite, gradual rollout      |

## Related Tasks

- **T2.1**: Proper Parameterization (uses these rules)
- **T3.2**: Generate Parameterization at Build Time (builds on this)
- **T3.3**: Pre-compiled Query Templates (uses schema information)

## References

- [DMMF Specification](https://github.com/prisma/prisma/blob/main/packages/generator-helper/src/dmmf.ts)
- [Query Schema in prisma-engines](https://github.com/prisma/prisma-engines/tree/main/query-engine/schema)
- [Query Compiler](https://github.com/prisma/prisma-engines/tree/main/query-compiler)
