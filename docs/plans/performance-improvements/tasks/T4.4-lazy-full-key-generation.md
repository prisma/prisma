# T4.4: Lazy Full Key Generation for Cache Lookups

**Priority**: P2
**Track**: 2 - Query Plan Caching
**Effort**: Small (1-2 days)
**Impact**: Low-Medium (15-20% reduction in cache hit overhead)
**Dependencies**: T1.1 (Query Plan Cache), T2.2 (Cache Key Optimization)

## Objective

Eliminate redundant JSON.stringify calls in the cache hit path by using lazy full key generation, only computing the full string key when needed for collision detection.

## Background

### Current Implementation

The cache hit path currently does:
```typescript
const { parameterizedQuery, queryHash } = parameterizeQuery(query)
const cacheKey = JSON.stringify(parameterizedQuery)  // ~0.6μs overhead
const cached = cache.get(queryHash, cacheKey)
```

### Profiling Results

From profiling on Apple M-series:
- `parameterizeQuery (simple)`: 2.03μs
- `JSON.stringify (simple query)`: 0.61μs
- Cache hit total: 2.99μs

The JSON.stringify accounts for ~20% of the cache hit path time. This is redundant on cache hits where there's no collision.

### Key Insight

With FNV-1a hashing, collisions are rare (<0.01% for typical workloads). We only need the full key for:
1. Collision detection (rare)
2. Cache set operations (less common than gets)

## Technical Design

### Option A: Lazy Key with Callback

Pass a callback that generates the full key only when needed:

```typescript
interface CacheGetOptions {
  hash: number
  getFullKey: () => string
}

class QueryPlanCache {
  get(options: CacheGetOptions): CacheEntry | undefined {
    const entry = this.#cache.get(options.hash)
    if (!entry) return undefined

    // Single entry, no collision detected yet
    if (!Array.isArray(entry)) {
      // Trust the hash - skip full key comparison unless storing collision info
      return entry
    }

    // Collision case - need full key
    const fullKey = options.getFullKey()
    return entry.find(e => e.fullKey === fullKey)
  }
}
```

### Option B: Secondary Hash

Use a secondary hash (different algorithm) to reduce collision probability:

```typescript
interface CacheEntry {
  plan: QueryPlanNode
  placeholderPaths: string[]
  primaryHash: number    // FNV-1a
  secondaryHash: number  // Different algorithm
}

class QueryPlanCache {
  get(primary: number, secondary: number): CacheEntry | undefined {
    const entry = this.#cache.get(primary)
    if (!entry) return undefined

    if (!Array.isArray(entry)) {
      // Check secondary hash instead of full key
      return entry.secondaryHash === secondary ? entry : undefined
    }

    return entry.find(e => e.secondaryHash === secondary)
  }
}
```

### Option C: Probabilistic (Recommended for Performance)

For cache hits, trust the hash. Only verify on suspected collisions:

```typescript
class QueryPlanCache {
  get(hash: number): CacheEntry | undefined {
    const entry = this.#cache.get(hash)
    if (!entry) return undefined

    // Single entry - trust the hash
    if (!Array.isArray(entry)) {
      return entry
    }

    // Collision detected - return first (could add better heuristics)
    return entry[0]
  }
}
```

## Implementation Plan

1. **Update QueryPlanCache interface** (0.5 day)
   - Change `get()` signature to accept lazy key generator
   - Update internal collision handling

2. **Update ClientEngine integration** (0.5 day)
   - Pass lazy generator instead of pre-computed key
   - Update cache set calls

3. **Add benchmarks** (0.5 day)
   - Measure cache hit path before/after
   - Verify no regression in collision handling

4. **Testing** (0.5 day)
   - Unit tests for lazy generation
   - Test collision scenarios still work

## Expected Results

- Cache hit overhead: 2.99μs → ~2.4μs (~20% improvement)
- Ops/sec: ~335K → ~420K

## Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| False positives from hash collision | Very Low | Medium | Secondary hash or periodic validation |
| Complexity increase | Low | Low | Keep implementation simple |
| Regression in collision handling | Low | Medium | Comprehensive testing |

## Related Tasks

- T2.2: Cache Key Optimization (provides hash during parameterization)
- T4.5: Secondary Hash for Collision Reduction (alternative approach)
