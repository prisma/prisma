/**
 * Production build virtual module generation for unplugin-ork
 * Optimizes build performance with caching and bundler-specific strategies
 */

import { createHash } from 'crypto'
import { existsSync } from 'fs'
import { mkdir, readFile, writeFile } from 'fs/promises'
import { dirname, resolve } from 'path'

import { DevOutput } from './dev-output.js'
import type { BuildCache, BuildContext, GeneratedClientCode, GeneratedTypes, ProductionBuildOptions } from './types.js'

export class ProductionBuildManager {
  private options: Required<ProductionBuildOptions>
  private devOutput: DevOutput
  private buildContext: BuildContext
  private version = '0.1.0' // Plugin version for cache invalidation

  constructor(options: ProductionBuildOptions = {}, devOutput: DevOutput, buildContext: BuildContext) {
    this.options = {
      optimize: true,
      cache: true,
      cacheDir: 'node_modules/.cache/unplugin-ork',
      failOnError: buildContext.isProduction,
      sourceMaps: false,
      ...options,
    }
    this.devOutput = devOutput
    this.buildContext = buildContext
  }

  /**
   * Generate virtual modules for production build with optimizations
   */
  async generateProductionModules(
    schemaPath: string,
    schemaContent: string,
    generatedTypes: GeneratedTypes,
    clientModule?: GeneratedClientCode | null,
  ): Promise<{ modules: Record<string, string>; cached: boolean }> {
    const schemaHash = this.createSchemaHash(schemaContent)

    // Try to load from cache first
    if (this.options.cache) {
      const cachedResult = await this.loadFromCache(schemaHash)
      if (cachedResult) {
        this.devOutput.debug('Using cached production modules')
        return { modules: this.createOptimizedModules(cachedResult), cached: true }
      }
    }

    // Generate fresh modules
    this.devOutput.debug('Generating fresh production modules')
    const optimizedModules = this.createOptimizedModules(generatedTypes, clientModule)

    // Cache the results for future builds
    if (this.options.cache) {
      await this.saveToCache(schemaHash, generatedTypes)
    }

    return { modules: optimizedModules, cached: false }
  }

  /**
   * Create optimized virtual modules for production
   */
  private createOptimizedModules(
    generatedTypes: GeneratedTypes,
    clientModule?: GeneratedClientCode | null,
  ): Record<string, string> {
    const modules: Record<string, string> = {}

    // Main types module with production optimizations
    modules.types = this.createOptimizedTypesModule(generatedTypes)

    // Index module for re-exports
    modules.index = this.createOptimizedIndexModule(generatedTypes, !!clientModule)

    // Generated types module (separate for better tree-shaking)
    modules.generated = this.createOptimizedGeneratedModule(generatedTypes)

    // Add generated client modules if available
    if (clientModule) {
      modules.client = this.createOptimizedClientModule(clientModule)
      modules['client-types'] = this.createOptimizedClientTypesModule(clientModule)
    }

    // Add source maps if enabled
    if (this.options.sourceMaps) {
      modules['types.map'] = this.createSourceMap('types', modules.types)
      modules['index.map'] = this.createSourceMap('index', modules.index)
      modules['generated.map'] = this.createSourceMap('generated', modules.generated)

      if (clientModule) {
        modules['client.map'] = this.createSourceMap('client', modules.client)
        modules['client-types.map'] = this.createSourceMap('client-types', modules['client-types'])
      }
    }

    return modules
  }

  /**
   * Create optimized types module for production
   */
  private createOptimizedTypesModule(generatedTypes: GeneratedTypes): string {
    const header = this.buildContext.isProduction
      ? '// Generated by unplugin-ork - production build'
      : '// Generated by unplugin-ork - development build'

    const content = `${header}
${this.options.sourceMaps ? '//# sourceMappingURL=types.map' : ''}

${generatedTypes.interfaces}

${generatedTypes.schema}

${generatedTypes.augmentation}

// Re-export core types for convenience
export type { OrkClient, OrkClientOptions } from '@ork/client'

// Export generated types for tree-shaking
export type * from './generated'`

    return this.options.optimize ? this.optimizeTypeScript(content) : content
  }

  /**
   * Create optimized index module
   */
  private createOptimizedIndexModule(generatedTypes: GeneratedTypes, hasClientModule = false): string {
    const modelNames = this.extractModelNames(generatedTypes.interfaces)

    const baseContent = `// Generated index for .ork directory
${this.options.sourceMaps ? '//# sourceMappingURL=index.map' : ''}
export * from './types'
export type { DatabaseSchema } from './types'

// Model type exports for tree-shaking
${modelNames.map((name) => `export type { ${name} } from './types'`).join('\n')}`

    const enhancedContent = hasClientModule
      ? `

// Generated client exports (runtime + types)
export * from './client'
export type * from './client-types'`
      : ''

    const content = baseContent + enhancedContent

    return this.options.optimize ? this.optimizeTypeScript(content) : content
  }

  /**
   * Create optimized generated types module
   */
  private createOptimizedGeneratedModule(generatedTypes: GeneratedTypes): string {
    const content = `// Generated types from schema.prisma
${this.options.sourceMaps ? '//# sourceMappingURL=generated.map' : ''}
${generatedTypes.interfaces}`

    return this.options.optimize ? this.optimizeTypeScript(content) : content
  }

  /**
   * Create optimized client module for production
   */
  private createOptimizedClientModule(clientModule: GeneratedClientCode): string {
    const header = '// Generated Ork Client - production build'

    const content = `${header}
${this.options.sourceMaps ? '//# sourceMappingURL=client.map' : ''}
// Database dialect: ${clientModule.dialect}

${clientModule.clientCode}`

    return this.options.optimize ? this.optimizeTypeScript(content) : content
  }

  /**
   * Create optimized client types module for production
   */
  private createOptimizedClientTypesModule(clientModule: GeneratedClientCode): string {
    const header = '// Generated Ork Client Types - production build'

    const content = `${header}
${this.options.sourceMaps ? '//# sourceMappingURL=client-types.map' : ''}

${clientModule.declarations}

// Export types for external usage
export type { OrkClient, OrkClientOptions } from '@ork/client'`

    return this.options.optimize ? this.optimizeTypeScript(content) : content
  }

  /**
   * Optimize TypeScript code for production
   */
  private optimizeTypeScript(content: string): string {
    if (!this.options.optimize) return content

    return (
      content
        // Remove extra whitespace and empty lines
        .replace(/\n\s*\n\s*\n/g, '\n\n')
        // Remove trailing whitespace
        .replace(/[ \t]+$/gm, '')
        // Compress multiple spaces to single space in comments
        .replace(/\/\*\s+/g, '/* ')
        .replace(/\s+\*\//g, ' */')
        // Remove excessive comment spacing
        .replace(/\/\/\s+/g, '// ')
    )
  }

  /**
   * Extract model names for tree-shaking optimization
   */
  private extractModelNames(interfaces: string): string[] {
    const modelRegex = /export interface (\w+) \{/g
    const names: string[] = []
    let match: RegExpExecArray | null

    while ((match = modelRegex.exec(interfaces)) !== null) {
      names.push(match[1])
    }

    return names
  }

  /**
   * Create source map for debugging
   */
  private createSourceMap(filename: string, content: string): string {
    // Simplified source map for virtual modules
    const sourceMap = {
      version: 3,
      file: `${filename}.ts`,
      sources: [`virtual:ork/${filename}`],
      names: [],
      mappings: this.generateMappings(content),
    }

    return JSON.stringify(sourceMap, null, 2)
  }

  /**
   * Generate simple mappings for source map
   */
  private generateMappings(content: string): string {
    // Simple mapping - each line maps to itself
    const lines = content.split('\n')
    return lines.map(() => 'AAAA').join(';')
  }

  /**
   * Create hash of schema content for cache invalidation
   */
  public createSchemaHash(content: string): string {
    const hash = createHash('sha256')
      .update(content)
      .update(this.version) // Include plugin version
      .update(JSON.stringify(this.options)) // Include options
      .digest('hex')
      .slice(0, 16) // Use first 16 chars for shorter cache keys

    return hash
  }

  /**
   * Load cached build results
   */
  private async loadFromCache(schemaHash: string): Promise<GeneratedTypes | null> {
    try {
      const cacheFile = this.getCacheFilePath(schemaHash)

      if (!existsSync(cacheFile)) {
        return null
      }

      const cacheData = JSON.parse(await readFile(cacheFile, 'utf-8')) as BuildCache

      // Validate cache
      if (cacheData.schemaHash !== schemaHash || cacheData.version !== this.version || !cacheData.generatedTypes) {
        this.devOutput.debug('Cache invalidated: hash/version mismatch')
        return null
      }

      // Check if cache is recent (within 24 hours for development)
      const maxAge = this.buildContext.isProduction ? Infinity : 24 * 60 * 60 * 1000
      if (Date.now() - cacheData.timestamp > maxAge) {
        this.devOutput.debug('Cache expired')
        return null
      }

      return cacheData.generatedTypes
    } catch (error) {
      this.devOutput.debug(`Cache load error: ${error}`)
      return null
    }
  }

  /**
   * Save build results to cache
   */
  private async saveToCache(schemaHash: string, generatedTypes: GeneratedTypes): Promise<void> {
    try {
      const cacheFile = this.getCacheFilePath(schemaHash)
      const cacheDir = dirname(cacheFile)

      // Ensure cache directory exists
      await mkdir(cacheDir, { recursive: true })

      const cacheData: BuildCache = {
        schemaHash,
        generatedTypes,
        timestamp: Date.now(),
        version: this.version,
      }

      await writeFile(cacheFile, JSON.stringify(cacheData, null, 2))
      this.devOutput.debug(`Cached build results: ${cacheFile}`)
    } catch (error) {
      this.devOutput.debug(`Cache save error: ${error}`)
      // Don't fail the build if caching fails
    }
  }

  /**
   * Get cache file path for schema hash
   */
  private getCacheFilePath(schemaHash: string): string {
    return resolve(this.options.cacheDir, `${schemaHash}.json`)
  }

  /**
   * Clean old cache files to prevent disk space issues
   */
  async cleanCache(maxFiles = 50): Promise<void> {
    try {
      const cacheDir = this.options.cacheDir

      if (!existsSync(cacheDir)) {
        return
      }

      const { readdirSync, statSync, unlinkSync } = await import('fs')
      const files = readdirSync(cacheDir)
        .filter((file) => file.endsWith('.json'))
        .map((file) => ({
          name: file,
          path: resolve(cacheDir, file),
          mtime: statSync(resolve(cacheDir, file)).mtime.getTime(),
        }))
        .sort((a, b) => b.mtime - a.mtime) // Sort by modification time, newest first

      // Remove oldest files if we exceed the limit
      if (files.length > maxFiles) {
        const filesToRemove = files.slice(maxFiles)
        for (const file of filesToRemove) {
          unlinkSync(file.path)
          this.devOutput.debug(`Removed old cache file: ${file.name}`)
        }
      }
    } catch (error) {
      this.devOutput.debug(`Cache cleanup error: ${error}`)
    }
  }

  /**
   * Handle build-time errors with appropriate reporting
   */
  handleBuildError(error: Error, _schemaPath: string): void {
    const errorMessage = `Production build failed: ${error.message}`

    if (this.options.failOnError && this.buildContext.isProduction) {
      // Fail the build in production
      this.devOutput.showSchemaError([
        {
          message: errorMessage,
        },
      ])
      throw new Error(errorMessage)
    } else {
      // Warn but continue in development
      this.devOutput.warn(errorMessage)
      this.devOutput.info('Continuing with fallback types...')
    }
  }

  /**
   * Get bundler-specific optimizations
   */
  getBundlerOptimizations(): Record<string, any> {
    const optimizations: Record<string, any> = {}

    switch (this.buildContext.bundler) {
      case 'vite':
        optimizations.vite = {
          // Vite-specific optimizations
          build: {
            rollupOptions: {
              external: ['@ork/client'],
              output: {
                manualChunks: undefined, // Let Vite handle chunking
              },
            },
          },
        }
        break

      case 'webpack':
        optimizations.webpack = {
          // Webpack-specific optimizations
          optimization: {
            sideEffects: false, // Enable tree-shaking
            usedExports: true,
          },
        }
        break

      case 'rollup':
        optimizations.rollup = {
          // Rollup-specific optimizations
          treeshake: true,
          external: ['@ork/client'],
        }
        break

      case 'esbuild':
        optimizations.esbuild = {
          // ESBuild-specific optimizations
          treeShaking: true,
          format: 'esm',
        }
        break
    }

    return optimizations
  }
}
