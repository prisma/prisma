import { existsSync } from 'fs'
import { mkdir, readFile, writeFile } from 'fs/promises'
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'

import { DevOutput } from '../dev-output.js'
import { ProductionBuildManager } from '../production-build.js'
import type { BuildContext, GeneratedTypes } from '../types.js'

// Mock file system
vi.mock('fs', () => ({
  existsSync: vi.fn(),
  readdirSync: vi.fn(() => []),
  statSync: vi.fn(() => ({ mtime: { getTime: () => Date.now() } })),
  unlinkSync: vi.fn(),
}))

vi.mock('fs/promises', () => ({
  mkdir: vi.fn(),
  readFile: vi.fn(),
  writeFile: vi.fn(),
}))

const mockExistsSync = vi.mocked(existsSync)
const mockReadFile = vi.mocked(readFile)
const mockWriteFile = vi.mocked(writeFile)
const mockMkdir = vi.mocked(mkdir)

describe('ProductionBuildManager', () => {
  let devOutput: DevOutput
  let buildContext: BuildContext
  let manager: ProductionBuildManager
  let mockGeneratedTypes: GeneratedTypes

  beforeEach(() => {
    vi.clearAllMocks()

    devOutput = new DevOutput({ debug: false, silent: true })
    buildContext = {
      isProduction: true,
      isDevelopment: false,
      mode: 'production',
      bundler: 'vite',
    }

    manager = new ProductionBuildManager({}, devOutput, buildContext)

    mockGeneratedTypes = {
      interfaces: `export interface User {
  id: number
  email: string
  name?: string
}

export interface Post {
  id: number
  title: string
  authorId: number
}`,
      schema: `export interface DatabaseSchema {
  user: User  
  post: Post
}`,
      augmentation: `declare module '@ork-orm/client' {
  interface OrkGeneratedSchema extends DatabaseSchema {}
}`,
    }
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('generateProductionModules', () => {
    it('should generate optimized modules for production', async () => {
      const schemaContent = 'model User { id Int @id }'

      const result = await manager.generateProductionModules('/test/schema.prisma', schemaContent, mockGeneratedTypes)

      expect(result.modules).toBeDefined()
      expect(result.modules.types).toContain('Generated by unplugin-ork - production build')
      expect(result.modules.types).toContain('export interface User')
      expect(result.modules.index).toContain("export * from './types'")
      expect(result.modules.generated).toContain('Generated types from schema.prisma')
      expect(result.cached).toBe(false)
    })

    it('should use cached modules when available', async () => {
      const schemaContent = 'model User { id Int @id }'

      // Generate the actual hash that would be created
      const expectedHash = manager.createSchemaHash(schemaContent)

      // Mock cache exists
      mockExistsSync.mockReturnValue(true)
      mockReadFile.mockResolvedValue(
        JSON.stringify({
          schemaHash: expectedHash,
          generatedTypes: mockGeneratedTypes,
          timestamp: Date.now(),
          version: '0.1.0',
        }),
      )

      const result = await manager.generateProductionModules('/test/schema.prisma', schemaContent, mockGeneratedTypes)

      expect(result.cached).toBe(true)
      expect(result.modules.types).toContain('export interface User')
    })

    it('should invalidate cache on version mismatch', async () => {
      const schemaContent = 'model User { id Int @id }'

      // Mock cache exists with old version
      mockExistsSync.mockReturnValue(true)
      mockReadFile.mockResolvedValue(
        JSON.stringify({
          schemaHash: 'test-hash',
          generatedTypes: mockGeneratedTypes,
          timestamp: Date.now(),
          version: '0.0.1', // Old version
        }),
      )

      const result = await manager.generateProductionModules('/test/schema.prisma', schemaContent, mockGeneratedTypes)

      expect(result.cached).toBe(false)
    })

    it('should save cache for future builds', async () => {
      const schemaContent = 'model User { id Int @id }'

      await manager.generateProductionModules('/test/schema.prisma', schemaContent, mockGeneratedTypes)

      expect(mockMkdir).toHaveBeenCalled()
      expect(mockWriteFile).toHaveBeenCalled()
    })
  })

  describe('optimization', () => {
    it('should optimize TypeScript code in production', async () => {
      const manager = new ProductionBuildManager({ optimize: true }, devOutput, buildContext)

      const result = await manager.generateProductionModules(
        '/test/schema.prisma',
        'model User { id Int @id }',
        mockGeneratedTypes,
      )

      // Check that optimization occurred (no excessive whitespace)
      expect(result.modules.types).not.toMatch(/\n\s*\n\s*\n/)
    })

    it('should skip optimization when disabled', async () => {
      const manager = new ProductionBuildManager({ optimize: false }, devOutput, buildContext)

      const result = await manager.generateProductionModules(
        '/test/schema.prisma',
        'model User { id Int @id }',
        mockGeneratedTypes,
      )

      expect(result.modules.types).toBeDefined()
    })

    it('should generate source maps when enabled', async () => {
      const manager = new ProductionBuildManager({ sourceMaps: true }, devOutput, buildContext)

      const result = await manager.generateProductionModules(
        '/test/schema.prisma',
        'model User { id Int @id }',
        mockGeneratedTypes,
      )

      expect(result.modules['types.map']).toBeDefined()
      expect(result.modules['index.map']).toBeDefined()
      expect(result.modules['generated.map']).toBeDefined()

      // Check source map content
      const sourceMap = JSON.parse(result.modules['types.map'])
      expect(sourceMap.version).toBe(3)
      expect(sourceMap.file).toBe('types.ts')
    })
  })

  describe('error handling', () => {
    it('should fail build on error in production when failOnError is true', () => {
      const manager = new ProductionBuildManager({ failOnError: true }, devOutput, buildContext)

      const error = new Error('Schema parsing failed')

      expect(() => {
        manager.handleBuildError(error, '/test/schema.prisma')
      }).toThrow('Production build failed: Schema parsing failed')
    })

    it('should continue build on error when failOnError is false', () => {
      const manager = new ProductionBuildManager({ failOnError: false }, devOutput, buildContext)

      const error = new Error('Schema parsing failed')

      expect(() => {
        manager.handleBuildError(error, '/test/schema.prisma')
      }).not.toThrow()
    })

    it('should handle cache errors gracefully', async () => {
      mockExistsSync.mockReturnValue(true)
      mockReadFile.mockRejectedValue(new Error('File read error'))

      const result = await manager.generateProductionModules(
        '/test/schema.prisma',
        'model User { id Int @id }',
        mockGeneratedTypes,
      )

      // Should fallback to fresh generation
      expect(result.cached).toBe(false)
      expect(result.modules.types).toBeDefined()
    })
  })

  describe('bundler optimizations', () => {
    it('should provide Vite-specific optimizations', () => {
      const buildContext: BuildContext = {
        isProduction: true,
        isDevelopment: false,
        mode: 'production',
        bundler: 'vite',
      }

      const manager = new ProductionBuildManager({}, devOutput, buildContext)
      const optimizations = manager.getBundlerOptimizations()

      expect(optimizations.vite).toBeDefined()
      expect(optimizations.vite.build).toBeDefined()
    })

    it('should provide Webpack-specific optimizations', () => {
      const buildContext: BuildContext = {
        isProduction: true,
        isDevelopment: false,
        mode: 'production',
        bundler: 'webpack',
      }

      const manager = new ProductionBuildManager({}, devOutput, buildContext)
      const optimizations = manager.getBundlerOptimizations()

      expect(optimizations.webpack).toBeDefined()
      expect(optimizations.webpack.optimization).toBeDefined()
    })

    it('should provide Rollup-specific optimizations', () => {
      const buildContext: BuildContext = {
        isProduction: true,
        isDevelopment: false,
        mode: 'production',
        bundler: 'rollup',
      }

      const manager = new ProductionBuildManager({}, devOutput, buildContext)
      const optimizations = manager.getBundlerOptimizations()

      expect(optimizations.rollup).toBeDefined()
      expect(optimizations.rollup.treeshake).toBe(true)
    })

    it('should provide ESBuild-specific optimizations', () => {
      const buildContext: BuildContext = {
        isProduction: true,
        isDevelopment: false,
        mode: 'production',
        bundler: 'esbuild',
      }

      const manager = new ProductionBuildManager({}, devOutput, buildContext)
      const optimizations = manager.getBundlerOptimizations()

      expect(optimizations.esbuild).toBeDefined()
      expect(optimizations.esbuild.treeShaking).toBe(true)
    })
  })

  describe('cache management', () => {
    it('should clean old cache files', async () => {
      const { readdirSync, statSync, unlinkSync } = await import('fs')
      const mockReaddirSync = vi.mocked(readdirSync)
      const mockStatSync = vi.mocked(statSync)
      const mockUnlinkSync = vi.mocked(unlinkSync)

      // Mock cache directory with many files
      mockExistsSync.mockReturnValue(true)
      mockReaddirSync.mockReturnValue(['old1.json', 'old2.json', 'old3.json'])
      mockStatSync.mockReturnValue({
        mtime: { getTime: () => Date.now() - 1000000 },
      })

      await manager.cleanCache(1) // Keep only 1 file

      expect(mockUnlinkSync).toHaveBeenCalledTimes(2)
    })

    it('should handle cache directory not existing', async () => {
      mockExistsSync.mockReturnValue(false)

      await expect(manager.cleanCache()).resolves.not.toThrow()
    })
  })
})
