/**
 * Generated Refract Client
 *
 * Do not edit this file manually. Regenerate with `refract generate`
 *
 * Generated at: 2026-01-01T21:05:15.788Z
 */

import { RefractClientBase } from '@refract/client'
import { createKyselyDialect, loadRefractConfig } from '@refract/config'
import { Kysely } from 'kysely'
import type {
  Dialect,
  ExpressionBuilder,
  SelectQueryBuilder,
  UpdateQueryBuilder,
  DeleteQueryBuilder,
  Expression,
  SqlBool,
  ReferenceExpression,
  Selectable,
} from 'kysely'

import { jsonArrayFrom, jsonObjectFrom } from 'kysely/helpers/postgres'

/**
 * Prettify<T> - Flattens intersection types for cleaner IDE tooltips
 * @see https://www.totaltypescript.com/concepts/the-prettify-helper
 */
export type Prettify<T> = { [K in keyof T]: T[K] } & {}

/**
 * User scalar fields (no relations)
 */
export type UserScalars = {
  id: number
  email: string
  name?: string
  createdAt: Date
  updatedAt: Date
}

/**
 * User relation payloads when included
 */
export type UserRelations = {
  posts: Post[]
  profile: Profile | null
}

/**
 * Get the return type for User based on include options
 * @example
 * type WithPosts = UserGetPayload<{ include: { posts: true } }>
 */
export type UserGetPayload<T extends { include?: UserInclude } | undefined | null = undefined> = Prettify<
  UserScalars &
    (T extends { include: infer I extends UserInclude }
      ? { [K in keyof I as I[K] extends true ? K : never]: K extends keyof UserRelations ? UserRelations[K] : never }
      : {})
>

/**
 * Full User type with optional relations
 * For precise typing based on include, use UserGetPayload<T>
 */
export interface User extends UserScalars {
  posts?: Post[]
  profile?: Profile
}

export type UserRow = Selectable<DatabaseSchema['User']>
export type UserRowWithIncludes = UserRow & Partial<UserRelations>

/**
 * Profile scalar fields (no relations)
 */
export type ProfileScalars = {
  id: number
  bio?: string
  userId: number
}

/**
 * Profile relation payloads when included
 */
export type ProfileRelations = {
  user: User | null
}

/**
 * Get the return type for Profile based on include options
 * @example
 * type WithPosts = ProfileGetPayload<{ include: { posts: true } }>
 */
export type ProfileGetPayload<T extends { include?: ProfileInclude } | undefined | null = undefined> = Prettify<
  ProfileScalars &
    (T extends { include: infer I extends ProfileInclude }
      ? {
          [K in keyof I as I[K] extends true ? K : never]: K extends keyof ProfileRelations
            ? ProfileRelations[K]
            : never
        }
      : {})
>

/**
 * Full Profile type with optional relations
 * For precise typing based on include, use ProfileGetPayload<T>
 */
export interface Profile extends ProfileScalars {
  user?: User
}

export type ProfileRow = Selectable<DatabaseSchema['Profile']>
export type ProfileRowWithIncludes = ProfileRow & Partial<ProfileRelations>

/**
 * Post scalar fields (no relations)
 */
export type PostScalars = {
  id: number
  title: string
  content?: string
  published: boolean
  authorId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Post relation payloads when included
 */
export type PostRelations = {
  author: User | null
}

/**
 * Get the return type for Post based on include options
 * @example
 * type WithPosts = PostGetPayload<{ include: { posts: true } }>
 */
export type PostGetPayload<T extends { include?: PostInclude } | undefined | null = undefined> = Prettify<
  PostScalars &
    (T extends { include: infer I extends PostInclude }
      ? { [K in keyof I as I[K] extends true ? K : never]: K extends keyof PostRelations ? PostRelations[K] : never }
      : {})
>

/**
 * Full Post type with optional relations
 * For precise typing based on include, use PostGetPayload<T>
 */
export interface Post extends PostScalars {
  author?: User
}

export type PostRow = Selectable<DatabaseSchema['Post']>
export type PostRowWithIncludes = PostRow & Partial<PostRelations>
export interface DatabaseSchema {
  User: User
  Profile: Profile
  Post: Post
  [modelName: string]: Record<string, any>
}

/**
 * Base filter type for all field types
 */
export type BaseFilter<T> = {
  equals?: T
  in?: T[]
  notIn?: T[]
  not?: BaseFilter<T> | T
}

/**
 * Filter for numeric fields (Int, Float, BigInt)
 */
export type NumericFilter<T extends number | bigint = number> = BaseFilter<T> & {
  lt?: T
  lte?: T
  gt?: T
  gte?: T
}

/**
 * Filter for string fields
 * Generic parameter allows string | null for nullable fields
 */
export type StringFilter<T extends string | null = string> = BaseFilter<T> & {
  contains?: string
  startsWith?: string
  endsWith?: string
  // mode?: 'default' | 'insensitive' // Deferred: case-insensitive search
}

/**
 * Filter for boolean fields
 */
export type BooleanFilter = BaseFilter<boolean>

/**
 * Filter for DateTime fields
 * Accepts Date objects or ISO string representations
 */
export type DateTimeFilter<T extends Date | string | null = Date | string> = BaseFilter<T> & {
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
}

/**
 * Filter for Json fields
 */
export type JsonFilter = BaseFilter<any>

/**
 * Sort order for orderBy clauses
 */
export type SortOrder = 'asc' | 'desc'

/**
 * Filter for one-to-many relation to Post
 * Note: Runtime implementation deferred to Phase 2+
 */
export type PostListRelationFilter = {
  every?: PostWhereInput
  some?: PostWhereInput
  none?: PostWhereInput
}

/**
 * Filter for one-to-one relation to Post
 * Note: Runtime implementation deferred to Phase 2+
 */
export type PostRelationFilter = {
  is?: PostWhereInput | null
  isNot?: PostWhereInput | null
}

/**
 * Filter for one-to-many relation to Profile
 * Note: Runtime implementation deferred to Phase 2+
 */
export type ProfileListRelationFilter = {
  every?: ProfileWhereInput
  some?: ProfileWhereInput
  none?: ProfileWhereInput
}

/**
 * Filter for one-to-one relation to Profile
 * Note: Runtime implementation deferred to Phase 2+
 */
export type ProfileRelationFilter = {
  is?: ProfileWhereInput | null
  isNot?: ProfileWhereInput | null
}

/**
 * Filter for one-to-many relation to User
 * Note: Runtime implementation deferred to Phase 2+
 */
export type UserListRelationFilter = {
  every?: UserWhereInput
  some?: UserWhereInput
  none?: UserWhereInput
}

/**
 * Filter for one-to-one relation to User
 * Note: Runtime implementation deferred to Phase 2+
 */
export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}

export type UserWhereInput = {
  id?: NumericFilter<number> | number
  email?: StringFilter<string> | string
  name?: StringFilter<string | null> | string | null
  createdAt?: DateTimeFilter<Date | string> | Date
  updatedAt?: DateTimeFilter<Date | string> | Date
  posts?: PostListRelationFilter
  profile?: ProfileRelationFilter | null
  AND?: UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput[]
}

export type UserWhereUniqueInput = {
  id?: number
  email?: string
}

export type UserOrderByWithRelationInput = {
  id?: SortOrder
  email?: SortOrder
  name?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
}

export type UserCreateInput = {
  email: string
  name?: string | null
  createdAt?: Date
}

export type UserUpdateInput = {
  email?: string
  name?: string | null
  createdAt?: Date
}

// Args types for User
export type UserFindManyArgs = {
  where?: UserWhereInput
  orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
  take?: number
  skip?: number
  include?: UserInclude
}

export type UserFindUniqueArgs = {
  where: UserWhereUniqueInput
  include?: UserInclude
}

export type UserFindFirstArgs = {
  where?: UserWhereInput
  orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
  include?: UserInclude
}

export type UserCreateArgs = {
  data: UserCreateInput
}

export type UserCreateManyArgs = {
  data: UserCreateInput[]
}

export type UserUpdateArgs = {
  where: UserWhereUniqueInput
  data: UserUpdateInput
}

export type UserUpdateManyArgs = {
  where?: UserWhereInput
  data: UserUpdateInput
}

export type UserUpsertArgs = {
  where: UserWhereUniqueInput
  create: UserCreateInput
  update: UserUpdateInput
}

export type UserDeleteArgs = {
  where: UserWhereUniqueInput
}

export type UserDeleteManyArgs = {
  where?: UserWhereInput
}

export type UserCountArgs = {
  where?: UserWhereInput
}

export type ProfileWhereInput = {
  id?: NumericFilter<number> | number
  bio?: StringFilter<string | null> | string | null
  userId?: NumericFilter<number> | number
  user?: UserRelationFilter | null
  AND?: ProfileWhereInput[]
  OR?: ProfileWhereInput[]
  NOT?: ProfileWhereInput[]
}

export type ProfileWhereUniqueInput = {
  id?: number
  userId?: number
}

export type ProfileOrderByWithRelationInput = {
  id?: SortOrder
  bio?: SortOrder
  userId?: SortOrder
}

export type ProfileCreateInput = {
  bio?: string | null
  userId: number
}

export type ProfileUpdateInput = {
  bio?: string | null
  userId?: number
}

// Args types for Profile
export type ProfileFindManyArgs = {
  where?: ProfileWhereInput
  orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
  take?: number
  skip?: number
  include?: ProfileInclude
}

export type ProfileFindUniqueArgs = {
  where: ProfileWhereUniqueInput
  include?: ProfileInclude
}

export type ProfileFindFirstArgs = {
  where?: ProfileWhereInput
  orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
  include?: ProfileInclude
}

export type ProfileCreateArgs = {
  data: ProfileCreateInput
}

export type ProfileCreateManyArgs = {
  data: ProfileCreateInput[]
}

export type ProfileUpdateArgs = {
  where: ProfileWhereUniqueInput
  data: ProfileUpdateInput
}

export type ProfileUpdateManyArgs = {
  where?: ProfileWhereInput
  data: ProfileUpdateInput
}

export type ProfileUpsertArgs = {
  where: ProfileWhereUniqueInput
  create: ProfileCreateInput
  update: ProfileUpdateInput
}

export type ProfileDeleteArgs = {
  where: ProfileWhereUniqueInput
}

export type ProfileDeleteManyArgs = {
  where?: ProfileWhereInput
}

export type ProfileCountArgs = {
  where?: ProfileWhereInput
}

export type PostWhereInput = {
  id?: NumericFilter<number> | number
  title?: StringFilter<string> | string
  content?: StringFilter<string | null> | string | null
  published?: BooleanFilter | boolean
  authorId?: NumericFilter<number> | number
  createdAt?: DateTimeFilter<Date | string> | Date
  updatedAt?: DateTimeFilter<Date | string> | Date
  author?: UserRelationFilter | null
  AND?: PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput[]
}

export type PostWhereUniqueInput = {
  id?: number
}

export type PostOrderByWithRelationInput = {
  id?: SortOrder
  title?: SortOrder
  content?: SortOrder
  published?: SortOrder
  authorId?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
}

export type PostCreateInput = {
  title: string
  content?: string | null
  published?: boolean
  authorId: number
  createdAt?: Date
}

export type PostUpdateInput = {
  title?: string
  content?: string | null
  published?: boolean
  authorId?: number
  createdAt?: Date
}

// Args types for Post
export type PostFindManyArgs = {
  where?: PostWhereInput
  orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
  take?: number
  skip?: number
  include?: PostInclude
}

export type PostFindUniqueArgs = {
  where: PostWhereUniqueInput
  include?: PostInclude
}

export type PostFindFirstArgs = {
  where?: PostWhereInput
  orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
  include?: PostInclude
}

export type PostCreateArgs = {
  data: PostCreateInput
}

export type PostCreateManyArgs = {
  data: PostCreateInput[]
}

export type PostUpdateArgs = {
  where: PostWhereUniqueInput
  data: PostUpdateInput
}

export type PostUpdateManyArgs = {
  where?: PostWhereInput
  data: PostUpdateInput
}

export type PostUpsertArgs = {
  where: PostWhereUniqueInput
  create: PostCreateInput
  update: PostUpdateInput
}

export type PostDeleteArgs = {
  where: PostWhereUniqueInput
}

export type PostDeleteManyArgs = {
  where?: PostWhereInput
}

export type PostCountArgs = {
  where?: PostWhereInput
}

export interface UserInclude {
  posts?: boolean
  profile?: boolean
}

export interface ProfileInclude {
  user?: boolean
}

export interface PostInclude {
  author?: boolean
}

export interface ModelCRUDOperations<T, TInclude = any> {
  findMany(args?: { where?: Partial<T>; orderBy?: any; take?: number; skip?: number; include?: TInclude }): Promise<T[]>
  findUnique(args: { where: Partial<T>; include?: TInclude }): Promise<T | null>
  findFirst(args?: { where?: Partial<T>; orderBy?: any; include?: TInclude }): Promise<T | null>
  create(args: { data: any }): Promise<T>
  createMany(args: { data: any[] }): Promise<{ count: number }>
  update(args: { where: Partial<T>; data: any }): Promise<T>
  updateMany(args: { where?: Partial<T>; data: any }): Promise<{ count: number }>
  upsert(args: { where: Partial<T>; create: any; update: any }): Promise<T>
  delete(args: { where: Partial<T> }): Promise<T>
  deleteMany(args?: { where?: Partial<T> }): Promise<{ count: number }>
  count(args?: { where?: Partial<T> }): Promise<number>
}

function transformWhereValue_User(fieldName: string, value: unknown): unknown {
  if (fieldName === 'id') {
    return Number(value)
  }

  if (fieldName === 'email') {
    return String(value)
  }

  if (fieldName === 'name') {
    return value !== null ? String(value) : null
  }

  if (fieldName === 'createdAt') {
    return new Date(value as string | number | Date)
  }

  if (fieldName === 'updatedAt') {
    return new Date(value as string | number | Date)
  }

  return value // No transformation needed for this field
}

function buildFieldExpression_User(eb: ExpressionBuilder<DatabaseSchema, 'User'>, field: string, value: unknown) {
  const qualifiedField = `User.${field}` as ReferenceExpression<DatabaseSchema, 'User'>

  if (value === null) {
    return eb(qualifiedField, 'is', null)
  }

  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
    const conditions: Expression<SqlBool>[] = []

    for (const [operator, operatorValue] of Object.entries(value)) {
      switch (operator) {
        case 'equals':
          if (operatorValue === null) {
            conditions.push(eb(qualifiedField, 'is', null))
          } else {
            conditions.push(eb(qualifiedField, '=', transformWhereValue_User(field, operatorValue)))
          }
          break
        case 'gt':
          conditions.push(eb(qualifiedField, '>', transformWhereValue_User(field, operatorValue)))
          break
        case 'gte':
          conditions.push(eb(qualifiedField, '>=', transformWhereValue_User(field, operatorValue)))
          break
        case 'lt':
          conditions.push(eb(qualifiedField, '<', transformWhereValue_User(field, operatorValue)))
          break
        case 'lte':
          conditions.push(eb(qualifiedField, '<=', transformWhereValue_User(field, operatorValue)))
          break
        case 'not':
          if (operatorValue === null) {
            conditions.push(eb(qualifiedField, 'is not', null))
          } else {
            conditions.push(eb(qualifiedField, '!=', transformWhereValue_User(field, operatorValue)))
          }
          break
        case 'in':
          conditions.push(
            eb(
              qualifiedField,
              'in',
              (operatorValue as unknown[]).map((v) => transformWhereValue_User(field, v)),
            ),
          )
          break
        case 'notIn':
          conditions.push(
            eb(
              qualifiedField,
              'not in',
              (operatorValue as unknown[]).map((v) => transformWhereValue_User(field, v)),
            ),
          )
          break
        case 'contains':
          conditions.push(eb(qualifiedField, 'like', `%${operatorValue}%`))
          break
        case 'startsWith':
          conditions.push(eb(qualifiedField, 'like', `${operatorValue}%`))
          break
        case 'endsWith':
          conditions.push(eb(qualifiedField, 'like', `%${operatorValue}`))
          break
      }
    }

    return eb.and(conditions)
  }

  return eb(qualifiedField, '=', transformWhereValue_User(field, value))
}

function buildRelationExpression_User(
  kysely: Kysely<DatabaseSchema>,
  eb: ExpressionBuilder<DatabaseSchema, 'User'>,
  field: string,
  value: unknown,
) {
  switch (field) {
    case 'posts': {
      if (value === null || typeof value !== 'object') {
        return eb.and([])
      }

      const filter = value as { some?: PostWhereInput; every?: PostWhereInput; none?: PostWhereInput }
      const conditions: Expression<SqlBool>[] = []
      const baseQuery = () => eb.selectFrom('Post').select('Post.id').whereRef('Post.authorId', '=', 'User.id')

      if (filter.some) {
        conditions.push(
          eb.exists(
            baseQuery().where((relEb) => buildWhereExpression_Post(kysely, relEb, filter.some as PostWhereInput)),
          ),
        )
      }

      if (filter.every) {
        const existsAny = eb.exists(baseQuery())
        const existsNonMatching = eb.exists(
          baseQuery().where((relEb) =>
            relEb.not(buildWhereExpression_Post(kysely, relEb, filter.every as PostWhereInput)),
          ),
        )
        conditions.push(eb.and([existsAny, eb.not(existsNonMatching)]))
      }

      if (filter.none) {
        conditions.push(
          eb.not(
            eb.exists(
              baseQuery().where((relEb) => buildWhereExpression_Post(kysely, relEb, filter.none as PostWhereInput)),
            ),
          ),
        )
      }

      return eb.and(conditions)
    }
    case 'profile': {
      const baseQuery = () => eb.selectFrom('Profile').select('Profile.id').whereRef('Profile.userId', '=', 'User.id')

      if (value === null) {
        return eb.not(eb.exists(baseQuery()))
      }

      if (value === null || typeof value !== 'object') {
        return eb.and([])
      }

      const filter = value as { is?: ProfileWhereInput | null; isNot?: ProfileWhereInput | null }
      const conditions: Expression<SqlBool>[] = []

      if ('is' in filter) {
        if (filter.is === null) {
          conditions.push(eb.not(eb.exists(baseQuery())))
        } else if (filter.is) {
          conditions.push(
            eb.exists(
              baseQuery().where((relEb) => buildWhereExpression_Profile(kysely, relEb, filter.is as ProfileWhereInput)),
            ),
          )
        }
      }

      if ('isNot' in filter) {
        if (filter.isNot === null) {
          conditions.push(eb.exists(baseQuery()))
        } else if (filter.isNot) {
          const existsAny = eb.exists(baseQuery())
          const existsMatch = eb.exists(
            baseQuery().where((relEb) =>
              buildWhereExpression_Profile(kysely, relEb, filter.isNot as ProfileWhereInput),
            ),
          )
          conditions.push(eb.and([existsAny, eb.not(existsMatch)]))
        }
      }

      return eb.and(conditions)
    }
    default:
      return eb.and([])
  }
}

function buildWhereExpression_User(
  kysely: Kysely<DatabaseSchema>,
  eb: ExpressionBuilder<DatabaseSchema, 'User'>,
  where: UserWhereInput,
) {
  const expressions: Expression<SqlBool>[] = []

  for (const [field, value] of Object.entries(where)) {
    if (field === 'AND') {
      expressions.push(eb.and((value as UserWhereInput[]).map((cond) => buildWhereExpression_User(kysely, eb, cond))))
    } else if (field === 'OR') {
      expressions.push(eb.or((value as UserWhereInput[]).map((cond) => buildWhereExpression_User(kysely, eb, cond))))
    } else if (field === 'NOT') {
      // `eb.not` doesn't accept a list, so need to negate each condition instead.
      for (const cond of value as UserWhereInput[]) {
        expressions.push(eb.not(buildWhereExpression_User(kysely, eb, cond)))
      }
    } else {
      switch (field) {
        case 'posts':
        case 'profile':
          expressions.push(buildRelationExpression_User(kysely, eb, field, value))
          break
        default:
          expressions.push(buildFieldExpression_User(eb, field, value))
      }
    }
  }

  return eb.and(expressions)
}

function transformWhereValue_Profile(fieldName: string, value: unknown): unknown {
  if (fieldName === 'id') {
    return Number(value)
  }

  if (fieldName === 'bio') {
    return value !== null ? String(value) : null
  }

  if (fieldName === 'userId') {
    return Number(value)
  }

  return value // No transformation needed for this field
}

function buildFieldExpression_Profile(eb: ExpressionBuilder<DatabaseSchema, 'Profile'>, field: string, value: unknown) {
  const qualifiedField = `Profile.${field}` as ReferenceExpression<DatabaseSchema, 'Profile'>

  if (value === null) {
    return eb(qualifiedField, 'is', null)
  }

  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
    const conditions: Expression<SqlBool>[] = []

    for (const [operator, operatorValue] of Object.entries(value)) {
      switch (operator) {
        case 'equals':
          if (operatorValue === null) {
            conditions.push(eb(qualifiedField, 'is', null))
          } else {
            conditions.push(eb(qualifiedField, '=', transformWhereValue_Profile(field, operatorValue)))
          }
          break
        case 'gt':
          conditions.push(eb(qualifiedField, '>', transformWhereValue_Profile(field, operatorValue)))
          break
        case 'gte':
          conditions.push(eb(qualifiedField, '>=', transformWhereValue_Profile(field, operatorValue)))
          break
        case 'lt':
          conditions.push(eb(qualifiedField, '<', transformWhereValue_Profile(field, operatorValue)))
          break
        case 'lte':
          conditions.push(eb(qualifiedField, '<=', transformWhereValue_Profile(field, operatorValue)))
          break
        case 'not':
          if (operatorValue === null) {
            conditions.push(eb(qualifiedField, 'is not', null))
          } else {
            conditions.push(eb(qualifiedField, '!=', transformWhereValue_Profile(field, operatorValue)))
          }
          break
        case 'in':
          conditions.push(
            eb(
              qualifiedField,
              'in',
              (operatorValue as unknown[]).map((v) => transformWhereValue_Profile(field, v)),
            ),
          )
          break
        case 'notIn':
          conditions.push(
            eb(
              qualifiedField,
              'not in',
              (operatorValue as unknown[]).map((v) => transformWhereValue_Profile(field, v)),
            ),
          )
          break
        case 'contains':
          conditions.push(eb(qualifiedField, 'like', `%${operatorValue}%`))
          break
        case 'startsWith':
          conditions.push(eb(qualifiedField, 'like', `${operatorValue}%`))
          break
        case 'endsWith':
          conditions.push(eb(qualifiedField, 'like', `%${operatorValue}`))
          break
      }
    }

    return eb.and(conditions)
  }

  return eb(qualifiedField, '=', transformWhereValue_Profile(field, value))
}

function buildRelationExpression_Profile(
  kysely: Kysely<DatabaseSchema>,
  eb: ExpressionBuilder<DatabaseSchema, 'Profile'>,
  field: string,
  value: unknown,
) {
  switch (field) {
    case 'user': {
      const baseQuery = () => eb.selectFrom('User').select('User.id').whereRef('Profile.userId', '=', 'User.id')

      if (value === null) {
        return eb.not(eb.exists(baseQuery()))
      }

      if (value === null || typeof value !== 'object') {
        return eb.and([])
      }

      const filter = value as { is?: UserWhereInput | null; isNot?: UserWhereInput | null }
      const conditions: Expression<SqlBool>[] = []

      if ('is' in filter) {
        if (filter.is === null) {
          conditions.push(eb.not(eb.exists(baseQuery())))
        } else if (filter.is) {
          conditions.push(
            eb.exists(
              baseQuery().where((relEb) => buildWhereExpression_User(kysely, relEb, filter.is as UserWhereInput)),
            ),
          )
        }
      }

      if ('isNot' in filter) {
        if (filter.isNot === null) {
          conditions.push(eb.exists(baseQuery()))
        } else if (filter.isNot) {
          const existsAny = eb.exists(baseQuery())
          const existsMatch = eb.exists(
            baseQuery().where((relEb) => buildWhereExpression_User(kysely, relEb, filter.isNot as UserWhereInput)),
          )
          conditions.push(eb.and([existsAny, eb.not(existsMatch)]))
        }
      }

      return eb.and(conditions)
    }
    default:
      return eb.and([])
  }
}

function buildWhereExpression_Profile(
  kysely: Kysely<DatabaseSchema>,
  eb: ExpressionBuilder<DatabaseSchema, 'Profile'>,
  where: ProfileWhereInput,
) {
  const expressions: Expression<SqlBool>[] = []

  for (const [field, value] of Object.entries(where)) {
    if (field === 'AND') {
      expressions.push(
        eb.and((value as ProfileWhereInput[]).map((cond) => buildWhereExpression_Profile(kysely, eb, cond))),
      )
    } else if (field === 'OR') {
      expressions.push(
        eb.or((value as ProfileWhereInput[]).map((cond) => buildWhereExpression_Profile(kysely, eb, cond))),
      )
    } else if (field === 'NOT') {
      // `eb.not` doesn't accept a list, so need to negate each condition instead.
      for (const cond of value as ProfileWhereInput[]) {
        expressions.push(eb.not(buildWhereExpression_Profile(kysely, eb, cond)))
      }
    } else {
      switch (field) {
        case 'user':
          expressions.push(buildRelationExpression_Profile(kysely, eb, field, value))
          break
        default:
          expressions.push(buildFieldExpression_Profile(eb, field, value))
      }
    }
  }

  return eb.and(expressions)
}

function transformWhereValue_Post(fieldName: string, value: unknown): unknown {
  if (fieldName === 'id') {
    return Number(value)
  }

  if (fieldName === 'title') {
    return String(value)
  }

  if (fieldName === 'content') {
    return value !== null ? String(value) : null
  }

  if (fieldName === 'published') {
    return value
  }

  if (fieldName === 'authorId') {
    return Number(value)
  }

  if (fieldName === 'createdAt') {
    return new Date(value as string | number | Date)
  }

  if (fieldName === 'updatedAt') {
    return new Date(value as string | number | Date)
  }

  return value // No transformation needed for this field
}

function buildFieldExpression_Post(eb: ExpressionBuilder<DatabaseSchema, 'Post'>, field: string, value: unknown) {
  const qualifiedField = `Post.${field}` as ReferenceExpression<DatabaseSchema, 'Post'>

  if (value === null) {
    return eb(qualifiedField, 'is', null)
  }

  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
    const conditions: Expression<SqlBool>[] = []

    for (const [operator, operatorValue] of Object.entries(value)) {
      switch (operator) {
        case 'equals':
          if (operatorValue === null) {
            conditions.push(eb(qualifiedField, 'is', null))
          } else {
            conditions.push(eb(qualifiedField, '=', transformWhereValue_Post(field, operatorValue)))
          }
          break
        case 'gt':
          conditions.push(eb(qualifiedField, '>', transformWhereValue_Post(field, operatorValue)))
          break
        case 'gte':
          conditions.push(eb(qualifiedField, '>=', transformWhereValue_Post(field, operatorValue)))
          break
        case 'lt':
          conditions.push(eb(qualifiedField, '<', transformWhereValue_Post(field, operatorValue)))
          break
        case 'lte':
          conditions.push(eb(qualifiedField, '<=', transformWhereValue_Post(field, operatorValue)))
          break
        case 'not':
          if (operatorValue === null) {
            conditions.push(eb(qualifiedField, 'is not', null))
          } else {
            conditions.push(eb(qualifiedField, '!=', transformWhereValue_Post(field, operatorValue)))
          }
          break
        case 'in':
          conditions.push(
            eb(
              qualifiedField,
              'in',
              (operatorValue as unknown[]).map((v) => transformWhereValue_Post(field, v)),
            ),
          )
          break
        case 'notIn':
          conditions.push(
            eb(
              qualifiedField,
              'not in',
              (operatorValue as unknown[]).map((v) => transformWhereValue_Post(field, v)),
            ),
          )
          break
        case 'contains':
          conditions.push(eb(qualifiedField, 'like', `%${operatorValue}%`))
          break
        case 'startsWith':
          conditions.push(eb(qualifiedField, 'like', `${operatorValue}%`))
          break
        case 'endsWith':
          conditions.push(eb(qualifiedField, 'like', `%${operatorValue}`))
          break
      }
    }

    return eb.and(conditions)
  }

  return eb(qualifiedField, '=', transformWhereValue_Post(field, value))
}

function buildRelationExpression_Post(
  kysely: Kysely<DatabaseSchema>,
  eb: ExpressionBuilder<DatabaseSchema, 'Post'>,
  field: string,
  value: unknown,
) {
  switch (field) {
    case 'author': {
      const baseQuery = () => eb.selectFrom('User').select('User.id').whereRef('Post.authorId', '=', 'User.id')

      if (value === null) {
        return eb.not(eb.exists(baseQuery()))
      }

      if (value === null || typeof value !== 'object') {
        return eb.and([])
      }

      const filter = value as { is?: UserWhereInput | null; isNot?: UserWhereInput | null }
      const conditions: Expression<SqlBool>[] = []

      if ('is' in filter) {
        if (filter.is === null) {
          conditions.push(eb.not(eb.exists(baseQuery())))
        } else if (filter.is) {
          conditions.push(
            eb.exists(
              baseQuery().where((relEb) => buildWhereExpression_User(kysely, relEb, filter.is as UserWhereInput)),
            ),
          )
        }
      }

      if ('isNot' in filter) {
        if (filter.isNot === null) {
          conditions.push(eb.exists(baseQuery()))
        } else if (filter.isNot) {
          const existsAny = eb.exists(baseQuery())
          const existsMatch = eb.exists(
            baseQuery().where((relEb) => buildWhereExpression_User(kysely, relEb, filter.isNot as UserWhereInput)),
          )
          conditions.push(eb.and([existsAny, eb.not(existsMatch)]))
        }
      }

      return eb.and(conditions)
    }
    default:
      return eb.and([])
  }
}

function buildWhereExpression_Post(
  kysely: Kysely<DatabaseSchema>,
  eb: ExpressionBuilder<DatabaseSchema, 'Post'>,
  where: PostWhereInput,
) {
  const expressions: Expression<SqlBool>[] = []

  for (const [field, value] of Object.entries(where)) {
    if (field === 'AND') {
      expressions.push(eb.and((value as PostWhereInput[]).map((cond) => buildWhereExpression_Post(kysely, eb, cond))))
    } else if (field === 'OR') {
      expressions.push(eb.or((value as PostWhereInput[]).map((cond) => buildWhereExpression_Post(kysely, eb, cond))))
    } else if (field === 'NOT') {
      // `eb.not` doesn't accept a list, so need to negate each condition instead.
      for (const cond of value as PostWhereInput[]) {
        expressions.push(eb.not(buildWhereExpression_Post(kysely, eb, cond)))
      }
    } else {
      switch (field) {
        case 'author':
          expressions.push(buildRelationExpression_Post(kysely, eb, field, value))
          break
        default:
          expressions.push(buildFieldExpression_Post(eb, field, value))
      }
    }
  }

  return eb.and(expressions)
}

/**
 * Generated operations for User model
 */
class UserOperations {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  private _posts(id: Expression<number>) {
    return jsonArrayFrom(
      this.kysely.selectFrom('Post').selectAll().whereRef('Post.authorId', '=', id).orderBy('Post.id'),
    )
  }

  private _profile(id: Expression<number>) {
    return jsonObjectFrom(this.kysely.selectFrom('Profile').selectAll().whereRef('Profile.userId', '=', id))
  }

  findMany(args?: Omit<UserFindManyArgs, 'include'>): Promise<UserScalars[]>
  findMany<T extends UserFindManyArgs>(args: T): Promise<UserGetPayload<T>[]>
  async findMany<T extends UserFindManyArgs = {}>(args?: T): Promise<UserScalars[] | UserGetPayload<T>[]> {
    let query = this.kysely
      .selectFrom('User')
      .selectAll()
      .$if(!!args?.include?.posts, (qb) => qb.select((eb) => this._posts(eb.ref('User.id')).as('posts')))
      .$if(!!args?.include?.profile, (qb) => qb.select((eb) => this._profile(eb.ref('User.id')).as('profile')))

    query = query.where((eb) => buildWhereExpression_User(this.kysely, eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    const include = args?.include
    if (!include) {
      return results.map((row) => this.transformSelectResult(row))
    }

    return results.map((row) => this.applyIncludes(row, include))
  }

  findUnique(args: Omit<UserFindUniqueArgs, 'include'>): Promise<UserScalars | null>
  findUnique<T extends UserFindUniqueArgs>(args: T): Promise<UserGetPayload<T> | null>
  async findUnique<T extends UserFindUniqueArgs>(args: T): Promise<UserScalars | UserGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('User')
      .selectAll()
      .$if(!!args?.include?.posts, (qb) => qb.select((eb) => this._posts(eb.ref('User.id')).as('posts')))
      .$if(!!args?.include?.profile, (qb) => qb.select((eb) => this._profile(eb.ref('User.id')).as('profile')))

    query = query.where((eb) => buildWhereExpression_User(this.kysely, eb, args.where))
    const results = await query.execute()

    if (results.length === 0) return null

    const include = args?.include
    if (!include) {
      return this.transformSelectResult(results[0])
    }

    return this.applyIncludes(results[0], include)
  }

  findFirst(args?: Omit<UserFindFirstArgs, 'include'>): Promise<UserScalars | null>
  findFirst<T extends UserFindFirstArgs>(args: T): Promise<UserGetPayload<T> | null>
  async findFirst<T extends UserFindFirstArgs = {}>(args?: T): Promise<UserScalars | UserGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('User')
      .selectAll()
      .$if(!!args?.include?.posts, (qb) => qb.select((eb) => this._posts(eb.ref('User.id')).as('posts')))
      .$if(!!args?.include?.profile, (qb) => qb.select((eb) => this._profile(eb.ref('User.id')).as('profile')))

    query = query.where((eb) => buildWhereExpression_User(this.kysely, eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    const include = args?.include
    if (!include) {
      return this.transformSelectResult(results[0])
    }

    return this.applyIncludes(results[0], include)
  }

  async create(args: UserCreateArgs): Promise<User> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('User')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: UserCreateManyArgs): Promise<{ count: number }> {
    const dataArray = args.data.map((item) => this.prepareCreateData(item))
    await this.kysely
      .insertInto('User')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: UserUpdateArgs): Promise<User> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('User').set(prepared as any)
    query = query.where((eb) => buildWhereExpression_User(this.kysely, eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: UserUpdateManyArgs): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('User').set(prepared as any)

    query = query.where((eb) => buildWhereExpression_User(this.kysely, eb, args?.where ?? {}))

    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: UserUpsertArgs): Promise<User> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)

    const result = await this.kysely
      .insertInto('User')
      .values(createData as any)
      .onConflict((oc) => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: UserDeleteArgs): Promise<User> {
    let query = this.kysely.deleteFrom('User')
    query = query.where((eb) => buildWhereExpression_User(this.kysely, eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: UserDeleteManyArgs): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('User')

    query = query.where((eb) => buildWhereExpression_User(this.kysely, eb, args?.where ?? {}))

    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: UserCountArgs): Promise<number> {
    let query = this.kysely.selectFrom('User').select((eb) => eb.fn.count('id').as('count'))

    query = query.where((eb) => buildWhereExpression_User(this.kysely, eb, args?.where ?? {}))

    const result = (await query.executeTakeFirst()) as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private prepareCreateData(data: UserCreateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}

    if (data.email !== undefined) {
      prepared.email = String(data.email)
    }

    if (data.name !== undefined) {
      prepared.name = data.name !== null ? String(data.name) : null
    }

    prepared.createdAt = data.createdAt ? new Date(data.createdAt) : new Date().toISOString()
    prepared.updatedAt = new Date().toISOString()

    return prepared
  }

  private prepareUpdateData(data: UserUpdateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}

    if (data.email !== undefined) {
      prepared.email = String(data.email)
    }

    if (data.name !== undefined) {
      prepared.name = data.name !== null ? String(data.name) : null
    }

    prepared.updatedAt = new Date().toISOString()

    return prepared
  }

  private transformSelectResult(row: UserRow): UserScalars {
    const result: Partial<UserScalars> = {}

    result.id = row.id

    result.email = row.email

    result.name = row.name

    result.createdAt = row.createdAt

    result.updatedAt = row.updatedAt

    return result as UserScalars
  }

  private applyIncludes<TInclude extends UserInclude>(
    row: UserRowWithIncludes,
    include: TInclude,
  ): UserGetPayload<{ include: TInclude }> {
    const result: UserScalars & Partial<UserRelations> = this.transformSelectResult(row)

    if (include?.posts) {
      result.posts = row.posts ?? []
    }
    if (include?.profile) {
      result.profile = row.profile ?? null
    }

    return result as UserGetPayload<{ include: TInclude }>
  }

  private async fetchManyRelations(
    results: any[],
    relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>,
  ): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter((r) => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // Fetch posts relation
    const postsRelation = manyRelations.find((r) => r.field === 'posts')
    if (postsRelation) {
      const parentIds = results.map((r) => r.id)
      const postsResults = await this.kysely.selectFrom('Post').selectAll().where('authorId', 'in', parentIds).execute()

      relatedData['posts'] = postsResults.map((row: any) => ({
        id: Number(row.id),
        title: String(row.title),
        content: String(row.content),
        published: row.published,
        authorId: Number(row.authorId),
        createdAt: new Date(row.createdAt as string | number | Date),
        updatedAt: new Date(row.updatedAt as string | number | Date),
      }))
    }

    return relatedData
  }

  private transformSelectResultWithIncludes(
    row: any,
    relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>,
    relatedData: Record<string, any[]>,
  ): User {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    const postsRelation = relations.find((r) => r.field === 'posts' && r.type === 'many')
    if (postsRelation && relatedData['posts']) {
      result.posts = relatedData['posts'].filter((r: any) => r['authorId'] === result.id) || []
    }

    const profileRelation = relations.find((r) => r.field === 'profile' && r.type === 'one')
    if (profileRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${profileRelation.prefix}id`] !== null
      result.profile = hasData
        ? {
            id: Number(row.profile_id),
            bio: String(row.profile_bio),
            userId: Number(row.profile_userId),
          }
        : null
    }

    return result
  }
}

/**
 * Generated operations for Profile model
 */
class ProfileOperations {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  private _user(userId: Expression<number>) {
    return jsonObjectFrom(this.kysely.selectFrom('User').selectAll().whereRef('User.id', '=', userId))
  }

  findMany(args?: Omit<ProfileFindManyArgs, 'include'>): Promise<ProfileScalars[]>
  findMany<T extends ProfileFindManyArgs>(args: T): Promise<ProfileGetPayload<T>[]>
  async findMany<T extends ProfileFindManyArgs = {}>(args?: T): Promise<ProfileScalars[] | ProfileGetPayload<T>[]> {
    let query = this.kysely
      .selectFrom('Profile')
      .selectAll()
      .$if(!!args?.include?.user, (qb) => qb.select((eb) => this._user(eb.ref('Profile.userId')).as('user')))

    query = query.where((eb) => buildWhereExpression_Profile(this.kysely, eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    const include = args?.include
    if (!include) {
      return results.map((row) => this.transformSelectResult(row))
    }

    return results.map((row) => this.applyIncludes(row, include))
  }

  findUnique(args: Omit<ProfileFindUniqueArgs, 'include'>): Promise<ProfileScalars | null>
  findUnique<T extends ProfileFindUniqueArgs>(args: T): Promise<ProfileGetPayload<T> | null>
  async findUnique<T extends ProfileFindUniqueArgs>(args: T): Promise<ProfileScalars | ProfileGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('Profile')
      .selectAll()
      .$if(!!args?.include?.user, (qb) => qb.select((eb) => this._user(eb.ref('Profile.userId')).as('user')))

    query = query.where((eb) => buildWhereExpression_Profile(this.kysely, eb, args.where))
    const results = await query.execute()

    if (results.length === 0) return null

    const include = args?.include
    if (!include) {
      return this.transformSelectResult(results[0])
    }

    return this.applyIncludes(results[0], include)
  }

  findFirst(args?: Omit<ProfileFindFirstArgs, 'include'>): Promise<ProfileScalars | null>
  findFirst<T extends ProfileFindFirstArgs>(args: T): Promise<ProfileGetPayload<T> | null>
  async findFirst<T extends ProfileFindFirstArgs = {}>(
    args?: T,
  ): Promise<ProfileScalars | ProfileGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('Profile')
      .selectAll()
      .$if(!!args?.include?.user, (qb) => qb.select((eb) => this._user(eb.ref('Profile.userId')).as('user')))

    query = query.where((eb) => buildWhereExpression_Profile(this.kysely, eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    const include = args?.include
    if (!include) {
      return this.transformSelectResult(results[0])
    }

    return this.applyIncludes(results[0], include)
  }

  async create(args: ProfileCreateArgs): Promise<Profile> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('Profile')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: ProfileCreateManyArgs): Promise<{ count: number }> {
    const dataArray = args.data.map((item) => this.prepareCreateData(item))
    await this.kysely
      .insertInto('Profile')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: ProfileUpdateArgs): Promise<Profile> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Profile').set(prepared as any)
    query = query.where((eb) => buildWhereExpression_Profile(this.kysely, eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: ProfileUpdateManyArgs): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Profile').set(prepared as any)

    query = query.where((eb) => buildWhereExpression_Profile(this.kysely, eb, args?.where ?? {}))

    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: ProfileUpsertArgs): Promise<Profile> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)

    const result = await this.kysely
      .insertInto('Profile')
      .values(createData as any)
      .onConflict((oc) => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: ProfileDeleteArgs): Promise<Profile> {
    let query = this.kysely.deleteFrom('Profile')
    query = query.where((eb) => buildWhereExpression_Profile(this.kysely, eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: ProfileDeleteManyArgs): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('Profile')

    query = query.where((eb) => buildWhereExpression_Profile(this.kysely, eb, args?.where ?? {}))

    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: ProfileCountArgs): Promise<number> {
    let query = this.kysely.selectFrom('Profile').select((eb) => eb.fn.count('id').as('count'))

    query = query.where((eb) => buildWhereExpression_Profile(this.kysely, eb, args?.where ?? {}))

    const result = (await query.executeTakeFirst()) as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private prepareCreateData(data: ProfileCreateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}

    if (data.bio !== undefined) {
      prepared.bio = data.bio !== null ? String(data.bio) : null
    }

    if (data.userId !== undefined) {
      prepared.userId = Number(data.userId)
    }

    return prepared
  }

  private prepareUpdateData(data: ProfileUpdateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}

    if (data.bio !== undefined) {
      prepared.bio = data.bio !== null ? String(data.bio) : null
    }

    if (data.userId !== undefined) {
      prepared.userId = Number(data.userId)
    }

    return prepared
  }

  private transformSelectResult(row: ProfileRow): ProfileScalars {
    const result: Partial<ProfileScalars> = {}

    result.id = row.id

    result.bio = row.bio

    result.userId = row.userId

    return result as ProfileScalars
  }

  private applyIncludes<TInclude extends ProfileInclude>(
    row: ProfileRowWithIncludes,
    include: TInclude,
  ): ProfileGetPayload<{ include: TInclude }> {
    const result: ProfileScalars & Partial<ProfileRelations> = this.transformSelectResult(row)

    if (include?.user) {
      result.user = row.user ?? null
    }

    return result as ProfileGetPayload<{ include: TInclude }>
  }

  private async fetchManyRelations(
    results: any[],
    relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>,
  ): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter((r) => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // No one-to-many relations

    return relatedData
  }

  private transformSelectResultWithIncludes(
    row: any,
    relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>,
    relatedData: Record<string, any[]>,
  ): Profile {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    const userRelation = relations.find((r) => r.field === 'user' && r.type === 'one')
    if (userRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${userRelation.prefix}id`] !== null
      result.user = hasData
        ? {
            id: Number(row.user_id),
            email: String(row.user_email),
            name: String(row.user_name),
            createdAt: new Date(row.user_createdAt as string | number | Date),
            updatedAt: new Date(row.user_updatedAt as string | number | Date),
          }
        : null
    }

    return result
  }
}

/**
 * Generated operations for Post model
 */
class PostOperations {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  private _author(authorId: Expression<number>) {
    return jsonObjectFrom(this.kysely.selectFrom('User').selectAll().whereRef('User.id', '=', authorId))
  }

  findMany(args?: Omit<PostFindManyArgs, 'include'>): Promise<PostScalars[]>
  findMany<T extends PostFindManyArgs>(args: T): Promise<PostGetPayload<T>[]>
  async findMany<T extends PostFindManyArgs = {}>(args?: T): Promise<PostScalars[] | PostGetPayload<T>[]> {
    let query = this.kysely
      .selectFrom('Post')
      .selectAll()
      .$if(!!args?.include?.author, (qb) => qb.select((eb) => this._author(eb.ref('Post.authorId')).as('author')))

    query = query.where((eb) => buildWhereExpression_Post(this.kysely, eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    const include = args?.include
    if (!include) {
      return results.map((row) => this.transformSelectResult(row))
    }

    return results.map((row) => this.applyIncludes(row, include))
  }

  findUnique(args: Omit<PostFindUniqueArgs, 'include'>): Promise<PostScalars | null>
  findUnique<T extends PostFindUniqueArgs>(args: T): Promise<PostGetPayload<T> | null>
  async findUnique<T extends PostFindUniqueArgs>(args: T): Promise<PostScalars | PostGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('Post')
      .selectAll()
      .$if(!!args?.include?.author, (qb) => qb.select((eb) => this._author(eb.ref('Post.authorId')).as('author')))

    query = query.where((eb) => buildWhereExpression_Post(this.kysely, eb, args.where))
    const results = await query.execute()

    if (results.length === 0) return null

    const include = args?.include
    if (!include) {
      return this.transformSelectResult(results[0])
    }

    return this.applyIncludes(results[0], include)
  }

  findFirst(args?: Omit<PostFindFirstArgs, 'include'>): Promise<PostScalars | null>
  findFirst<T extends PostFindFirstArgs>(args: T): Promise<PostGetPayload<T> | null>
  async findFirst<T extends PostFindFirstArgs = {}>(args?: T): Promise<PostScalars | PostGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('Post')
      .selectAll()
      .$if(!!args?.include?.author, (qb) => qb.select((eb) => this._author(eb.ref('Post.authorId')).as('author')))

    query = query.where((eb) => buildWhereExpression_Post(this.kysely, eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    const include = args?.include
    if (!include) {
      return this.transformSelectResult(results[0])
    }

    return this.applyIncludes(results[0], include)
  }

  async create(args: PostCreateArgs): Promise<Post> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('Post')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: PostCreateManyArgs): Promise<{ count: number }> {
    const dataArray = args.data.map((item) => this.prepareCreateData(item))
    await this.kysely
      .insertInto('Post')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: PostUpdateArgs): Promise<Post> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Post').set(prepared as any)
    query = query.where((eb) => buildWhereExpression_Post(this.kysely, eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: PostUpdateManyArgs): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Post').set(prepared as any)

    query = query.where((eb) => buildWhereExpression_Post(this.kysely, eb, args?.where ?? {}))

    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: PostUpsertArgs): Promise<Post> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)

    const result = await this.kysely
      .insertInto('Post')
      .values(createData as any)
      .onConflict((oc) => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: PostDeleteArgs): Promise<Post> {
    let query = this.kysely.deleteFrom('Post')
    query = query.where((eb) => buildWhereExpression_Post(this.kysely, eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: PostDeleteManyArgs): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('Post')

    query = query.where((eb) => buildWhereExpression_Post(this.kysely, eb, args?.where ?? {}))

    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: PostCountArgs): Promise<number> {
    let query = this.kysely.selectFrom('Post').select((eb) => eb.fn.count('id').as('count'))

    query = query.where((eb) => buildWhereExpression_Post(this.kysely, eb, args?.where ?? {}))

    const result = (await query.executeTakeFirst()) as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private prepareCreateData(data: PostCreateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}

    if (data.title !== undefined) {
      prepared.title = String(data.title)
    }

    if (data.content !== undefined) {
      prepared.content = data.content !== null ? String(data.content) : null
    }

    if (data.published !== undefined) {
      prepared.published = data.published
    }

    if (data.authorId !== undefined) {
      prepared.authorId = Number(data.authorId)
    }

    prepared.createdAt = data.createdAt ? new Date(data.createdAt) : new Date().toISOString()
    prepared.updatedAt = new Date().toISOString()

    return prepared
  }

  private prepareUpdateData(data: PostUpdateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}

    if (data.title !== undefined) {
      prepared.title = String(data.title)
    }

    if (data.content !== undefined) {
      prepared.content = data.content !== null ? String(data.content) : null
    }

    if (data.published !== undefined) {
      prepared.published = data.published
    }

    if (data.authorId !== undefined) {
      prepared.authorId = Number(data.authorId)
    }

    prepared.updatedAt = new Date().toISOString()

    return prepared
  }

  private transformSelectResult(row: PostRow): PostScalars {
    const result: Partial<PostScalars> = {}

    result.id = row.id

    result.title = row.title

    result.content = row.content

    result.published = row.published

    result.authorId = row.authorId

    result.createdAt = row.createdAt

    result.updatedAt = row.updatedAt

    return result as PostScalars
  }

  private applyIncludes<TInclude extends PostInclude>(
    row: PostRowWithIncludes,
    include: TInclude,
  ): PostGetPayload<{ include: TInclude }> {
    const result: PostScalars & Partial<PostRelations> = this.transformSelectResult(row)

    if (include?.author) {
      result.author = row.author ?? null
    }

    return result as PostGetPayload<{ include: TInclude }>
  }

  private async fetchManyRelations(
    results: any[],
    relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>,
  ): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter((r) => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // No one-to-many relations

    return relatedData
  }

  private transformSelectResultWithIncludes(
    row: any,
    relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>,
    relatedData: Record<string, any[]>,
  ): Post {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    const authorRelation = relations.find((r) => r.field === 'author' && r.type === 'one')
    if (authorRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${authorRelation.prefix}id`] !== null
      result.author = hasData
        ? {
            id: Number(row.author_id),
            email: String(row.author_email),
            name: String(row.author_name),
            createdAt: new Date(row.author_createdAt as string | number | Date),
            updatedAt: new Date(row.author_updatedAt as string | number | Date),
          }
        : null
    }

    return result
  }
}

const createModelOperations = (kysely: Kysely<DatabaseSchema>) => ({
  user: new UserOperations(kysely),
  profile: new ProfileOperations(kysely),
  post: new PostOperations(kysely),
})

/**
 * Refract Client with pre-compiled operations
 * Database dialect: postgresql
 * No runtime schema parsing - all model operations are embedded at generation time
 */
export class RefractClient extends RefractClientBase<DatabaseSchema> {
  declare readonly user: UserOperations
  declare readonly profile: ProfileOperations
  declare readonly post: PostOperations
  constructor(dialect: Dialect) {
    super(dialect, { modelFactory: createModelOperations })
  }
}

/**
 * Factory function for creating RefractClient instances
 */
export function createRefractClient(dialect: Dialect): RefractClient {
  return new RefractClient(dialect)
}

/**
 * Convenience factory function that automatically loads configuration
 * This is the main entry point used by the generated client
 */
export async function createClient(): Promise<RefractClient> {
  const { config } = await loadRefractConfig()
  const dialect = await createKyselyDialect(config)
  return new RefractClient(dialect)
}
