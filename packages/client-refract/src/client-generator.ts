/**
 * Refract client code generator with FieldTranslator integration.
 *
 * Emits client modules ahead of time with database-specific field transformations
 * using the @refract/field-translator system for zero runtime overhead.
 */

import {
  createFieldTranslator,
  detectDialect,
  type DatabaseDialect,
  type RefractConfig,
} from '@refract/field-translator'
import type { FieldAST, ModelAST, SchemaAST } from '@refract/schema-parser'

import { PRISMA_TO_TS_TYPES } from './types'
import dedent from 'dedent'

export interface ClientGeneratorOptions {
  /** Database dialect for transformations */
  dialect?: DatabaseDialect
  /** Configuration for dialect detection */
  config?: RefractConfig
  /** Include TypeScript type definitions in output */
  includeTypes?: boolean
  /** Include JSDoc comments for better IDE experience */
  includeJSDoc?: boolean
  /** Target ES module syntax (default: true) */
  esModules?: boolean
}

export class ClientGenerator {
  private dialect: DatabaseDialect
  private fieldTranslator: ReturnType<typeof createFieldTranslator>

  constructor(private schemaAST: SchemaAST, private options: ClientGeneratorOptions = {}) {
    // Detect or use provided dialect
    this.dialect = this.detectDialect()
    this.fieldTranslator = createFieldTranslator(this.dialect)
  }

  private detectDialect(): DatabaseDialect {
    if (this.options.dialect) {
      return this.options.dialect
    }

    if (this.options.config) {
      return detectDialect(this.options.config)
    }

    // Default to SQLite for compatibility
    return 'sqlite'
  }


  /**
   * Generate complete client module with generated model operations.
   */
  generateClientModule(): string {
    const { includeTypes = true, esModules = true } = this.options

    const imports = this.generateImports(esModules)
    const typeDefinitions = includeTypes ? this.generateTypeDefinitions() : ''
    const modelOperations = this.generateModelOperationsBlock()
    const clientClass = this.generateClientClass()
    const factoryFunction = this.generateClientFactory()

    return [this.generateFileHeader(), imports, typeDefinitions, modelOperations, clientClass, factoryFunction]
      .filter(Boolean)
      .join('\n\n')
  }

  private generateFileHeader(): string {
    return dedent`
      /**
       * Generated Refract Client
       * 
       * Do not edit this file manually. Regenerate with \`refract generate\`
       * 
       * Generated at: ${new Date().toISOString()}
       */
    `
  }

  private generateImports(esModules: boolean): string {
    const importStyle = esModules ? 'import' : 'const'
    const fromStyle = esModules ? 'from' : '= require'

    // Dialect-specific JSON helper imports
    const jsonHelperImport = this.generateJsonHelperImport(importStyle, fromStyle)

    return dedent`
      ${importStyle} { RefractClientBase } ${fromStyle} '@refract/client'
      ${importStyle} { createKyselyDialect, loadRefractConfig } ${fromStyle} '@refract/config'
      ${importStyle} { Kysely } ${fromStyle} 'kysely'
      ${importStyle} type { Dialect, ExpressionBuilder, SelectQueryBuilder, UpdateQueryBuilder, DeleteQueryBuilder, Expression, SqlBool, ReferenceExpression, Selectable } ${fromStyle} 'kysely'

      ${jsonHelperImport}
    `
  }

  private generateJsonHelperImport(importStyle: string, fromStyle: string): string {
    // JSON aggregation helpers are dialect-specific in Kysely
    switch (this.dialect) {
      case 'postgresql':
        return `${importStyle} { jsonArrayFrom, jsonObjectFrom } ${fromStyle} 'kysely/helpers/postgres'`
      case 'mysql':
        return `${importStyle} { jsonArrayFrom, jsonObjectFrom } ${fromStyle} 'kysely/helpers/mysql'`
      case 'sqlite':
        return `${importStyle} { jsonArrayFrom, jsonObjectFrom } ${fromStyle} 'kysely/helpers/sqlite'`
      default:
        return `${importStyle} { jsonArrayFrom, jsonObjectFrom } ${fromStyle} 'kysely/helpers/postgres'`
    }
  }

  private generateTypeDefinitions(): string {
    const prettifyHelper = this.generatePrettifyHelper()
    const modelTypes = this.generateModelTypes()
    const databaseSchema = this.generateDatabaseSchemaInterface()
    const baseFilterTypes = this.generateBaseFilterTypes()
    const modelInputTypes = this.generateModelInputTypes()

    return dedent.withOptions({ alignValues: true })`
      ${prettifyHelper}

      ${modelTypes}
      ${databaseSchema}

      ${baseFilterTypes}

      ${modelInputTypes}

      ${this.generateCRUDInterfaces()}
    `
  }

  /**
   * Generate the Prettify<T> type helper
   * This forces TypeScript to flatten intersection types in IDE hover tooltips
   */
  private generatePrettifyHelper(): string {
    return dedent`
      /**
       * Prettify<T> - Flattens intersection types for cleaner IDE tooltips
       * @see https://www.totaltypescript.com/concepts/the-prettify-helper
       */
      export type Prettify<T> = { [K in keyof T]: T[K] } & {}
    `
  }

  /**
   * Generate all model-related types:
   * - {Model}Scalars: scalar fields only
   * - {Model}Relations: relation field payloads
   * - {Model}GetPayload<T>: conditional utility type for precise return types
   * - {Model}: full interface with optional relations (backwards compat)
   */
  private generateModelTypes(): string {
    const types: string[] = []

    for (const model of this.schemaAST.models) {
      const modelName = model.name
      const relations = this.getModelRelations(model)
      const hasRelations = relations.length > 0
      const modelNames = new Set(this.schemaAST.models.map((m) => m.name))

      // Generate scalar fields (non-relation fields)
      const scalarFields = model.fields
        .filter((field) => !modelNames.has(field.fieldType))
        .map((field) => {
          const optionalMarker = field.isOptional ? '?' : ''
          const tsType = this.mapFieldType(field)
          return `${field.name}${optionalMarker}: ${tsType}`
        })
        .join('\n')

      // 1. {Model}Scalars - scalar fields only
      types.push(dedent.withOptions({ alignValues: true })`
        /**
         * ${modelName} scalar fields (no relations)
         */
        export type ${modelName}Scalars = {
          ${scalarFields}
        }
      `)

      // 2. {Model}Relations - relation payload types
      if (hasRelations) {
        const relationFields = relations
          .map((rel) => {
            if (rel.isArray) {
              // One-to-many: always returns an array
              return `${rel.fieldName}: ${rel.relatedModel}[]`
            } else {
              // One-to-one: could be null if optional or not found
              return `${rel.fieldName}: ${rel.relatedModel} | null`
            }
          })
          .join('\n')

        types.push(dedent.withOptions({ alignValues: true })`
          /**
           * ${modelName} relation payloads when included
           */
          export type ${modelName}Relations = {
            ${relationFields}
          }
        `)

        // 3. {Model}GetPayload<T> - conditional utility type
        types.push(dedent.withOptions({ alignValues: true })`
          /**
           * Get the return type for ${modelName} based on include options
           * @example
           * type WithPosts = ${modelName}GetPayload<{ include: { posts: true } }>
           */
          export type ${modelName}GetPayload<T extends { include?: ${modelName}Include } | undefined | null = undefined> = Prettify<
            ${modelName}Scalars & (
              T extends { include: infer I extends ${modelName}Include }
                ? { [K in keyof I as I[K] extends true ? K : never]: K extends keyof ${modelName}Relations ? ${modelName}Relations[K] : never }
                : {}
            )
          >
        `)
      } else {
        // No relations - GetPayload just returns Scalars
        types.push(dedent.withOptions({ alignValues: true })`
          /**
           * Get the return type for ${modelName} (no relations available)
           */
          export type ${modelName}GetPayload<T extends { include?: Record<string, never> } | undefined | null = undefined> = ${modelName}Scalars
        `)
      }

      // 4. {Model} - full interface with optional relations (backwards compat)
      const relationFields = hasRelations
        ? relations.map((rel) => {
            const listMarker = rel.isArray ? '[]' : ''
            return `${rel.fieldName}?: ${rel.relatedModel}${listMarker}`
          }).join('\n')
        : '// No relations'

      types.push(dedent.withOptions({ alignValues: true })`
        /**
         * Full ${modelName} type with optional relations
         * For precise typing based on include, use ${modelName}GetPayload<T>
         */
        export interface ${modelName} extends ${modelName}Scalars {
          ${relationFields}
        }
      `)

      const rowWithIncludesType = hasRelations
        ? `${modelName}Row & Partial<${modelName}Relations>`
        : `${modelName}Row`

      types.push(dedent.withOptions({ alignValues: true })`
        export type ${modelName}Row = Selectable<DatabaseSchema['${modelName}']>
        export type ${modelName}RowWithIncludes = ${rowWithIncludesType}
      `)
    }

    return types.join('\n\n')
  }

  generateModelInterfaces(): string {
    const interfaces = this.schemaAST.models.map((model) => {
      const fields = this.generateModelFields(model).map((field) => {
        const optionalMarker = field.isOptional ? '?' : ''
        const listMarker = field.isList ? '[]' : ''
        return `${field.name}${optionalMarker}: ${field.type}${listMarker}`
      })

      return dedent.withOptions({ alignValues: true })`
        export interface ${model.name} {
          ${fields.join('\n')}
        }
      `
    })

    return `${interfaces.join('\n\n')}\n`
  }

  /**
   * Generate fields for a model
   */
  generateModelFields(model: ModelAST) {
    return model.fields.map((field) => {
      const isPrimaryKey = this.isPrimaryKey(field)
      const isUnique = field.attributes.some((attr) => attr.name === 'unique') || isPrimaryKey
      const hasDefault =
        field.attributes.some((attr) => attr.name === 'default') ||
        field.attributes.some((attr) => attr.name === 'updatedAt')

      return {
        name: field.name,
        type: this.mapFieldType(field),
        isOptional: field.isOptional,
        isList: field.isList,
        isPrimaryKey,
        isUnique,
        hasDefault,
      }
    })
  }

  private isPrimaryKey(field: FieldAST): boolean {
    return field.attributes.some((attr) => attr.name === 'id')
  }

  private isUniqueField(field: FieldAST): boolean {
    return field.attributes.some((attr) => attr.name === 'unique' || attr.name === 'id')
  }

  private isAutoTimestamp(field: FieldAST): boolean {
    return field.attributes.some((attr) => {
      return attr.name === 'updatedAt' || (field.fieldType === 'DateTime' && attr.name === 'default')
    })
  }

  /**
   * Map Prisma field type to TypeScript type
   */
  private mapFieldType(field: FieldAST): string {
    const baseType = field.fieldType

    // Handle built-in scalar types
    if (PRISMA_TO_TS_TYPES[baseType]) {
      return PRISMA_TO_TS_TYPES[baseType]
    }

    // Handle relation fields (references to other models)
    const relatedModel = this.schemaAST.models.find((m) => m.name === baseType)
    if (relatedModel) {
      return baseType // Use the model name as the type
    }

    // Handle enum types
    const enumType = this.schemaAST.enums.find((e) => e.name === baseType)
    if (enumType) {
      return baseType // Use the enum name as the type
    }

    // Fallback to string for unknown types
    return 'string'
  }

  private generateDatabaseSchemaInterface(): string {
    const tableTypes = this.schemaAST.models
      .map((model) => {
        const tableName = this.getTableName(model)
        return `${tableName}: ${model.name}`
      })
      .join('\n')

    return dedent.withOptions({ alignValues: true })`
      export interface DatabaseSchema {
        ${tableTypes}
        [modelName: string]: Record<string, any>
      }
    `
  }

  /**
   * Generate generic base filter types that work for all models
   */
  private generateBaseFilterTypes(): string {
    return dedent`
      /**
       * Base filter type for all field types
       */
      export type BaseFilter<T> = {
        equals?: T
        in?: T[]
        notIn?: T[]
        not?: BaseFilter<T> | T
      }

      /**
       * Filter for numeric fields (Int, Float, BigInt)
       */
      export type NumericFilter<T extends number | bigint = number> = BaseFilter<T> & {
        lt?: T
        lte?: T
        gt?: T
        gte?: T
      }

      /**
       * Filter for string fields
       * Generic parameter allows string | null for nullable fields
       */
      export type StringFilter<T extends string | null = string> = BaseFilter<T> & {
        contains?: string
        startsWith?: string
        endsWith?: string
        // mode?: 'default' | 'insensitive' // Deferred: case-insensitive search
      }

      /**
       * Filter for boolean fields
       */
      export type BooleanFilter = BaseFilter<boolean>

      /**
       * Filter for DateTime fields
       * Accepts Date objects or ISO string representations
       */
      export type DateTimeFilter<T extends Date | string | null = Date | string> = BaseFilter<T> & {
        lt?: Date | string
        lte?: Date | string
        gt?: Date | string
        gte?: Date | string
      }

      /**
       * Filter for Json fields
       */
      export type JsonFilter = BaseFilter<any>

      /**
       * Sort order for orderBy clauses
       */
      export type SortOrder = 'asc' | 'desc'
    `
  }

  /**
   * Generate all model-specific input types (WhereInput, OrderByInput, Args types)
   */
  private generateModelInputTypes(): string {
    const types: string[] = []

    // First, generate all relation filter types globally to avoid duplicates
    const allRelationFilters = this.generateAllRelationFilterTypes()
    if (allRelationFilters) {
      types.push(allRelationFilters)
    }

    for (const model of this.schemaAST.models) {
      // Generate WhereInput for this model
      types.push(this.generateWhereInput(model))

      // Generate WhereUniqueInput for this model
      types.push(this.generateWhereUniqueInput(model))

      // Generate OrderByInput for this model
      types.push(this.generateOrderByInput(model))

      // Generate CreateInput for this model
      types.push(this.generateCreateInput(model))

      // Generate UpdateInput for this model
      types.push(this.generateUpdateInput(model))

      // Generate Args types for all operations
      types.push(this.generateArgsTypes(model))
    }

    return types.filter(Boolean).join('\n\n')
  }

  /**
   * Generate all relation filter types once to avoid duplicates
   */
  private generateAllRelationFilterTypes(): string {
    const generatedTypes = new Set<string>()
    const types: string[] = []

    for (const model of this.schemaAST.models) {
      const relations = this.getModelRelations(model)

      for (const rel of relations) {
        // Generate list filter for the related model
        const listFilterName = `${rel.relatedModel}ListRelationFilter`
        if (!generatedTypes.has(listFilterName)) {
          generatedTypes.add(listFilterName)
          types.push(dedent`
            /**
             * Filter for one-to-many relation to ${rel.relatedModel}
             * Note: Runtime implementation deferred to Phase 2+
             */
            export type ${listFilterName} = {
              every?: ${rel.relatedModel}WhereInput
              some?: ${rel.relatedModel}WhereInput
              none?: ${rel.relatedModel}WhereInput
            }
          `)
        }

        // Generate singular filter for the related model
        const singularFilterName = `${rel.relatedModel}RelationFilter`
        if (!generatedTypes.has(singularFilterName)) {
          generatedTypes.add(singularFilterName)
          types.push(dedent`
            /**
             * Filter for one-to-one relation to ${rel.relatedModel}
             * Note: Runtime implementation deferred to Phase 2+
             */
            export type ${singularFilterName} = {
              is?: ${rel.relatedModel}WhereInput | null
              isNot?: ${rel.relatedModel}WhereInput | null
            }
          `)
        }
      }
    }

    return types.join('\n\n')
  }

  /**
   * Generate WhereInput type for a model
   */
  private generateWhereInput(model: ModelAST): string {
    const fields: string[] = []
    const modelNames = new Set(this.schemaAST.models.map((m) => m.name))

    // Add scalar field filters
    for (const field of model.fields) {
      // Skip relation fields (they're added separately)
      if (modelNames.has(field.fieldType)) {
        continue
      }

      const filterType = this.getFilterTypeForField(field)
      const shorthandType = this.getShorthandTypeForField(field)

      fields.push(`${field.name}?: ${filterType} | ${shorthandType}`)
    }

    // Add relation field filters
    const relations = this.getModelRelations(model)
    for (const rel of relations) {
      if (rel.isArray) {
        fields.push(`${rel.fieldName}?: ${rel.relatedModel}ListRelationFilter`)
      } else {
        fields.push(`${rel.fieldName}?: ${rel.relatedModel}RelationFilter | null`)
      }
    }

    // Add logical operators
    fields.push(`AND?: ${model.name}WhereInput[]`)
    fields.push(`OR?: ${model.name}WhereInput[]`)
    fields.push(`NOT?: ${model.name}WhereInput[]`)

    return dedent.withOptions({ alignValues: true })`
      export type ${model.name}WhereInput = {
        ${fields.join('\n')}
      }
    `
  }

  /**
   * Generate WhereUniqueInput type for a model
   * Only includes fields marked with @id or @unique
   */
  private generateWhereUniqueInput(model: ModelAST): string {
    const fields: string[] = []
    const modelNames = new Set(this.schemaAST.models.map((m) => m.name))

    for (const field of model.fields) {
      if (modelNames.has(field.fieldType)) {
        continue
      }

      if (!this.isUniqueField(field)) {
        continue
      }

      const shorthandType = this.getShorthandTypeForField(field)
      fields.push(`${field.name}?: ${shorthandType}`)
    }

    if (fields.length === 0) {
      return `export type ${model.name}WhereUniqueInput = never`
    }

    return dedent.withOptions({ alignValues: true })`
      export type ${model.name}WhereUniqueInput = {
        ${fields.join('\n')}
      }
    `
  }

  /**
   * Get the filter type for a field (e.g., NumericFilter<number>, StringFilter<string | null>)
   */
  private getFilterTypeForField(field: FieldAST): string {
    const baseType = field.fieldType

    switch (baseType) {
      case 'Int':
      case 'Float':
        return `NumericFilter<number>`

      case 'BigInt':
        return `NumericFilter<bigint>`

      case 'String':
        return field.isOptional ? `StringFilter<string | null>` : `StringFilter<string>`

      case 'Boolean':
        return `BooleanFilter`

      case 'DateTime':
        return field.isOptional ? `DateTimeFilter<Date | string | null>` : `DateTimeFilter<Date | string>`

      case 'Json':
        return `JsonFilter`

      default:
        // For enums or unknown types
        return field.isOptional ? `BaseFilter<${baseType} | null>` : `BaseFilter<${baseType}>`
    }
  }

  /**
   * Get the shorthand type for a field (e.g., number, string | null)
   */
  private getShorthandTypeForField(field: FieldAST): string {
    const tsType = this.mapFieldType(field)
    return field.isOptional ? `${tsType} | null` : tsType
  }

  /**
   * Generate OrderByWithRelationInput type for a model
   */
  private generateOrderByInput(model: ModelAST): string {
    const fields: string[] = []
    const modelNames = new Set(this.schemaAST.models.map((m) => m.name))

    // Add scalar fields (can be ordered)
    for (const field of model.fields) {
      // Skip relation fields for Phase 1
      if (modelNames.has(field.fieldType)) {
        continue
      }

      fields.push(`  ${field.name}?: SortOrder`)
    }

    // Note: Relation ordering deferred
    // Would add: posts?: PostOrderByRelationAggregateInput

    return dedent.withOptions({ alignValues: true })`
      export type ${model.name}OrderByWithRelationInput = {
        ${fields.join('\n')}
      }
    `
  }

  /**
   * Check if a field should be excluded from CreateInput
   */
  private shouldExcludeFromCreate(field: FieldAST): boolean {
    const modelNames = new Set(this.schemaAST.models.map((m) => m.name))

    // Exclude relation fields (not foreign keys, but relation objects)
    if (modelNames.has(field.fieldType)) {
      return true
    }

    // Exclude fields with @updatedAt
    if (field.attributes?.some((attr) => attr.name === 'updatedAt')) {
      return true
    }

    // Exclude auto-generated ID fields: @id @default(autoincrement())
    const hasIdAttribute = field.attributes?.some((attr) => attr.name === 'id')
    const hasAutoIncrement = field.attributes?.some(
      (attr) =>
        attr.name === 'default' &&
        attr.args?.some((arg) => arg.value === 'autoincrement' || String(arg.value).includes('autoincrement')),
    )
    if (hasIdAttribute && hasAutoIncrement) {
      return true
    }

    // // Exclude fields with @default(now()) - typically timestamps
    // const hasDefaultNow = field.attributes?.some(
    //   (attr) =>
    //     attr.name === 'default' && attr.args?.some((arg) => arg.value === 'now' || String(arg.value).includes('now')),
    // )
    // if (hasDefaultNow) {
    //   return true
    // }

    return false
  }

  /**
   * Check if a field is required in CreateInput (not optional, no default)
   */
  private isFieldRequiredInCreate(field: FieldAST): boolean {
    return !field.isOptional && !field.attributes?.some((attr) => attr.name === 'default')
  }

  /**
   * Generate CreateInput type for a model
   */
  private generateCreateInput(model: ModelAST): string {
    const fields: string[] = []

    for (const field of model.fields) {
      if (this.shouldExcludeFromCreate(field)) {
        continue
      }

      const tsType = this.mapFieldType(field)
      const isRequired = this.isFieldRequiredInCreate(field)

      if (isRequired) {
        // Required field
        fields.push(`${field.name}: ${tsType}`)
      } else {
        // Optional field - allow omission or explicit value
        const optionalType = field.isOptional ? `${tsType} | null` : tsType
        fields.push(`${field.name}?: ${optionalType}`)
      }
    }

    return dedent.withOptions({ alignValues: true })`
      export type ${model.name}CreateInput = {
        ${fields.join('\n')}
      }
    `
  }

  /**
   * Generate UpdateInput type for a model
   * All fields are optional in updates
   */
  private generateUpdateInput(model: ModelAST): string {
    const fields: string[] = []
    const modelNames = new Set(this.schemaAST.models.map((m) => m.name))

    for (const field of model.fields) {
      // Exclude relation fields (Phase 1)
      if (modelNames.has(field.fieldType)) {
        continue
      }

      // Exclude @updatedAt fields (automatically managed)
      if (field.attributes?.some((attr) => attr.name === 'updatedAt')) {
        continue
      }

      // Exclude @id @default(autoincrement()) fields (can't update primary key)
      const hasIdAttribute = field.attributes?.some((attr) => attr.name === 'id')
      const hasAutoIncrement = field.attributes?.some(
        (attr) =>
          attr.name === 'default' &&
          attr.args?.some((arg) => arg.value === 'autoincrement' || String(arg.value).includes('autoincrement')),
      )
      if (hasIdAttribute && hasAutoIncrement) {
        continue
      }

      const tsType = this.mapFieldType(field)
      // In updates, all fields are optional and can be set to their type or null (if field allows null)
      const updateType = field.isOptional ? `${tsType} | null` : tsType
      fields.push(`  ${field.name}?: ${updateType}`)
    }

    return `export type ${model.name}UpdateInput = {
${fields.join('\n')}
}`
  }

  /**
   * Generate Args types for all CRUD operations
   */
  private generateArgsTypes(model: ModelAST): string {
    const includeType = `${model.name}Include`

    return dedent`
      // Args types for ${model.name}
      export type ${model.name}FindManyArgs = {
        where?: ${model.name}WhereInput
        orderBy?: ${model.name}OrderByWithRelationInput | ${model.name}OrderByWithRelationInput[]
        take?: number
        skip?: number
        include?: ${includeType}
      }

      export type ${model.name}FindUniqueArgs = {
        where: ${model.name}WhereUniqueInput
        include?: ${includeType}
      }

      export type ${model.name}FindFirstArgs = {
        where?: ${model.name}WhereInput
        orderBy?: ${model.name}OrderByWithRelationInput | ${model.name}OrderByWithRelationInput[]
        include?: ${includeType}
      }

      export type ${model.name}CreateArgs = {
        data: ${model.name}CreateInput
      }

      export type ${model.name}CreateManyArgs = {
        data: ${model.name}CreateInput[]
      }

      export type ${model.name}UpdateArgs = {
        where: ${model.name}WhereUniqueInput
        data: ${model.name}UpdateInput
      }

      export type ${model.name}UpdateManyArgs = {
        where?: ${model.name}WhereInput
        data: ${model.name}UpdateInput
      }

      export type ${model.name}UpsertArgs = {
        where: ${model.name}WhereUniqueInput
        create: ${model.name}CreateInput
        update: ${model.name}UpdateInput
      }

      export type ${model.name}DeleteArgs = {
        where: ${model.name}WhereUniqueInput
      }

      export type ${model.name}DeleteManyArgs = {
        where?: ${model.name}WhereInput
      }

      export type ${model.name}CountArgs = {
        where?: ${model.name}WhereInput
      }
    `
  }

  private generateCRUDInterfaces(): string {
    // Generate relation include types
    const relationIncludeTypes = this.schemaAST.models
      .map((model) => {
        const relations = this.getModelRelations(model)
        if (relations.length === 0) return ''

        const includeFields = relations.map((rel) => `  ${rel.fieldName}?: boolean`).join('\n')
        return `export interface ${model.name}Include {
${includeFields}
}`
      })
      .filter(Boolean)
      .join('\n\n')

    return `${
      relationIncludeTypes ? relationIncludeTypes + '\n\n' : ''
    }export interface ModelCRUDOperations<T, TInclude = any> {
  findMany(args?: { where?: Partial<T>; orderBy?: any; take?: number; skip?: number; include?: TInclude }): Promise<T[]>
  findUnique(args: { where: Partial<T>; include?: TInclude }): Promise<T | null>
  findFirst(args?: { where?: Partial<T>; orderBy?: any; include?: TInclude }): Promise<T | null>
  create(args: { data: any }): Promise<T>
  createMany(args: { data: any[] }): Promise<{ count: number }>
  update(args: { where: Partial<T>; data: any }): Promise<T>
  updateMany(args: { where?: Partial<T>; data: any }): Promise<{ count: number }>
  upsert(args: { where: Partial<T>; create: any; update: any }): Promise<T>
  delete(args: { where: Partial<T> }): Promise<T>
  deleteMany(args?: { where?: Partial<T> }): Promise<{ count: number }>
  count(args?: { where?: Partial<T> }): Promise<number>
}`
  }

  private generateModelOperationsBlock(): string {
    const whereHelpers = this.generateWhereHelpersBlock()
    const operationClasses = this.schemaAST.models.map((model) => this.generateModelOperations(model))

    const factoryEntries = this.schemaAST.models
      .map((model) => `  ${this.toCamelCase(model.name)}: new ${model.name}Operations(kysely)`)
      .join(',\n')

    const factory = `const createModelOperations = (kysely: Kysely<DatabaseSchema>) => ({\n${factoryEntries}\n})`

    return [whereHelpers, ...operationClasses, factory].filter(Boolean).join('\n\n')
  }

  private generateWhereHelpersBlock(): string {
    const helpers = this.schemaAST.models.map((model) => this.generateWhereHelpers(model))
    return helpers.filter(Boolean).join('\n\n')
  }

  private generateModelOperations(model: ModelAST): string {
    const className = `${model.name}Operations`
    const tableName = this.getTableName(model)
    const relations = this.getModelRelations(model)
    const whereHelperName = `buildWhereExpression_${model.name}`

    // Generate private relation helper methods
    const relationHelpers = this.generateRelationHelperMethods(model, relations)
    const hasRelations = relations.length > 0

    // Generate $if conditions for includes
    const ifConditions = this.generateIfConditions(model, relations)

    const includeAssignments = relations
      .map((rel) => {
        if (rel.isArray) {
          return dedent`
            if (include?.${rel.fieldName}) {
              result.${rel.fieldName} = row.${rel.fieldName} ?? []
            }
          `
        }

        return dedent`
          if (include?.${rel.fieldName}) {
            result.${rel.fieldName} = row.${rel.fieldName} ?? null
          }
        `
      })
      .join('\n')

    const includeHelper = hasRelations
      ? dedent`
          private applyIncludes<TInclude extends ${model.name}Include>(
            row: ${model.name}RowWithIncludes,
            include: TInclude
          ): ${model.name}GetPayload<{ include: TInclude }> {
            const result: ${model.name}Scalars & Partial<${model.name}Relations> = this.transformSelectResult(row)

            ${includeAssignments}

            return result as ${model.name}GetPayload<{ include: TInclude }>
          }
        `
      : ''

    const findManyOverloads = hasRelations
      ? dedent`
          findMany(args?: Omit<${model.name}FindManyArgs, 'include'>): Promise<${model.name}Scalars[]>
          findMany<T extends ${model.name}FindManyArgs>(args: T): Promise<${model.name}GetPayload<T>[]>
        `
      : ''

    const findUniqueOverloads = hasRelations
      ? dedent`
          findUnique(args: Omit<${model.name}FindUniqueArgs, 'include'>): Promise<${model.name}Scalars | null>
          findUnique<T extends ${model.name}FindUniqueArgs>(args: T): Promise<${model.name}GetPayload<T> | null>
        `
      : ''

    const findFirstOverloads = hasRelations
      ? dedent`
          findFirst(args?: Omit<${model.name}FindFirstArgs, 'include'>): Promise<${model.name}Scalars | null>
          findFirst<T extends ${model.name}FindFirstArgs>(args: T): Promise<${model.name}GetPayload<T> | null>
        `
      : ''

    const findManyReturnType = hasRelations
      ? `Promise<${model.name}Scalars[] | ${model.name}GetPayload<T>[]>`
      : `Promise<${model.name}GetPayload<T>[]>`

    const findOneReturnType = hasRelations
      ? `Promise<${model.name}Scalars | ${model.name}GetPayload<T> | null>`
      : `Promise<${model.name}GetPayload<T> | null>`

    const findManyReturn = hasRelations
      ? dedent`
          const include = args?.include
          if (!include) {
            return results.map(row => this.transformSelectResult(row))
          }

          return results.map(row => this.applyIncludes(row, include))
        `
      : dedent`
          return results.map(row => this.transformSelectResult(row))
        `

    const findOneReturn = hasRelations
      ? dedent`
          const include = args?.include
          if (!include) {
            return this.transformSelectResult(results[0])
          }

          return this.applyIncludes(results[0], include)
        `
      : dedent`
          return this.transformSelectResult(results[0])
        `

    return dedent.withOptions({ alignValues: true })`
      /**
       * Generated operations for ${model.name} model
       */
      class ${className} {
        constructor(private kysely: Kysely<DatabaseSchema>) {}

        ${relationHelpers}

        ${findManyOverloads}
        async findMany<T extends ${model.name}FindManyArgs = {}>(args?: T): ${findManyReturnType} {
          let query = this.kysely
            .selectFrom('${tableName}')
            .selectAll()
            ${ifConditions}

          query = query.where(eb => ${whereHelperName}(this.kysely, eb, args?.where ?? {}))

          if (args?.orderBy) {
            const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
            for (const orderByObj of orderByArray) {
              Object.entries(orderByObj).forEach(([field, direction]) => {
                query = query.orderBy(field as any, direction as 'asc' | 'desc')
              })
            }
          }

          if (args?.skip) {
            query = query.offset(args.skip)
          }

          if (args?.take) {
            query = query.limit(args.take)
          }

          const results = await query.execute()

          ${findManyReturn}
        }

        ${findUniqueOverloads}
        async findUnique<T extends ${model.name}FindUniqueArgs>(args: T): ${findOneReturnType} {
          let query = this.kysely
            .selectFrom('${tableName}')
            .selectAll()
            ${ifConditions}

          query = query.where(eb => ${whereHelperName}(this.kysely, eb, args.where))
          const results = await query.execute()

          if (results.length === 0) return null

          ${findOneReturn}
        }

        ${findFirstOverloads}
        async findFirst<T extends ${model.name}FindFirstArgs = {}>(args?: T): ${findOneReturnType} {
          let query = this.kysely
            .selectFrom('${tableName}')
            .selectAll()
            ${ifConditions}

          query = query.where(eb => ${whereHelperName}(this.kysely, eb, args?.where ?? {}))

          if (args?.orderBy) {
            const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
            for (const orderByObj of orderByArray) {
              Object.entries(orderByObj).forEach(([field, direction]) => {
                query = query.orderBy(field as any, direction as 'asc' | 'desc')
              })
            }
          }

          query = query.limit(1)
          const results = await query.execute()

          if (results.length === 0) return null

          ${findOneReturn}
        }

        async create(args: ${model.name}CreateArgs): Promise<${model.name}> {
          const prepared = this.prepareCreateData(args.data)
          const result = await this.kysely
            .insertInto('${tableName}')
            .values(prepared as any)
            .returningAll()
            .executeTakeFirstOrThrow()
          return this.transformSelectResult(result)
        }

        async createMany(args: ${model.name}CreateManyArgs): Promise<{ count: number }> {
          const dataArray = args.data.map(item => this.prepareCreateData(item))
          await this.kysely
            .insertInto('${tableName}')
            .values(dataArray as any)
            .execute()
          return { count: dataArray.length }
        }

        async update(args: ${model.name}UpdateArgs): Promise<${model.name}> {
          const prepared = this.prepareUpdateData(args.data)
          let query = this.kysely.updateTable('${tableName}').set(prepared as any)
          query = query.where(eb => ${whereHelperName}(this.kysely, eb, args.where))
          const result = await query.returningAll().executeTakeFirstOrThrow()
          return this.transformSelectResult(result)
        }

        async updateMany(args: ${model.name}UpdateManyArgs): Promise<{ count: number }> {
          const prepared = this.prepareUpdateData(args.data)
          let query = this.kysely.updateTable('${tableName}').set(prepared as any)
          
          query = query.where(eb => ${whereHelperName}(this.kysely, eb, args?.where ?? {}))
          
          const result = await query.execute()
          return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
        }

        async upsert(args: ${model.name}UpsertArgs): Promise<${model.name}> {
          const createData = this.prepareCreateData(args.create)
          const updateData = this.prepareUpdateData(args.update)
          
          const result = await this.kysely
            .insertInto('${tableName}')
            .values(createData as any)
            .onConflict(oc => oc.column('${this.getPrimaryKeyField(model)}').doUpdateSet(updateData))
            .returningAll()
            .executeTakeFirstOrThrow()
          return this.transformSelectResult(result)
        }

        async delete(args: ${model.name}DeleteArgs): Promise<${model.name}> {
          let query = this.kysely.deleteFrom('${tableName}')
          query = query.where(eb => ${whereHelperName}(this.kysely, eb, args.where))
          const result = await query.returningAll().executeTakeFirstOrThrow()
          return this.transformSelectResult(result)
        }

        async deleteMany(args?: ${model.name}DeleteManyArgs): Promise<{ count: number }> {
          let query = this.kysely.deleteFrom('${tableName}')
          
          query = query.where(eb => ${whereHelperName}(this.kysely, eb, args?.where ?? {}))
          
          const result = await query.execute()
          return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
        }

        async count(args?: ${model.name}CountArgs): Promise<number> {
          let query = this.kysely
            .selectFrom('${tableName}')
            .select(eb => eb.fn.count('id').as('count'))
            
          query = query.where(eb => ${whereHelperName}(this.kysely, eb, args?.where ?? {}))
          
          const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
          return Number(result?.count || 0)
        }

        private prepareCreateData(data: ${model.name}CreateInput): Record<string, unknown> {
          const prepared: Record<string, unknown> = {}
          
          ${this.generateFieldTransformationMethods(model, 'create')}
          
          return prepared
        }

        private prepareUpdateData(data: ${model.name}UpdateInput): Record<string, unknown> {
          const prepared: Record<string, unknown> = {}
          
          ${this.generateFieldTransformationMethods(model, 'update')}
          
          return prepared
        }

        private transformSelectResult(row: ${model.name}Row): ${model.name}Scalars {
          const result: Partial<${model.name}Scalars> = {}

          ${this.generateFieldTransformationMethods(model, 'select')}

          return result as ${model.name}Scalars
        }

        ${includeHelper}

        private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
          const relatedData: Record<string, any[]> = {}

          // Only fetch relations that are marked as 'many' type
          const manyRelations = relations.filter(r => r.type === 'many')
          if (manyRelations.length === 0 || results.length === 0) {
            return relatedData
          }

          ${this.generateFetchManyRelationsLogic(model)}

          return relatedData
        }

        private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): ${
          model.name
        } {
          // First transform the base model
          const result: any = this.transformSelectResult(row)

          // Then add included relations
          ${this.generateIncludeTransformationLogic(model)}

          return result
        }
      }
    `
  }

  private generateWhereHelpers(model: ModelAST): string {
    const modelName = model.name
    const tableName = this.getTableName(model)
    const relations = this.getModelRelations(model)
    const relationNames = relations.map((rel) => rel.fieldName)

    const buildWhereName = `buildWhereExpression_${modelName}`
    const buildFieldName = `buildFieldExpression_${modelName}`
    const buildRelationName = `buildRelationExpression_${modelName}`
    const transformWhereName = `transformWhereValue_${modelName}`

    const relationSwitchCases = relations
      .map((rel) => {
        const relatedModel = this.findModelByName(rel.relatedModel)
        if (!relatedModel) return ''

        const relatedTable = this.getTableName(relatedModel)
        const relatedPk = this.getPrimaryKeyField(relatedModel)
        const relatedWhereHelper = `buildWhereExpression_${relatedModel.name}`

        let leftRef: string
        let rightRef: string

        if (rel.foreignKeyField && rel.referencedField) {
          leftRef = `${tableName}.${rel.foreignKeyField}`
          rightRef = `${relatedTable}.${rel.referencedField}`
        } else {
          const foreignKeyField = this.getForeignKeyForRelation(relatedModel, modelName)
          const referencedField = this.getPrimaryKeyField(model)
          leftRef = `${relatedTable}.${foreignKeyField}`
          rightRef = `${tableName}.${referencedField}`
        }

        const baseQuery = `() => eb.selectFrom('${relatedTable}').select('${relatedTable}.${relatedPk}').whereRef('${leftRef}', '=', '${rightRef}')`

        if (rel.isArray) {
          return dedent`
            case '${rel.fieldName}': {
              if (value === null || typeof value !== 'object') {
                return eb.and([])
              }

              const filter = value as { some?: ${relatedModel.name}WhereInput; every?: ${relatedModel.name}WhereInput; none?: ${relatedModel.name}WhereInput }
              const conditions: Expression<SqlBool>[] = []
              const baseQuery = ${baseQuery}

              if (filter.some) {
                conditions.push(
                  eb.exists(
                    baseQuery().where((relEb) => ${relatedWhereHelper}(kysely, relEb, filter.some as ${relatedModel.name}WhereInput))
                  )
                )
              }

              if (filter.every) {
                const existsAny = eb.exists(baseQuery())
                const existsNonMatching = eb.exists(
                  baseQuery().where((relEb) => relEb.not(${relatedWhereHelper}(kysely, relEb, filter.every as ${relatedModel.name}WhereInput)))
                )
                conditions.push(eb.and([existsAny, eb.not(existsNonMatching)]))
              }

              if (filter.none) {
                conditions.push(
                  eb.not(
                    eb.exists(
                      baseQuery().where((relEb) => ${relatedWhereHelper}(kysely, relEb, filter.none as ${relatedModel.name}WhereInput))
                    )
                  )
                )
              }

              return eb.and(conditions)
            }
          `
        }

        return dedent`
          case '${rel.fieldName}': {
            const baseQuery = ${baseQuery}

            if (value === null) {
              return eb.not(eb.exists(baseQuery()))
            }

            if (value === null || typeof value !== 'object') {
              return eb.and([])
            }

            const filter = value as { is?: ${relatedModel.name}WhereInput | null; isNot?: ${relatedModel.name}WhereInput | null }
            const conditions: Expression<SqlBool>[] = []

            if ('is' in filter) {
              if (filter.is === null) {
                conditions.push(eb.not(eb.exists(baseQuery())))
              } else if (filter.is) {
                conditions.push(
                  eb.exists(
                    baseQuery().where((relEb) => ${relatedWhereHelper}(kysely, relEb, filter.is as ${relatedModel.name}WhereInput))
                  )
                )
              }
            }

            if ('isNot' in filter) {
              if (filter.isNot === null) {
                conditions.push(eb.exists(baseQuery()))
              } else if (filter.isNot) {
                const existsAny = eb.exists(baseQuery())
                const existsMatch = eb.exists(
                  baseQuery().where((relEb) => ${relatedWhereHelper}(kysely, relEb, filter.isNot as ${relatedModel.name}WhereInput))
                )
                conditions.push(eb.and([existsAny, eb.not(existsMatch)]))
              }
            }

            return eb.and(conditions)
          }
        `
      })
      .filter(Boolean)
      .join('\n')

    const relationFieldCases = relationNames.length
      ? relationNames.map((name) => `case '${name}':`).join('\n')
      : ''

    const relationFieldBlock = relationNames.length
      ? dedent`
          ${relationFieldCases}
          expressions.push(${buildRelationName}(kysely, eb, field, value))
          break
          default:
            expressions.push(${buildFieldName}(eb, field, value))
        `
      : dedent`
          default:
            expressions.push(${buildFieldName}(eb, field, value))
        `

    return dedent.withOptions({ alignValues: true })`
      function ${transformWhereName}(fieldName: string, value: unknown): unknown {
        ${this.generateFieldTransformationMethods(model, 'where')}
      }

      function ${buildFieldName}(
        eb: ExpressionBuilder<DatabaseSchema, '${modelName}'>,
        field: string,
        value: unknown
      ) {
        const qualifiedField = \`${modelName}.$\{field}\` as ReferenceExpression<DatabaseSchema, '${modelName}'>

        if (value === null) {
          return eb(qualifiedField, 'is', null)
        }

        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          const conditions: Expression<SqlBool>[] = []

          for (const [operator, operatorValue] of Object.entries(value)) {
            switch (operator) {
              case 'equals':
                if (operatorValue === null) {
                  conditions.push(eb(qualifiedField, 'is', null))
                } else {
                  conditions.push(eb(qualifiedField, '=', ${transformWhereName}(field, operatorValue)))
                }
                break
              case 'gt':
                conditions.push(eb(qualifiedField, '>', ${transformWhereName}(field, operatorValue)))
                break
              case 'gte':
                conditions.push(eb(qualifiedField, '>=', ${transformWhereName}(field, operatorValue)))
                break
              case 'lt':
                conditions.push(eb(qualifiedField, '<', ${transformWhereName}(field, operatorValue)))
                break
              case 'lte':
                conditions.push(eb(qualifiedField, '<=', ${transformWhereName}(field, operatorValue)))
                break
              case 'not':
                if (operatorValue === null) {
                  conditions.push(eb(qualifiedField, 'is not', null))
                } else {
                  conditions.push(eb(qualifiedField, '!=', ${transformWhereName}(field, operatorValue)))
                }
                break
              case 'in':
                conditions.push(
                  eb(qualifiedField, 'in', (operatorValue as unknown[]).map(v => ${transformWhereName}(field, v)))
                )
                break
              case 'notIn':
                conditions.push(
                  eb(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => ${transformWhereName}(field, v)))
                )
                break
              case 'contains':
                conditions.push(eb(qualifiedField, 'like', \`%\${operatorValue}%\`))
                break
              case 'startsWith':
                conditions.push(eb(qualifiedField, 'like', \`\${operatorValue}%\`))
                break
              case 'endsWith':
                conditions.push(eb(qualifiedField, 'like', \`%\${operatorValue}\`))
                break
            }
          }

          return eb.and(conditions)
        }

        return eb(qualifiedField, '=', ${transformWhereName}(field, value))
      }

      function ${buildRelationName}(
        kysely: Kysely<DatabaseSchema>,
        eb: ExpressionBuilder<DatabaseSchema, '${modelName}'>,
        field: string,
        value: unknown
      ) {
        switch (field) {
          ${relationSwitchCases}
          default:
            return eb.and([])
        }
      }

      function ${buildWhereName}(
        kysely: Kysely<DatabaseSchema>,
        eb: ExpressionBuilder<DatabaseSchema, '${modelName}'>,
        where: ${modelName}WhereInput
      ) {
        const expressions: Expression<SqlBool>[] = []

        for (const [field, value] of Object.entries(where)) {
          if (field === 'AND') {
            expressions.push(eb.and((value as ${modelName}WhereInput[]).map(cond => ${buildWhereName}(kysely, eb, cond))))
          } else if (field === 'OR') {
            expressions.push(eb.or((value as ${modelName}WhereInput[]).map(cond => ${buildWhereName}(kysely, eb, cond))))
          } else if (field === 'NOT') {
            // \`eb.not\` doesn't accept a list, so need to negate each condition instead.
            for (const cond of value as ${modelName}WhereInput[]) {
              expressions.push(eb.not(${buildWhereName}(kysely, eb, cond)))
            }
          } else {
            switch (field) {
              ${relationFieldBlock}
            }
          }
        }

        return eb.and(expressions)
      }
    `
  }

  private generateFieldTransformationMethods(
    model: ModelAST,
    operation: 'create' | 'update' | 'where' | 'select',
  ): string {
    // Get list of model names to detect relation fields
    const modelNames = new Set(this.schemaAST.models.map((m) => m.name))

    const transformations = model.fields
      .map((field) => {
        // Skip relation fields - they're not actual database columns
        if (modelNames.has(field.fieldType)) {
          return null
        }

        // Skip certain fields in creates and updates
        const isCreateOrUpdate = operation === 'update' || operation === 'create'
        const isPrimaryKey = this.isPrimaryKey(field)
        const isAutoTimestamp = this.isAutoTimestamp(field)
        if (isCreateOrUpdate && (isPrimaryKey || isAutoTimestamp)) {
          return null
        }

        // Use FieldTranslator to generate transformation code
        const fieldAnalysis = this.fieldTranslator.analyzeField(field)
        const transformation = fieldAnalysis.transformations.get(operation)

        if (!transformation) {
          // Generate basic fallback transformation for common types
          return this.generateFallbackTransformation(field, operation)
        }

        switch (operation) {
          case 'where':
            return dedent`
              if (fieldName === '${field.name}') {
                return ${transformation.code.replaceAll('data.' + field.name, 'value')}
              }
            `

          case 'create':
          case 'update':
            return dedent`
              if (data.${field.name} !== undefined) {
                prepared.${field.name} = ${transformation.code}
              }
            `

          case 'select':
            return dedent`
              result.${field.name} = ${transformation.code.replaceAll('data.' + field.name, 'row.' + field.name)}
            `
        }
      })
      .filter(Boolean)

    // Add timestamp handling for create/update
    if (operation === 'create' || operation === 'update') {
      const hasCreatedAt = model.fields.some((f) => f.name === 'createdAt')
      const hasUpdatedAt = model.fields.some((f) => f.name === 'updatedAt')

      let logic = ''

      if (operation === 'create' && hasCreatedAt) {
        logic += 'prepared.createdAt = data.createdAt ? new Date(data.createdAt) : new Date().toISOString()\n'
      }

      if (hasUpdatedAt) {
        logic += 'prepared.updatedAt = new Date().toISOString()'
      }

      transformations.push(logic)
    }

    // Add fallback for where operation
    if (operation === 'where') {
      transformations.push('return value // No transformation needed for this field')
    }

    return transformations.join('\n\n')
  }

  private generateFallbackTransformation(field: FieldAST, operation: 'create' | 'update' | 'where' | 'select'): string {
    const whereTransform = this.generateFieldValueTransformation(field, 'value', false)

    switch (operation) {
      case 'where':
        return dedent`
          if (fieldName === '${field.name}') {
            return ${whereTransform}
          }
        `

      case 'create':
      case 'update':
        return dedent`
          if (data.${field.name} !== undefined) {
            prepared.${field.name} = ${this.generateFieldValueTransformation(field, `data.${field.name}`)}
          }
        `

      case 'select':
        return dedent`
          result.${field.name} = ${this.generateFieldValueTransformation(field, `row.${field.name}`, true)}
        `
    }
  }

  private generateFieldValueTransformation(field: FieldAST, variableName: string, isFromDatabase = false): string {
    // Handle optional fields with null check
    const isOptional = field.isOptional

    // Generate database-specific transformations based on dialect
    switch (field.fieldType) {
      case 'Boolean':
        if (this.dialect === 'sqlite') {
          return isFromDatabase ? `${variableName} === 1` : `${variableName} ? 1 : 0`
        }
        return variableName

      case 'DateTime':
        return `new Date(${variableName} as string | number | Date)`

      case 'Int':
      case 'Float':
        return `Number(${variableName})`

      case 'String':
        if (isOptional && !isFromDatabase) {
          return `${variableName} !== null ? String(${variableName}) : null`
        }
        return `String(${variableName})`

      case 'BigInt':
        if (this.dialect === 'sqlite') {
          return isFromDatabase ? `BigInt(${variableName})` : `String(${variableName})`
        }
        return variableName

      case 'Json':
        return isFromDatabase ? `JSON.parse(${variableName})` : `JSON.stringify(${variableName})`

      default:
        return variableName
    }
  }

  private generateClientClass(): string {
    const modelDeclarations = this.schemaAST.models
      .map((model) => `  declare readonly ${this.toCamelCase(model.name)}: ${model.name}Operations`)
      .join('\n')

    const declarationsBlock = modelDeclarations.length > 0 ? `${modelDeclarations}\n` : ''

    return `/**
 * Refract Client with pre-compiled operations
 * Database dialect: ${this.dialect}
 * No runtime schema parsing - all model operations are embedded at generation time
 */
export class RefractClient extends RefractClientBase<DatabaseSchema> {
${declarationsBlock}  constructor(dialect: Dialect) {
    super(dialect, { modelFactory: createModelOperations })
  }
}`
  }

  private generateClientFactory(): string {
    return `/**
 * Factory function for creating RefractClient instances
 */
export function createRefractClient(dialect: Dialect): RefractClient {
  return new RefractClient(dialect)
}

/**
 * Convenience factory function that automatically loads configuration
 * This is the main entry point used by the generated client
 */
export async function createClient(): Promise<RefractClient> {
  const { config } = await loadRefractConfig()
  const dialect = await createKyselyDialect(config)
  return new RefractClient(dialect)
}`
  }

  private getTableName(model: ModelAST): string {
    // Check for @@map attribute
    const mapAttribute = model.attributes.find((attr) => attr.name === 'map')
    if (mapAttribute && mapAttribute.args[0]) {
      return String(mapAttribute.args[0].value)
    }
    // Default: use model name as-is (Prisma's default)
    return model.name
  }

  private getPrimaryKeyField(model: ModelAST): string {
    const pkField = model.fields.find((field) => field.attributes.some((attr) => attr.name === 'id'))
    return pkField ? pkField.name : 'id'
  }

  private toCamelCase(str: string): string {
    return str.charAt(0).toLowerCase() + str.slice(1)
  }

  /**
   * Get the TypeScript type for a field by name
   * Uses mapFieldType to ensure consistency with generated model interfaces
   */
  private getFieldTsType(model: ModelAST, fieldName: string): string {
    const field = model.fields.find((f) => f.name === fieldName)
    if (!field) return 'unknown'
    return this.mapFieldType(field)
  }

  /**
   * Generate private helper methods for relation loading using jsonArrayFrom/jsonObjectFrom
   * These create subquery builders for each relation
   */
  private generateRelationHelperMethods(
    model: ModelAST,
    relations: Array<{
      fieldName: string
      relatedModel: string
      isArray: boolean
      foreignKeyField?: string
      referencedField?: string
    }>,
  ): string {
    if (relations.length === 0) return ''

    const pkField = this.getPrimaryKeyField(model)
    const pkType = this.getFieldTsType(model, pkField)

    const helpers = relations
      .map((rel) => {
        const relatedModel = this.findModelByName(rel.relatedModel)
        if (!relatedModel) return ''

        const relatedTableName = this.getTableName(relatedModel)

        if (rel.isArray) {
          // One-to-many: use jsonArrayFrom
          // Find the FK field on the related model that points to this model
          const foreignKeyField = this.getForeignKeyForRelation(relatedModel, model.name)

          return dedent`
            private _${rel.fieldName}(${pkField}: Expression<${pkType}>) {
              return jsonArrayFrom(
                this.kysely.selectFrom('${relatedTableName}')
                  .selectAll()
                  .whereRef('${relatedTableName}.${foreignKeyField}', '=', ${pkField})
                  .orderBy('${relatedTableName}.${this.getPrimaryKeyField(relatedModel)}'))
            }
          `
        } else if (rel.foreignKeyField) {
          // Forward relation (this model has FK): use jsonObjectFrom
          const fkType = this.getFieldTsType(model, rel.foreignKeyField)

          return dedent`
            private _${rel.fieldName}(${rel.foreignKeyField}: Expression<${fkType}>) {
              return jsonObjectFrom(
                this.kysely.selectFrom('${relatedTableName}')
                  .selectAll()
                  .whereRef('${relatedTableName}.${rel.referencedField || 'id'}', '=', ${rel.foreignKeyField})
              )
            }
          `
        } else {
          // Reverse relation (related model has FK pointing to us): use jsonObjectFrom
          const reverseRelation = this.getModelRelations(relatedModel).find(
            (r) => r.relatedModel === model.name && r.foreignKeyField,
          )

          if (reverseRelation) {
            return dedent`
              private _${rel.fieldName}(${pkField}: Expression<${pkType}>) {
                return jsonObjectFrom(
                  this.kysely.selectFrom('${relatedTableName}')
                    .selectAll()
                    .whereRef('${relatedTableName}.${reverseRelation.foreignKeyField}', '=', ${pkField})
                )
              }
            `
          }
        }

        return ''
      })
      .filter(Boolean)
      .join('\n\n')

    return helpers
  }

  /**
   * Generate $if conditions for conditionally including relations in queries
   * Uses the private helper methods to build subqueries
   */
  private generateIfConditions(
    model: ModelAST,
    relations: Array<{
      fieldName: string
      relatedModel: string
      isArray: boolean
      foreignKeyField?: string
      referencedField?: string
    }>,
  ): string {
    if (relations.length === 0) return ''

    const tableName = this.getTableName(model)
    const pkField = this.getPrimaryKeyField(model)

    const conditions = relations
      .map((rel) => {
        const relatedModel = this.findModelByName(rel.relatedModel)
        if (!relatedModel) return ''

        // Determine the reference field to pass to the helper
        let refField: string
        if (rel.foreignKeyField) {
          // Forward relation: use the FK field
          refField = `'${tableName}.${rel.foreignKeyField}'`
        } else {
          // Reverse relation or one-to-many: use the PK field
          refField = `'${tableName}.${pkField}'`
        }

        return dedent`
        .$if(!!args?.include?.${rel.fieldName}, (qb) => qb.select(
          (eb) => this._${rel.fieldName}(eb.ref(${refField})).as('${rel.fieldName}')
        ))`
      })
      .filter(Boolean)
      .join('\n')

    return conditions
  }

  /**
   * Extract relation metadata from a model
   */
  private getModelRelations(model: ModelAST): Array<{
    fieldName: string
    relatedModel: string
    isArray: boolean
    foreignKeyField?: string
    referencedField?: string
  }> {
    const modelNames = new Set(this.schemaAST.models.map((m) => m.name))

    return model.fields
      .filter((field) => {
        // A field is a relation if its type references another model
        return modelNames.has(field.fieldType)
      })
      .map((field) => {
        const relationAttr = field.attributes.find((attr) => attr.name === 'relation')

        // Extract foreign key information from @relation attribute
        let foreignKeyField: string | undefined
        let referencedField: string | undefined

        if (relationAttr) {
          const fieldsArg = relationAttr.args.find((arg) => arg.name === 'fields')
          const referencesArg = relationAttr.args.find((arg) => arg.name === 'references')

          if (fieldsArg && Array.isArray(fieldsArg.value)) {
            foreignKeyField = fieldsArg.value[0] as string
          }

          if (referencesArg && Array.isArray(referencesArg.value)) {
            referencedField = referencesArg.value[0] as string
          }
        }

        return {
          fieldName: field.name,
          relatedModel: field.fieldType,
          isArray: field.isList,
          foreignKeyField,
          referencedField,
        }
      })
  }

  /**
   * Generate logic to transform flat joined rows into nested objects
   */
  private generateIncludeTransformationLogic(model: ModelAST): string {
    const relations = this.getModelRelations(model)
    if (relations.length === 0) return '// No relations to transform'

    const logic = relations
      .map((rel) => {
        const relatedModel = this.findModelByName(rel.relatedModel)
        if (!relatedModel) return ''

        // One-to-one relation (joined inline)
        if (!rel.isArray) {
          const relatedFields = relatedModel.fields
            .filter((f) => !this.getModelRelations(relatedModel).some((r) => r.fieldName === f.name))
            .map((f) => {
              const transformation = this.generateFieldValueTransformation(f, `row.${rel.fieldName}_${f.name}`, true)
              return `      ${f.name}: ${transformation}`
            })
            .join(',\n')

          return dedent`const ${rel.fieldName}Relation = relations.find(r => r.field === '${
            rel.fieldName
          }' && r.type === 'one')
    if (${rel.fieldName}Relation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[\`\${${rel.fieldName}Relation.prefix}${relatedModel.fields[0]?.name || 'id'}\`] !== null
      result.${rel.fieldName} = hasData ? {
${relatedFields}
      } : null
    }`
        }

        // One-to-many relation (fetched separately)
        if (rel.isArray) {
          const pkField = this.getPrimaryKeyField(model)
          const foreignKeyField = this.getForeignKeyForRelation(relatedModel, model.name)
          return dedent`const ${rel.fieldName}Relation = relations.find(r => r.field === '${rel.fieldName}' && r.type === 'many')
    if (${rel.fieldName}Relation && relatedData['${rel.fieldName}']) {
      result.${rel.fieldName} = relatedData['${rel.fieldName}'].filter((r: any) => r['${foreignKeyField}'] === result.${pkField}) || []
    }`
        }

        return ''
      })
      .filter(Boolean)
      .join('\n\n')

    return logic || '// No supported relations to transform'
  }

  /**
   * Get the foreign key field name that points from sourceModel to targetModelName
   */
  private getForeignKeyForRelation(sourceModel: ModelAST, targetModelName: string): string {
    const relation = this.getModelRelations(sourceModel).find(
      (r) => r.relatedModel === targetModelName && r.foreignKeyField,
    )
    return relation?.foreignKeyField || 'id'
  }

  /**
   * Find the table name for a given model name
   */
  private findModelByName(modelName: string): ModelAST | undefined {
    return this.schemaAST.models.find((m) => m.name === modelName)
  }

  /**
   * Generate logic to fetch one-to-many relations separately
   */
  private generateFetchManyRelationsLogic(model: ModelAST): string {
    const relations = this.getModelRelations(model).filter((r) => r.isArray)
    if (relations.length === 0) return '// No one-to-many relations'

    const pkField = this.getPrimaryKeyField(model)

    const fetchLogic = relations
      .map((rel) => {
        const relatedModel = this.findModelByName(rel.relatedModel)
        if (!relatedModel) return ''

        const relatedTableName = this.getTableName(relatedModel)
        const foreignKeyField = this.getForeignKeyForRelation(relatedModel, model.name)

        // Generate field transformation for the related model
        const relatedFieldTransforms = relatedModel.fields
          .filter((f) => !this.getModelRelations(relatedModel).some((r) => r.fieldName === f.name))
          .map((f) => {
            const transformation = this.generateFieldValueTransformation(f, `row.${f.name}`, true)
            return `${f.name}: ${transformation}`
          })
          .join(',\n')

        return dedent.withOptions({ alignValues: true })`
          // Fetch ${rel.fieldName} relation
          const ${rel.fieldName}Relation = manyRelations.find(r => r.field === '${rel.fieldName}')
          if (${rel.fieldName}Relation) {
            const parentIds = results.map(r => r.${pkField})
            const ${rel.fieldName}Results = await this.kysely
              .selectFrom('${relatedTableName}')
              .selectAll()
              .where('${foreignKeyField}', 'in', parentIds)
              .execute()

            relatedData['${rel.fieldName}'] = ${rel.fieldName}Results.map((row: any) => ({
              ${relatedFieldTransforms}
            }))
          }
        `
      })
      .filter(Boolean)
      .join('\n\n')

    return fetchLogic || '// No one-to-many relations to fetch'
  }
}
