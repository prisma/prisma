/**
 * Refract client code generator with FieldTranslator integration.
 *
 * Emits client modules ahead of time with database-specific field transformations
 * using the @refract/field-translator system for zero runtime overhead.
 */

import type { FieldAST, ModelAST, SchemaAST } from '@refract/schema-parser'
import {
  createFieldTranslator,
  detectDialect,
  type DatabaseDialect,
  type RefractConfig,
} from '@refract/field-translator'

export interface ClientGeneratorOptions {
  /** Database dialect for transformations */
  dialect?: DatabaseDialect
  /** Configuration for dialect detection */
  config?: RefractConfig
  /** Include TypeScript type definitions in output */
  includeTypes?: boolean
  /** Include JSDoc comments for better IDE experience */
  includeJSDoc?: boolean
  /** Target ES module syntax (default: true) */
  esModules?: boolean
}

export class ClientGenerator {
  private dialect: DatabaseDialect
  private fieldTranslator: ReturnType<typeof createFieldTranslator>

  constructor(
    private schemaAST: SchemaAST,
    private options: ClientGeneratorOptions = {},
  ) {
    // Detect or use provided dialect
    this.dialect = this.detectDialect()
    this.fieldTranslator = createFieldTranslator(this.dialect)
  }

  private detectDialect(): DatabaseDialect {
    if (this.options.dialect) {
      return this.options.dialect
    }
    
    if (this.options.config) {
      return detectDialect(this.options.config)
    }
    
    // Default to SQLite for compatibility
    return 'sqlite'
  }

  /**
   * Generate complete client module with generated model operations.
   */
  generateClientModule(): string {
    const { includeTypes = true, includeJSDoc = true, esModules = true } = this.options

    const imports = this.generateImports(esModules)
    const typeDefinitions = includeTypes ? this.generateTypeDefinitions() : ''
    const modelOperations = this.generateModelOperationsBlock()
    const clientClass = this.generateClientClass()
    const factoryFunction = this.generateClientFactory()

    return [
      this.generateFileHeader(),
      imports,
      typeDefinitions,
      modelOperations,
      clientClass,
      factoryFunction,
    ].filter(Boolean).join('\n\n')
  }

  private generateFileHeader(): string {
    return `/**
 * Generated Refract Client Module
 * 
 * Database dialect: ${this.dialect}
 * Generated transformations with zero runtime overhead
 * 
 * Do not edit this file manually - regenerate with \`refract generate\`
 * Generated at: ${new Date().toISOString()}
 */`
  }

  private generateImports(esModules: boolean): string {
    const importStyle = esModules ? 'import' : 'const'
    const fromStyle = esModules ? 'from' : '= require'

    // Import model types from models.d.ts
    const modelTypeNames = this.schemaAST.models.map(m => m.name).join(', ')

    return `${importStyle} { RefractClientBase } ${fromStyle} '@refract/client'
${importStyle} { createKyselyDialect, loadRefractConfig } ${fromStyle} '@refract/config'
${importStyle} { Kysely } ${fromStyle} 'kysely'
${importStyle} type { Dialect } ${fromStyle} 'kysely'
${importStyle} type { ${modelTypeNames} } ${fromStyle} './models'`
  }

  private generateTypeDefinitions(): string {
    const databaseSchema = this.generateDatabaseSchemaInterface()

    return `// Model types imported from models.d.ts

${databaseSchema}

// CRUD Operation Interfaces
${this.generateCRUDInterfaces()}`
  }

  private generateModelInterface(model: ModelAST): string {
    const fields = model.fields.map(field => {
      const optional = field.isOptional ? '?' : ''
      const fieldType = this.mapFieldTypeToTS(field)
      const listSuffix = field.isList ? '[]' : ''
      return `  ${field.name}${optional}: ${fieldType}${listSuffix}`
    }).join('\n')

    return `export interface ${model.name} {
${fields}
}`
  }

  private generateDatabaseSchemaInterface(): string {
    const tableTypes = this.schemaAST.models.map(model => {
      const tableName = this.getTableName(model)
      return `  ${tableName}: ${model.name}`
    }).join('\n')

    return `export interface DatabaseSchema {
${tableTypes}
  [modelName: string]: Record<string, any>
}`
  }

  private generateCRUDInterfaces(): string {
    // Generate relation include types
    const relationIncludeTypes = this.schemaAST.models.map(model => {
      const relations = this.getModelRelations(model)
      if (relations.length === 0) return ''

      const includeFields = relations.map(rel => `  ${rel.fieldName}?: boolean`).join('\n')
      return `export interface ${model.name}Include {
${includeFields}
}`
    }).filter(Boolean).join('\n\n')

    return `${relationIncludeTypes ? relationIncludeTypes + '\n\n' : ''}export interface ModelCRUDOperations<T, TInclude = any> {
  findMany(args?: { where?: Partial<T>; orderBy?: any; take?: number; skip?: number; include?: TInclude }): Promise<T[]>
  findUnique(args: { where: Partial<T>; include?: TInclude }): Promise<T | undefined>
  findFirst(args?: { where?: Partial<T>; orderBy?: any; include?: TInclude }): Promise<T | null>
  create(args: { data: any }): Promise<T>
  createMany(args: { data: any[] }): Promise<{ count: number }>
  update(args: { where: Partial<T>; data: any }): Promise<T>
  updateMany(args: { where?: Partial<T>; data: any }): Promise<{ count: number }>
  upsert(args: { where: Partial<T>; create: any; update: any }): Promise<T>
  delete(args: { where: Partial<T> }): Promise<T>
  deleteMany(args?: { where?: Partial<T> }): Promise<{ count: number }>
  count(args?: { where?: Partial<T> }): Promise<number>
}`
  }

  private generateModelOperationsBlock(): string {
    const operationClasses = this.schemaAST.models.map((model) => this.generateModelOperations(model))

    const factoryEntries = this.schemaAST.models
      .map((model) => `  ${this.toCamelCase(model.name)}: new ${model.name}Operations(kysely)`).join(',\n')

    const factory = `const createModelOperations = (kysely: Kysely<DatabaseSchema>) => ({\n${factoryEntries}\n})`

    return [...operationClasses, factory].join('\n\n')
  }

  private generateModelOperations(model: ModelAST): string {
    const className = `${model.name}Operations`
    const tableName = this.getTableName(model)
    const includeType = `${model.name}Include`

    return `/**
 * Generated operations for ${model.name} model
 * All field transformations are embedded at generation time for ${this.dialect}
 */
class ${className} implements ModelCRUDOperations<${model.name}, ${includeType}> {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  async findMany(args?: { where?: Partial<${model.name}>; orderBy?: any; take?: number; skip?: number; include?: ${includeType} }): Promise<${model.name}[]> {
    let query = this.kysely.selectFrom('${tableName}')

    // Apply includes (joins) if specified
    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }

    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations(results, includesApplied.relations)
      return results.map(row => this.transformSelectResultWithIncludes(row, includesApplied.relations, relatedData))
    }

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique(args: { where: Partial<${model.name}>; include?: ${includeType} }): Promise<${model.name} | undefined> {
    let query = this.kysely.selectFrom('${tableName}')

    const includesApplied = args.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = this.applyWhereConditions(query, args.where)
    const results = await query.execute()

    if (results.length === 0) return undefined

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async findFirst(args?: { where?: Partial<${model.name}>; orderBy?: any; include?: ${includeType} }): Promise<${model.name} | null> {
    let query = this.kysely.selectFrom('${tableName}')

    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }

    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async create(args: { data: any }): Promise<${model.name}> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('${tableName}')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: { data: any[] }): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('${tableName}')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: { where: Partial<${model.name}>; data: any }): Promise<${model.name}> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('${tableName}').set(prepared as any)
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: { where?: Partial<${model.name}>; data: any }): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('${tableName}').set(prepared as any)
    
    if (args.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: { where: Partial<${model.name}>; create: any; update: any }): Promise<${model.name}> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('${tableName}')
      .values(createData as any)
      .onConflict(oc => oc.column('${this.getPrimaryKeyField(model)}').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: { where: Partial<${model.name}> }): Promise<${model.name}> {
    let query = this.kysely.deleteFrom('${tableName}')
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: { where?: Partial<${model.name}> }): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('${tableName}')
    
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: { where?: Partial<${model.name}> }): Promise<number> {
    let query = this.kysely
      .selectFrom('${tableName}')
      .select(eb => eb.fn.count('id').as('count'))
      
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private applyWhereConditions(query: any, where: Record<string, unknown>): any {
    let currentQuery = query

    for (const [field, value] of Object.entries(where)) {
      const qualifiedField = '${tableName}.' + field
      if (value === null) {
        currentQuery = currentQuery.where(qualifiedField, 'is', null)
      } else if (typeof value === 'object' && value !== null) {
        // Handle complex where conditions
        for (const [operator, operatorValue] of Object.entries(value)) {
          switch (operator) {
            case 'gt':
              currentQuery = currentQuery.where(qualifiedField, '>', this.transformWhereValue(field, operatorValue))
              break
            case 'gte':
              currentQuery = currentQuery.where(qualifiedField, '>=', this.transformWhereValue(field, operatorValue))
              break
            case 'lt':
              currentQuery = currentQuery.where(qualifiedField, '<', this.transformWhereValue(field, operatorValue))
              break
            case 'lte':
              currentQuery = currentQuery.where(qualifiedField, '<=', this.transformWhereValue(field, operatorValue))
              break
            case 'not':
              currentQuery = currentQuery.where(qualifiedField, '!=', this.transformWhereValue(field, operatorValue))
              break
            case 'in':
              currentQuery = currentQuery.where(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'notIn':
              currentQuery = currentQuery.where(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'contains':
              currentQuery = currentQuery.where(qualifiedField, 'like', \`%\${operatorValue}%\`)
              break
            case 'startsWith':
              currentQuery = currentQuery.where(qualifiedField, 'like', \`\${operatorValue}%\`)
              break
            case 'endsWith':
              currentQuery = currentQuery.where(qualifiedField, 'like', \`%\${operatorValue}\`)
              break
          }
        }
      } else {
        currentQuery = currentQuery.where(qualifiedField, '=', this.transformWhereValue(field, value))
      }
    }

    return currentQuery
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
    ${this.generateFieldTransformationMethods(model, 'where')}
  }

  private prepareCreateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    ${this.generateFieldTransformationMethods(model, 'create')}
    
    return prepared
  }

  private prepareUpdateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    ${this.generateFieldTransformationMethods(model, 'update')}
    
    return prepared
  }

  private transformSelectResult(row: any): ${model.name} {
    const result: any = {}

    ${this.generateFieldTransformationMethods(model, 'select')}

    return result
  }

  private applyIncludes(query: any, include: ${includeType}): { query: any; relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> } | null {
    if (!include || Object.keys(include).length === 0) return null

    const relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> = []
    let currentQuery = query

    ${this.generateIncludeApplicationLogic(model)}

    return { query: currentQuery, relations }
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    ${this.generateFetchManyRelationsLogic(model)}

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): ${model.name} {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    ${this.generateIncludeTransformationLogic(model)}

    return result
  }
}`
  }

  private generateFieldTransformationMethods(model: ModelAST, operation: 'create' | 'update' | 'where' | 'select'): string {
    // Get list of model names to detect relation fields
    const modelNames = new Set(this.schemaAST.models.map(m => m.name))

    const transformations = model.fields.map(field => {
      // Skip relation fields - they're not actual database columns
      if (modelNames.has(field.fieldType)) {
        return null
      }

      // Skip certain fields in updates
      if (operation === 'update' && (field.name === 'id' || field.name === 'createdAt')) {
        return null
      }

      // Use FieldTranslator to generate transformation code
      const fieldAnalysis = this.fieldTranslator.analyzeField(field)
      const transformation = fieldAnalysis.transformations.get(operation)
      
      if (!transformation) {
        // Generate basic fallback transformation for common types
        return this.generateFallbackTransformation(field, operation)
      }

      switch (operation) {
        case 'where':
          return `    if (fieldName === '${field.name}') {
      return ${transformation.code.replaceAll('data.' + field.name, 'value')}
    }`
        
        case 'create':
        case 'update':
          return `    if (data.${field.name} !== undefined) {
      prepared.${field.name} = ${transformation.code}
    }`
        
        case 'select':
          return `    result.${field.name} = ${transformation.code.replaceAll('data.' + field.name, 'row.' + field.name)}`
      }
    }).filter(Boolean)

    // Add timestamp handling for create/update
    if (operation === 'create' || operation === 'update') {
      const timestampLogic = this.generateTimestampLogic(model, operation)
      transformations.push(timestampLogic)
    }

    // Add fallback for where operation
    if (operation === 'where') {
      transformations.push('    return value // No transformation needed for this field')
    }

    return transformations.join('\n    \n')
  }

  private generateFallbackTransformation(field: FieldAST, operation: 'create' | 'update' | 'where' | 'select'): string {
    const whereTransform = this.generateFieldValueTransformation(field, 'value', false)

    switch (operation) {
      case 'where':
        return `    if (fieldName === '${field.name}') {
      return ${whereTransform}
    }`

      case 'create':
      case 'update':
        return `    if (data.${field.name} !== undefined) {
      prepared.${field.name} = ${this.generateFieldValueTransformation(field, `data.${field.name}`)}
    }`

      case 'select':
        return `    result.${field.name} = ${this.generateFieldValueTransformation(field, `row.${field.name}`, true)}`
    }
  }

  private generateFieldValueTransformation(field: FieldAST, variableName: string, isFromDatabase = false): string {
    // Handle optional fields with null check
    const isOptional = field.isOptional

    // Generate database-specific transformations based on dialect
    switch (field.fieldType) {
      case 'Boolean':
        if (this.dialect === 'sqlite') {
          return isFromDatabase
            ? `${variableName} === 1`
            : `${variableName} ? 1 : 0`
        }
        return variableName

      case 'DateTime':
        if (isFromDatabase) {
          return `new Date(${variableName} as any)`
        }
        return `${variableName} instanceof Date ? ${variableName} : new Date(${variableName} as any)`

      case 'Int':
      case 'Float':
        return `Number(${variableName})`

      case 'String':
        if (isOptional && !isFromDatabase) {
          return `${variableName} !== null ? String(${variableName}) : null`
        }
        return `String(${variableName})`
      
      case 'BigInt':
        if (this.dialect === 'sqlite') {
          return isFromDatabase 
            ? `BigInt(${variableName})` 
            : `String(${variableName})`
        }
        return variableName
      
      case 'Json':
        return isFromDatabase 
          ? `JSON.parse(${variableName})` 
          : `JSON.stringify(${variableName})`
      
      default:
        return variableName
    }
  }

  private generateTimestampLogic(model: ModelAST, operation: 'create' | 'update'): string {
    const hasCreatedAt = model.fields.some(f => f.name === 'createdAt')
    const hasUpdatedAt = model.fields.some(f => f.name === 'updatedAt')
    
    let logic = ''
    
    if (operation === 'create' && hasCreatedAt) {
      logic += `    // Auto-generated createdAt timestamp
    prepared.createdAt = new Date().toISOString()\n`
    }
    
    if (hasUpdatedAt) {
      logic += `    // Auto-generated updatedAt timestamp
    prepared.updatedAt = new Date().toISOString()\n`
    }
    
    return logic
  }

  private generateClientClass(): string {
    const modelDeclarations = this.schemaAST.models
      .map((model) => `  declare readonly ${this.toCamelCase(model.name)}: ${model.name}Operations`)
      .join('\n')

    const declarationsBlock = modelDeclarations.length > 0 ? `${modelDeclarations}\n` : ''

    return `/**
 * Refract Client with pre-compiled operations
 * Database dialect: ${this.dialect}
 * No runtime schema parsing - all model operations are embedded at generation time
 */
export class RefractClient extends RefractClientBase<DatabaseSchema> {
${declarationsBlock}  constructor(dialect: Dialect) {
    super(dialect, { modelFactory: createModelOperations })
  }
}`
  }

  private generateClientFactory(): string {
    return `/**
 * Factory function for creating RefractClient instances
 */
export function createRefractClient(dialect: Dialect): RefractClient {
  return new RefractClient(dialect)
}

/**
 * Convenience factory function that automatically loads configuration
 * This is the main entry point used by the generated client
 */
export async function createClient(): Promise<RefractClient> {
  const { config } = await loadRefractConfig()
  const dialect = await createKyselyDialect(config)
  return new RefractClient(dialect)
}`
  }

  private mapFieldTypeToTS(field: FieldAST): string {
    switch (field.fieldType) {
      case 'String': return 'string'
      case 'Int': return 'number'
      case 'Float': return 'number'
      case 'Boolean': return 'boolean'
      case 'DateTime': return 'Date'
      case 'Json': return 'any'
      case 'BigInt': return 'bigint'
      default: return 'any'
    }
  }

  private getTableName(model: ModelAST): string {
    // Check for @@map attribute
    const mapAttribute = model.attributes.find(attr => attr.name === 'map')
    if (mapAttribute && mapAttribute.args[0]) {
      return String(mapAttribute.args[0].value)
    }
    // Default: use model name as-is (Prisma's default)
    return model.name
  }

  private getPrimaryKeyField(model: ModelAST): string {
    const pkField = model.fields.find(field => 
      field.attributes.some(attr => attr.name === 'id')
    )
    return pkField ? pkField.name : 'id'
  }

  private toCamelCase(str: string): string {
    return str.charAt(0).toLowerCase() + str.slice(1)
  }

  /**
   * Extract relation metadata from a model
   */
  private getModelRelations(model: ModelAST): Array<{
    fieldName: string
    relatedModel: string
    isArray: boolean
    foreignKeyField?: string
    referencedField?: string
  }> {
    const modelNames = new Set(this.schemaAST.models.map(m => m.name))

    return model.fields
      .filter(field => {
        // A field is a relation if its type references another model
        return modelNames.has(field.fieldType)
      })
      .map(field => {
        const relationAttr = field.attributes.find(attr => attr.name === 'relation')

        // Extract foreign key information from @relation attribute
        let foreignKeyField: string | undefined
        let referencedField: string | undefined

        if (relationAttr) {
          const fieldsArg = relationAttr.args.find(arg => arg.name === 'fields')
          const referencesArg = relationAttr.args.find(arg => arg.name === 'references')

          if (fieldsArg && Array.isArray(fieldsArg.value)) {
            foreignKeyField = fieldsArg.value[0] as string
          }

          if (referencesArg && Array.isArray(referencesArg.value)) {
            referencedField = referencesArg.value[0] as string
          }
        }

        return {
          fieldName: field.name,
          relatedModel: field.fieldType,
          isArray: field.isList,
          foreignKeyField,
          referencedField,
        }
      })
  }

  /**
   * Generate logic to apply includes (joins) to a query
   */
  private generateIncludeApplicationLogic(model: ModelAST): string {
    const relations = this.getModelRelations(model)
    if (relations.length === 0) return '// No relations for this model'

    const logic = relations.map(rel => {
      const relatedModel = this.findModelByName(rel.relatedModel)
      if (!relatedModel) return ''

      const relatedTableName = this.getTableName(relatedModel)
      const prefix = `${rel.fieldName}_`

      // Forward relation: this model has the FK
      if (rel.foreignKeyField && rel.referencedField && !rel.isArray) {
        const relatedFields = relatedModel.fields
          .filter(f => !this.getModelRelations(relatedModel).some(r => r.fieldName === f.name))
          .map(f => `'${relatedTableName}.${f.name} as ${prefix}${f.name}'`)
          .join(', ')

        return `    if (include.${rel.fieldName}) {
      currentQuery = currentQuery
        .leftJoin('${relatedTableName}', '${this.getTableName(model)}.${rel.foreignKeyField}', '${relatedTableName}.${rel.referencedField}')
        .selectAll('${this.getTableName(model)}')
        .select([
          ${relatedFields}
        ])
      relations.push({ field: '${rel.fieldName}', relatedModel: '${rel.relatedModel}', prefix: '${prefix}', type: 'one' })
    }`
      }

      // Reverse relation: related model has the FK pointing to us
      if (!rel.foreignKeyField && !rel.isArray) {
        // Find the reverse relation on the related model
        const reverseRelation = this.getModelRelations(relatedModel).find(r =>
          r.relatedModel === model.name && r.foreignKeyField
        )

        if (reverseRelation) {
          const relatedFields = relatedModel.fields
            .filter(f => !this.getModelRelations(relatedModel).some(r => r.fieldName === f.name))
            .map(f => `'${relatedTableName}.${f.name} as ${prefix}${f.name}'`)
            .join(', ')

          return `    if (include.${rel.fieldName}) {
      currentQuery = currentQuery
        .leftJoin('${relatedTableName}', '${this.getTableName(model)}.${reverseRelation.referencedField}', '${relatedTableName}.${reverseRelation.foreignKeyField}')
        .selectAll('${this.getTableName(model)}')
        .select([
          ${relatedFields}
        ])
      relations.push({ field: '${rel.fieldName}', relatedModel: '${rel.relatedModel}', prefix: '${prefix}', type: 'one' })
    }`
        }
      }

      // One-to-many relation: fetch related records separately to avoid N+1
      if (rel.isArray) {
        return `    if (include.${rel.fieldName}) {
      relations.push({ field: '${rel.fieldName}', relatedModel: '${rel.relatedModel}', prefix: '${prefix}', type: 'many' })
    }`
      }

      return ''
    }).filter(Boolean).join('\n\n')

    return logic || '// No supported relations for includes'
  }

  /**
   * Generate logic to transform flat joined rows into nested objects
   */
  private generateIncludeTransformationLogic(model: ModelAST): string {
    const relations = this.getModelRelations(model)
    if (relations.length === 0) return '// No relations to transform'

    const logic = relations.map(rel => {
      const relatedModel = this.findModelByName(rel.relatedModel)
      if (!relatedModel) return ''

      // One-to-one relation (joined inline)
      if (!rel.isArray) {
        const relatedFields = relatedModel.fields
          .filter(f => !this.getModelRelations(relatedModel).some(r => r.fieldName === f.name))
          .map(f => {
            const transformation = this.generateFieldValueTransformation(f, `row.${rel.fieldName}_${f.name}`, true)
            return `      ${f.name}: ${transformation}`
          })
          .join(',\n')

        return `    const ${rel.fieldName}Relation = relations.find(r => r.field === '${rel.fieldName}' && r.type === 'one')
    if (${rel.fieldName}Relation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[\`\${${rel.fieldName}Relation.prefix}${relatedModel.fields[0]?.name || 'id'}\`] !== null
      result.${rel.fieldName} = hasData ? {
${relatedFields}
      } : null
    }`
      }

      // One-to-many relation (fetched separately)
      if (rel.isArray) {
        const pkField = this.getPrimaryKeyField(model)
        const foreignKeyField = this.getForeignKeyForRelation(relatedModel, model.name)
        return `    const ${rel.fieldName}Relation = relations.find(r => r.field === '${rel.fieldName}' && r.type === 'many')
    if (${rel.fieldName}Relation && relatedData['${rel.fieldName}']) {
      result.${rel.fieldName} = relatedData['${rel.fieldName}'].filter((r: any) => r['${foreignKeyField}'] === result.${pkField}) || []
    }`
      }

      return ''
    }).filter(Boolean).join('\n\n')

    return logic || '// No supported relations to transform'
  }

  /**
   * Get the foreign key field name that points from sourceModel to targetModelName
   */
  private getForeignKeyForRelation(sourceModel: ModelAST, targetModelName: string): string {
    const relation = this.getModelRelations(sourceModel).find(r =>
      r.relatedModel === targetModelName && r.foreignKeyField
    )
    return relation?.foreignKeyField || 'id'
  }

  /**
   * Find the table name for a given model name
   */
  private findModelByName(modelName: string): ModelAST | undefined {
    return this.schemaAST.models.find(m => m.name === modelName)
  }

  /**
   * Generate logic to fetch one-to-many relations separately
   */
  private generateFetchManyRelationsLogic(model: ModelAST): string {
    const relations = this.getModelRelations(model).filter(r => r.isArray)
    if (relations.length === 0) return '// No one-to-many relations'

    const pkField = this.getPrimaryKeyField(model)

    const fetchLogic = relations.map(rel => {
      const relatedModel = this.findModelByName(rel.relatedModel)
      if (!relatedModel) return ''

      const relatedTableName = this.getTableName(relatedModel)
      const foreignKeyField = this.getForeignKeyForRelation(relatedModel, model.name)

      // Generate field transformation for the related model
      const relatedFieldTransforms = relatedModel.fields
        .filter(f => !this.getModelRelations(relatedModel).some(r => r.fieldName === f.name))
        .map(f => {
          const transformation = this.generateFieldValueTransformation(f, `row.${f.name}`, true)
          return `      ${f.name}: ${transformation}`
        })
        .join(',\n')

      return `    // Fetch ${rel.fieldName} relation
    const ${rel.fieldName}Relation = manyRelations.find(r => r.field === '${rel.fieldName}')
    if (${rel.fieldName}Relation) {
      const parentIds = results.map(r => r.${pkField})
      const ${rel.fieldName}Results = await this.kysely
        .selectFrom('${relatedTableName}')
        .selectAll()
        .where('${foreignKeyField}', 'in', parentIds)
        .execute()

      relatedData['${rel.fieldName}'] = ${rel.fieldName}Results.map((row: any) => ({
${relatedFieldTransforms}
      }))
    }`
    }).filter(Boolean).join('\n\n')

    return fetchLogic || '// No one-to-many relations to fetch'
  }
}
