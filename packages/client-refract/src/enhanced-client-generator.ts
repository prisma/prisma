/**
 * Enhanced TypeScript Client Generator with FieldTranslator Integration
 * 
 * Generates pre-compiled model operations with database-specific field transformations
 * using the @refract/field-translator system for zero runtime overhead.
 */

import type { FieldAST, ModelAST, SchemaAST } from '@refract/schema-parser'
import { 
  createFieldTranslator, 
  detectDialect, 
  type DatabaseDialect,
  type RefractConfig 
} from '@refract/field-translator'

export interface EnhancedGenerationOptions {
  /** Database dialect for transformations */
  dialect?: DatabaseDialect
  /** Configuration for dialect detection */
  config?: RefractConfig
  /** Include TypeScript type definitions in output */
  includeTypes?: boolean
  /** Include JSDoc comments for better IDE experience */
  includeJSDoc?: boolean
  /** Target ES module syntax (default: true) */
  esModules?: boolean
}

export class EnhancedClientGeneratorWithTranslations {
  private dialect: DatabaseDialect
  private fieldTranslator: ReturnType<typeof createFieldTranslator>

  constructor(
    private schemaAST: SchemaAST, 
    private options: EnhancedGenerationOptions = {}
  ) {
    // Detect or use provided dialect
    this.dialect = this.detectDialect()
    this.fieldTranslator = createFieldTranslator(this.dialect)
  }

  private detectDialect(): DatabaseDialect {
    if (this.options.dialect) {
      return this.options.dialect
    }
    
    if (this.options.config) {
      return detectDialect(this.options.config)
    }
    
    // Default to SQLite for compatibility
    return 'sqlite'
  }

  /**
   * Generate complete client with pre-compiled model operations using FieldTranslator
   */
  generateEnhancedClient(): string {
    const { includeTypes = true, includeJSDoc = true, esModules = true } = this.options

    const imports = this.generateImports(esModules)
    const typeDefinitions = includeTypes ? this.generateTypeDefinitions() : ''
    const modelOperations = this.generatePreCompiledOperations()
    const clientClass = this.generateEnhancedClientClass()
    const factoryFunction = this.generateClientFactory()

    return [
      this.generateFileHeader(),
      imports,
      typeDefinitions,
      modelOperations,
      clientClass,
      factoryFunction,
    ].filter(Boolean).join('\n\n')
  }

  private generateFileHeader(): string {
    return `/**
 * Generated Refract Client with Pre-compiled Operations
 * 
 * Database dialect: ${this.dialect}
 * Generated transformations with zero runtime overhead
 * 
 * Do not edit this file manually - regenerate with \`refract generate\`
 * Generated at: ${new Date().toISOString()}
 */`
  }

  private generateImports(esModules: boolean): string {
    const importStyle = esModules ? 'import' : 'const'
    const fromStyle = esModules ? 'from' : '= require'
    
    return `${importStyle} { createKyselyDialect, loadRefractConfig } ${fromStyle} '@refract/config'
${importStyle} { Kysely } ${fromStyle} 'kysely'
${importStyle} type { Dialect } ${fromStyle} 'kysely'`
  }

  private generateTypeDefinitions(): string {
    const modelTypes = this.schemaAST.models.map(model => this.generateModelInterface(model)).join('\n\n')
    const databaseSchema = this.generateDatabaseSchemaInterface()
    
    return `// Generated TypeScript Interfaces
${modelTypes}

${databaseSchema}

// CRUD Operation Interfaces
${this.generateCRUDInterfaces()}`
  }

  private generateModelInterface(model: ModelAST): string {
    const fields = model.fields.map(field => {
      const optional = field.isOptional ? '?' : ''
      const fieldType = this.mapFieldTypeToTS(field)
      const listSuffix = field.isList ? '[]' : ''
      return `  ${field.name}${optional}: ${fieldType}${listSuffix}`
    }).join('\n')

    return `export interface ${model.name} {
${fields}
}`
  }

  private generateDatabaseSchemaInterface(): string {
    const tableTypes = this.schemaAST.models.map(model => {
      const tableName = this.getTableName(model)
      return `  ${tableName}: ${model.name}`
    }).join('\n')

    return `export interface DatabaseSchema {
${tableTypes}
}`
  }

  private generateCRUDInterfaces(): string {
    return `export interface ModelCRUDOperations<T> {
  findMany(args?: { where?: Partial<T>; orderBy?: any; take?: number; skip?: number }): Promise<T[]>
  findUnique(args: { where: Partial<T> }): Promise<T | undefined>
  findFirst(args?: { where?: Partial<T>; orderBy?: any }): Promise<T | null>
  create(args: { data: any }): Promise<T>
  createMany(args: { data: any[] }): Promise<{ count: number }>
  update(args: { where: Partial<T>; data: any }): Promise<T>
  updateMany(args: { where?: Partial<T>; data: any }): Promise<{ count: number }>
  upsert(args: { where: Partial<T>; create: any; update: any }): Promise<T>
  delete(args: { where: Partial<T> }): Promise<T>
  deleteMany(args?: { where?: Partial<T> }): Promise<{ count: number }>
  count(args?: { where?: Partial<T> }): Promise<number>
}`
  }

  private generatePreCompiledOperations(): string {
    return this.schemaAST.models.map(model => this.generateModelOperations(model)).join('\n\n')
  }

  private generateModelOperations(model: ModelAST): string {
    const className = `${model.name}Operations`
    const tableName = this.getTableName(model)
    
    return `/**
 * Pre-compiled operations for ${model.name} model
 * All field transformations are embedded at generation time for ${this.dialect}
 */
class ${className} implements ModelCRUDOperations<${model.name}> {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  async findMany(args?: { where?: Partial<${model.name}>; orderBy?: any; take?: number; skip?: number }): Promise<${model.name}[]> {
    let query = this.kysely.selectFrom('${tableName}').selectAll()
    
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }
    
    if (args?.skip) {
      query = query.offset(args.skip)
    }
    
    if (args?.take) {
      query = query.limit(args.take)
    }
    
    const results = await query.execute()
    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique(args: { where: Partial<${model.name}> }): Promise<${model.name} | undefined> {
    let query = this.kysely.selectFrom('${tableName}').selectAll()
    query = this.applyWhereConditions(query, args.where)
    const results = await query.execute()
    return results.length > 0 ? this.transformSelectResult(results[0]) : undefined
  }

  async findFirst(args?: { where?: Partial<${model.name}>; orderBy?: any }): Promise<${model.name} | null> {
    let query = this.kysely.selectFrom('${tableName}').selectAll()
    
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }
    
    query = query.limit(1)
    const results = await query.execute()
    return results.length > 0 ? this.transformSelectResult(results[0]) : null
  }

  async create(args: { data: any }): Promise<${model.name}> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('${tableName}')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: { data: any[] }): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('${tableName}')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: { where: Partial<${model.name}>; data: any }): Promise<${model.name}> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('${tableName}').set(prepared as any)
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: { where?: Partial<${model.name}>; data: any }): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('${tableName}').set(prepared as any)
    
    if (args.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: { where: Partial<${model.name}>; create: any; update: any }): Promise<${model.name}> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('${tableName}')
      .values(createData as any)
      .onConflict(oc => oc.column('${this.getPrimaryKeyField(model)}').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: { where: Partial<${model.name}> }): Promise<${model.name}> {
    let query = this.kysely.deleteFrom('${tableName}')
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: { where?: Partial<${model.name}> }): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('${tableName}')
    
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: { where?: Partial<${model.name}> }): Promise<number> {
    let query = this.kysely
      .selectFrom('${tableName}')
      .select(eb => eb.fn.count('id').as('count'))
      
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private applyWhereConditions(query: any, where: Record<string, unknown>): any {
    let currentQuery = query
    
    for (const [field, value] of Object.entries(where)) {
      if (value === null) {
        currentQuery = currentQuery.where(field, 'is', null)
      } else if (typeof value === 'object' && value !== null) {
        // Handle complex where conditions
        for (const [operator, operatorValue] of Object.entries(value)) {
          switch (operator) {
            case 'gt':
              currentQuery = currentQuery.where(field, '>', this.transformWhereValue(field, operatorValue))
              break
            case 'gte':
              currentQuery = currentQuery.where(field, '>=', this.transformWhereValue(field, operatorValue))
              break
            case 'lt':
              currentQuery = currentQuery.where(field, '<', this.transformWhereValue(field, operatorValue))
              break
            case 'lte':
              currentQuery = currentQuery.where(field, '<=', this.transformWhereValue(field, operatorValue))
              break
            case 'not':
              currentQuery = currentQuery.where(field, '!=', this.transformWhereValue(field, operatorValue))
              break
            case 'in':
              currentQuery = currentQuery.where(field, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'notIn':
              currentQuery = currentQuery.where(field, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'contains':
              currentQuery = currentQuery.where(field, 'like', \`%\${operatorValue}%\`)
              break
            case 'startsWith':
              currentQuery = currentQuery.where(field, 'like', \`\${operatorValue}%\`)
              break
            case 'endsWith':
              currentQuery = currentQuery.where(field, 'like', \`%\${operatorValue}\`)
              break
          }
        }
      } else {
        currentQuery = currentQuery.where(field, '=', this.transformWhereValue(field, value))
      }
    }
    
    return currentQuery
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
    ${this.generateFieldTransformationMethods(model, 'where')}
  }

  private prepareCreateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    ${this.generateFieldTransformationMethods(model, 'create')}
    
    return prepared
  }

  private prepareUpdateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    ${this.generateFieldTransformationMethods(model, 'update')}
    
    return prepared
  }

  private transformSelectResult(row: any): ${model.name} {
    const result: any = {}
    
    ${this.generateFieldTransformationMethods(model, 'select')}
    
    return result
  }
}`
  }

  private generateFieldTransformationMethods(model: ModelAST, operation: 'create' | 'update' | 'where' | 'select'): string {
    const transformations = model.fields.map(field => {
      // Skip certain fields in updates
      if (operation === 'update' && (field.name === 'id' || field.name === 'createdAt')) {
        return null
      }

      // Use FieldTranslator to generate transformation code
      const fieldAnalysis = this.fieldTranslator.analyzeField(field)
      const transformation = fieldAnalysis.transformations.get(operation)
      
      if (!transformation) {
        // Generate basic fallback transformation for common types
        return this.generateFallbackTransformation(field, operation)
      }

      switch (operation) {
        case 'where':
          return `    if (fieldName === '${field.name}') {
      return ${transformation.code.replace('data.' + field.name, 'value')}
    }`
        
        case 'create':
        case 'update':
          return `    if (data.${field.name} !== undefined) {
      prepared.${field.name} = ${transformation.code}
    }`
        
        case 'select':
          return `    result.${field.name} = ${transformation.code.replace('data.' + field.name, 'row.' + field.name)}`
      }
    }).filter(Boolean)

    // Add timestamp handling for create/update
    if (operation === 'create' || operation === 'update') {
      const timestampLogic = this.generateTimestampLogic(model, operation)
      transformations.push(timestampLogic)
    }

    // Add fallback for where operation
    if (operation === 'where') {
      transformations.push('    return value // No transformation needed for this field')
    }

    return transformations.join('\n    \n')
  }

  private generateFallbackTransformation(field: FieldAST, operation: 'create' | 'update' | 'where' | 'select'): string {
    switch (operation) {
      case 'where':
        return `    if (fieldName === '${field.name}') {
      return ${this.generateFieldValueTransformation(field, 'value')}
    }`
      
      case 'create':
      case 'update':
        return `    if (data.${field.name} !== undefined) {
      prepared.${field.name} = ${this.generateFieldValueTransformation(field, `data.${field.name}`)}
    }`
      
      case 'select':
        return `    result.${field.name} = ${this.generateFieldValueTransformation(field, `row.${field.name}`, true)}`
    }
  }

  private generateFieldValueTransformation(field: FieldAST, variableName: string, isFromDatabase = false): string {
    // Generate database-specific transformations based on dialect
    switch (field.fieldType) {
      case 'Boolean':
        if (this.dialect === 'sqlite') {
          return isFromDatabase 
            ? `${variableName} === 1` 
            : `${variableName} ? 1 : 0`
        }
        return variableName
      
      case 'DateTime':
        if (isFromDatabase) {
          return `new Date(${variableName})`
        }
        return `${variableName} instanceof Date ? ${variableName}.toISOString() : new Date(${variableName}).toISOString()`
      
      case 'Int':
      case 'Float':
        return `Number(${variableName})`
      
      case 'String':
        return `String(${variableName})`
      
      case 'BigInt':
        if (this.dialect === 'sqlite') {
          return isFromDatabase 
            ? `BigInt(${variableName})` 
            : `String(${variableName})`
        }
        return variableName
      
      case 'Json':
        return isFromDatabase 
          ? `JSON.parse(${variableName})` 
          : `JSON.stringify(${variableName})`
      
      default:
        return variableName
    }
  }

  private generateTimestampLogic(model: ModelAST, operation: 'create' | 'update'): string {
    const hasCreatedAt = model.fields.some(f => f.name === 'createdAt')
    const hasUpdatedAt = model.fields.some(f => f.name === 'updatedAt')
    
    let logic = ''
    
    if (operation === 'create' && hasCreatedAt) {
      logic += `    // Auto-generated createdAt timestamp
    prepared.createdAt = new Date().toISOString()\n`
    }
    
    if (hasUpdatedAt) {
      logic += `    // Auto-generated updatedAt timestamp
    prepared.updatedAt = new Date().toISOString()\n`
    }
    
    return logic
  }

  private generateEnhancedClientClass(): string {
    const modelProperties = this.schemaAST.models.map(model => {
      const propertyName = this.toCamelCase(model.name)
      return `  readonly ${propertyName}: ${model.name}Operations`
    }).join('\n')

    const modelInitializations = this.schemaAST.models.map(model => {
      const propertyName = this.toCamelCase(model.name)
      return `    this.${propertyName} = new ${model.name}Operations(this.$kysely)`
    }).join('\n')

    return `/**
 * Enhanced Refract Client with pre-compiled operations
 * Database dialect: ${this.dialect}
 * No runtime schema parsing - all model operations are embedded at generation time
 */
export class RefractClient {
  readonly $kysely: Kysely<DatabaseSchema>
${modelProperties}

  constructor(dialect: Dialect) {
    this.$kysely = new Kysely<DatabaseSchema>({ dialect })
    
    // Initialize pre-compiled model operations
${modelInitializations}
  }

  async $connect(): Promise<void> {
    // Kysely handles connections automatically
  }

  async $disconnect(): Promise<void> {
    await this.$kysely.destroy()
  }

  async $transaction<T>(fn: (client: RefractClient) => Promise<T>): Promise<T> {
    return this.$kysely.transaction().execute(async (trx) => {
      // Create transaction client with same operations but different Kysely instance
      const trxClient = Object.create(this)
      Object.defineProperty(trxClient, '$kysely', {
        value: trx,
        writable: false,
        enumerable: false,
        configurable: false,
      })
      return fn(trxClient)
    })
  }
}`
  }

  private generateClientFactory(): string {
    return `/**
 * Factory function for creating RefractClient instances
 */
export function createRefractClient(dialect: Dialect): RefractClient {
  return new RefractClient(dialect)
}

/**
 * Convenience factory function that automatically loads configuration
 * This is the main entry point used by the generated client
 */
export async function createClient(): Promise<RefractClient> {
  const config = await loadRefractConfig()
  const dialect = createKyselyDialect(config.datasource)
  return new RefractClient(dialect)
}`
  }

  private mapFieldTypeToTS(field: FieldAST): string {
    switch (field.fieldType) {
      case 'String': return 'string'
      case 'Int': return 'number'
      case 'Float': return 'number'
      case 'Boolean': return 'boolean'
      case 'DateTime': return 'Date'
      case 'Json': return 'any'
      case 'BigInt': return 'bigint'
      default: return 'any'
    }
  }

  private getTableName(model: ModelAST): string {
    // Check for @@map attribute
    const mapAttribute = model.attributes.find(attr => attr.name === 'map')
    if (mapAttribute && mapAttribute.args[0]) {
      return String(mapAttribute.args[0].value)
    }
    // Default: use model name as-is (Prisma's default)
    return model.name
  }

  private getPrimaryKeyField(model: ModelAST): string {
    const pkField = model.fields.find(field => 
      field.attributes.some(attr => attr.name === 'id')
    )
    return pkField ? pkField.name : 'id'
  }

  private toCamelCase(str: string): string {
    return str.charAt(0).toLowerCase() + str.slice(1)
  }
}