import indent from 'indent-string'

import { ClientModelAction } from '../../runtime/clientActions'
import { DMMF } from '../../runtime/dmmf-types'
import { lowerCase } from '../../runtime/utils/common'
import { GenericArgsInfo } from '../GenericsArgsInfo'
import { getIncludeName, getModelArgName, getSelectName } from '../utils'
import { TAB_SIZE } from './constants'
import type { Generatable } from './Generatable'
import { getArgFieldJSDoc } from './helpers'
import { InputField } from './Input'
import { ifExtensions } from './utils/ifExtensions'

export class ArgsType implements Generatable {
  constructor(
    protected readonly args: DMMF.SchemaArg[],
    protected readonly type: DMMF.OutputType,
    protected readonly genericsInfo: GenericArgsInfo,
    protected readonly action?: ClientModelAction,
  ) {}
  public toTS(): string {
    const { action, args } = this
    const { name } = this.type
    for (const arg of args) {
      arg.comment = getArgFieldJSDoc(this.type, action, arg)
    }

    const selectName = getSelectName(name)

    const argsToGenerate: DMMF.SchemaArg[] = [
      {
        name: 'select',
        isRequired: false,
        isNullable: true,
        inputTypes: [
          {
            type: selectName,
            location: 'inputObjectTypes',
            isList: false,
          },
          {
            type: 'null',
            location: 'scalar',
            isList: false,
          },
        ],
        comment: `Select specific fields to fetch from the ${name}`,
      },
    ]

    const hasRelationField = this.type.fields.some((f) => f.outputType.location === 'outputObjectTypes')

    if (hasRelationField) {
      const includeName = getIncludeName(name)
      argsToGenerate.push({
        name: 'include',
        isRequired: false,
        isNullable: true,
        inputTypes: [
          {
            type: includeName,
            location: 'inputObjectTypes',
            isList: false,
          },
          {
            type: 'null',
            location: 'scalar',
            isList: false,
          },
        ],
        comment: `Choose, which related nodes to fetch as well.`,
      })
    }

    argsToGenerate.push(...args)
    const modelArgName = getModelArgName(name, action)
    if (action === DMMF.ModelAction.findUnique || action === DMMF.ModelAction.findFirst) {
      return this.generateFindMethodArgs(action, name, argsToGenerate, modelArgName)
    } else if (action === 'findFirstOrThrow' || action === 'findUniqueOrThrow') {
      return this.generateFindOrThrowMethodArgs(action, name, modelArgName)
    }

    return `
/**
 * ${name} ${action ? action : 'without action'}
 */
export type ${modelArgName}${ifExtensions('<ExtArgs extends runtime.Types.Extensions.Args = never>', '')} = {
${indent(argsToGenerate.map((arg) => new InputField(arg, false, false, this.genericsInfo).toTS()).join('\n'), TAB_SIZE)}
}
`
  }

  private generateFindMethodArgs(
    action: DMMF.ModelAction.findFirst | DMMF.ModelAction.findUnique,
    name: string,
    argsToGenerate: DMMF.SchemaArg[],
    modelArgName: string,
  ) {
    const baseTypeName = getBaseTypeName(name, action)
    const replacement = action === DMMF.ModelAction.findFirst ? 'findFirstOrThrow' : 'findUniqueOrThrow'

    // we have to use interface for arg type here, since as for TS 4.7.2
    // using BaseType & { rejectOnNotFound } intersection breaks type checking for `select`
    // option
    return `
/**
 * ${name} base type for ${action} actions
 */
export type ${baseTypeName}${ifExtensions('<ExtArgs extends runtime.Types.Extensions.Args = never>', '')} = {
${indent(argsToGenerate.map((arg) => new InputField(arg, false, false, this.genericsInfo).toTS()).join('\n'), TAB_SIZE)}
}

/**
 * ${name}: ${action}
 */
export interface ${modelArgName}${ifExtensions(
      '<ExtArgs extends runtime.Types.Extensions.Args = never>',
      '',
    )} extends ${baseTypeName}${ifExtensions('<ExtArgs>', '')} {
 /**
  * Throw an Error if query returns no results
  * @deprecated since 4.0.0: use \`${replacement}\` method instead
  */
  rejectOnNotFound?: RejectOnNotFound
}
      `
  }

  private generateFindOrThrowMethodArgs(
    action: 'findFirstOrThrow' | 'findUniqueOrThrow',
    name: string,
    modelArgName: string,
  ) {
    // here we are assuming that base type have been already generated by corresponding
    // DMMF actions. At the moment orThrow methods do not have any extra arguments, so arg
    // type is just an alias for a base type
    const baseTypeName = getBaseTypeName(name, action)
    return `
/**
 * ${name}: ${action}
 */
export type ${modelArgName}${ifExtensions(
      '<ExtArgs extends runtime.Types.Extensions.Args = never>',
      '',
    )} = ${baseTypeName}${ifExtensions('<ExtArgs>', '')}
      `
  }
}

export class MinimalArgsType implements Generatable {
  constructor(
    protected readonly args: DMMF.SchemaArg[],
    protected readonly type: DMMF.OutputType,
    protected readonly genericsInfo: GenericArgsInfo,
    protected readonly action?: DMMF.ModelAction,
    protected readonly generatedTypeName = getModelArgName(type.name, action),
  ) {}
  public toTS(): string {
    const { action, args } = this
    const { name } = this.type

    for (const arg of args) {
      arg.comment = getArgFieldJSDoc(this.type, action, arg)
    }

    return `
/**
 * ${name} ${action ? action : 'without action'}
 */
export type ${this.generatedTypeName}${ifExtensions('<ExtArgs extends runtime.Types.Extensions.Args = never>', '')} = {
${indent(
  args
    .map((arg) => {
      const noEnumerable = arg.inputTypes.some((input) => input.type === 'Json') && arg.name === 'pipeline'
      return new InputField(arg, false, noEnumerable, this.genericsInfo).toTS()
    })
    .join('\n'),
  TAB_SIZE,
)}
}
`
  }
}

type ActionWithBaseType =
  | DMMF.ModelAction.findFirst
  | DMMF.ModelAction.findUnique
  | 'findFirstOrThrow'
  | 'findUniqueOrThrow'

function getBaseTypeName(modelName: string, action: ActionWithBaseType): string {
  switch (action) {
    case DMMF.ModelAction.findFirst:
    case 'findFirstOrThrow':
      return `${modelName}FindFirstArgsBase`
    case DMMF.ModelAction.findUnique:
    case 'findUniqueOrThrow':
      return `${modelName}FindUniqueArgsBase`
  }
}
