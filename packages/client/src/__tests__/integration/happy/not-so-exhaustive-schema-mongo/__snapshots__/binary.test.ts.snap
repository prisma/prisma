// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`not-so-exhaustive-schema-mongo (binary): generatedBrowserJS 1`] = `
"
Object.defineProperty(exports, "__esModule", { value: true });

const {
  Decimal,
  objectEnumValues,
  makeStrictEnum,
  Public,
  getRuntime,
} = require('@prisma/client/runtime/index-browser.js')


const Prisma = {}

exports.Prisma = Prisma
exports.$Enums = {}

/**
 * Prisma Client JS version: local
 * Query Engine version: local
 */
Prisma.prismaVersion = {
  client: "local",
  engine: "local"
}

Prisma.PrismaClientKnownRequestError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`PrismaClientKnownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)};
Prisma.PrismaClientUnknownRequestError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`PrismaClientUnknownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.PrismaClientRustPanicError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`PrismaClientRustPanicError is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.PrismaClientInitializationError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`PrismaClientInitializationError is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.PrismaClientValidationError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`PrismaClientValidationError is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.NotFoundError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`NotFoundError is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.Decimal = Decimal

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`sqltag is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.empty = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`empty is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.join = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`join is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.raw = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`raw is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.validator = Public.validator

/**
* Extensions
*/
Prisma.getExtensionContext = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`Extensions.getExtensionContext is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}
Prisma.defineExtension = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(\`Extensions.defineExtension is unable to run in this browser environment, or has been bundled for the browser (running in \${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report\`,
)}

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}

/**
 * Enums
 */

exports.Prisma.PostScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  title: 'title',
  content: 'content',
  published: 'published',
  authorId: 'authorId'
};

exports.Prisma.UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean',
  embedHolderId: 'embedHolderId'
};

exports.Prisma.EmbedHolderScalarFieldEnum = {
  id: 'id',
  time: 'time',
  text: 'text',
  boolean: 'boolean'
};

exports.Prisma.MScalarFieldEnum = {
  id: 'id',
  n_ids: 'n_ids',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

exports.Prisma.NScalarFieldEnum = {
  id: 'id',
  m_ids: 'm_ids',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

exports.Prisma.OneOptionalScalarFieldEnum = {
  id: 'id',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

exports.Prisma.ManyRequiredScalarFieldEnum = {
  id: 'id',
  oneOptionalId: 'oneOptionalId',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

exports.Prisma.OptionalSide1ScalarFieldEnum = {
  id: 'id',
  optionalSide2Id: 'optionalSide2Id',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

exports.Prisma.OptionalSide2ScalarFieldEnum = {
  id: 'id',
  int: 'int',
  optionalInt: 'optionalInt',
  float: 'float',
  optionalFloat: 'optionalFloat',
  string: 'string',
  optionalString: 'optionalString',
  json: 'json',
  optionalJson: 'optionalJson',
  enum: 'enum',
  optionalEnum: 'optionalEnum',
  boolean: 'boolean',
  optionalBoolean: 'optionalBoolean'
};

exports.Prisma.AScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  int: 'int',
  sInt: 'sInt',
  bInt: 'bInt'
};

exports.Prisma.BScalarFieldEnum = {
  id: 'id',
  float: 'float',
  dFloat: 'dFloat'
};

exports.Prisma.CScalarFieldEnum = {
  id: 'id',
  char: 'char',
  vChar: 'vChar',
  text: 'text',
  bit: 'bit',
  vBit: 'vBit',
  uuid: 'uuid'
};

exports.Prisma.DScalarFieldEnum = {
  id: 'id',
  bool: 'bool',
  byteA: 'byteA',
  xml: 'xml',
  json: 'json',
  jsonb: 'jsonb',
  list: 'list'
};

exports.Prisma.EScalarFieldEnum = {
  id: 'id',
  date: 'date',
  time: 'time',
  ts: 'ts'
};

exports.Prisma.SortOrder = {
  asc: 'asc',
  desc: 'desc'
};

exports.Prisma.QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
};
exports.ABeautifulEnum = exports.$Enums.ABeautifulEnum = {
  A: 'A',
  B: 'B',
  C: 'C'
};

exports.Prisma.ModelName = {
  Post: 'Post',
  User: 'User',
  EmbedHolder: 'EmbedHolder',
  M: 'M',
  N: 'N',
  OneOptional: 'OneOptional',
  ManyRequired: 'ManyRequired',
  OptionalSide1: 'OptionalSide1',
  OptionalSide2: 'OptionalSide2',
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E'
};

/**
 * This is a stub Prisma Client that will error at runtime if called.
 */
class PrismaClient {
  constructor() {
    return new Proxy(this, {
      get(target, prop) {
        let message
        const runtime = getRuntime()
        if (runtime.isEdge) {
          message = \`PrismaClient is not configured to run in \${runtime.prettyName}. In order to run Prisma Client on edge runtime, either:
- Use Prisma Accelerate: https://pris.ly/d/accelerate
- Use Driver Adapters: https://pris.ly/d/driver-adapters
\`;
        } else {
          message = 'PrismaClient is unable to run in this browser environment, or has been bundled for the browser (running in \`' + runtime.prettyName + '\`).'
        }
        
        message += \`
If this is unexpected, please open an issue: https://pris.ly/prisma-prisma-bug-report\`

        throw new Error(message)
      }
    })
  }
}

exports.PrismaClient = PrismaClient

Object.assign(exports, Prisma)
"
`;

exports[`not-so-exhaustive-schema-mongo (binary): generatedTypeScript 1`] = `
"
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/binary.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Embed
 * 
 */
export type Embed = $Result.DefaultSelection<Prisma.$EmbedPayload>
/**
 * Model EmbedEmbed
 * 
 */
export type EmbedEmbed = $Result.DefaultSelection<Prisma.$EmbedEmbedPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model EmbedHolder
 * 
 */
export type EmbedHolder = $Result.DefaultSelection<Prisma.$EmbedHolderPayload>
/**
 * Model M
 * 
 */
export type M = $Result.DefaultSelection<Prisma.$MPayload>
/**
 * Model N
 * 
 */
export type N = $Result.DefaultSelection<Prisma.$NPayload>
/**
 * Model OneOptional
 * 
 */
export type OneOptional = $Result.DefaultSelection<Prisma.$OneOptionalPayload>
/**
 * Model ManyRequired
 * 
 */
export type ManyRequired = $Result.DefaultSelection<Prisma.$ManyRequiredPayload>
/**
 * Model OptionalSide1
 * 
 */
export type OptionalSide1 = $Result.DefaultSelection<Prisma.$OptionalSide1Payload>
/**
 * Model OptionalSide2
 * 
 */
export type OptionalSide2 = $Result.DefaultSelection<Prisma.$OptionalSide2Payload>
/**
 * Model A
 * model comment
 */
export type A = $Result.DefaultSelection<Prisma.$APayload>
/**
 * Model B
 * 
 */
export type B = $Result.DefaultSelection<Prisma.$BPayload>
/**
 * Model C
 * 
 */
export type C = $Result.DefaultSelection<Prisma.$CPayload>
/**
 * Model D
 * 
 */
export type D = $Result.DefaultSelection<Prisma.$DPayload>
/**
 * Model E
 * 
 */
export type E = $Result.DefaultSelection<Prisma.$EPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ABeautifulEnum: {
  A: 'A',
  B: 'B',
  C: 'C'
};

export type ABeautifulEnum = (typeof ABeautifulEnum)[keyof typeof ABeautifulEnum]

}

export type ABeautifulEnum = $Enums.ABeautifulEnum

export const ABeautifulEnum: typeof $Enums.ABeautifulEnum

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * \`\`\`
 * const prisma = new PrismaClient()
 * // Fetch zero or more Posts
 * const posts = await prisma.post.findMany()
 * \`\`\`
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * \`\`\`
   * const prisma = new PrismaClient()
   * // Fetch zero or more Posts
   * const posts = await prisma.post.findMany()
   * \`\`\`
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => $Utils.JsPromise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * \`\`\`
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * \`\`\`
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * \`\`\`
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * \`\`\`
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * \`prisma.post\`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * \`\`\`
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * \`prisma.user\`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * \`\`\`
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * \`prisma.embedHolder\`: Exposes CRUD operations for the **EmbedHolder** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more EmbedHolders
    * const embedHolders = await prisma.embedHolder.findMany()
    * \`\`\`
    */
  get embedHolder(): Prisma.EmbedHolderDelegate<ExtArgs>;

  /**
   * \`prisma.m\`: Exposes CRUD operations for the **M** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Ms
    * const ms = await prisma.m.findMany()
    * \`\`\`
    */
  get m(): Prisma.MDelegate<ExtArgs>;

  /**
   * \`prisma.n\`: Exposes CRUD operations for the **N** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Ns
    * const ns = await prisma.n.findMany()
    * \`\`\`
    */
  get n(): Prisma.NDelegate<ExtArgs>;

  /**
   * \`prisma.oneOptional\`: Exposes CRUD operations for the **OneOptional** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more OneOptionals
    * const oneOptionals = await prisma.oneOptional.findMany()
    * \`\`\`
    */
  get oneOptional(): Prisma.OneOptionalDelegate<ExtArgs>;

  /**
   * \`prisma.manyRequired\`: Exposes CRUD operations for the **ManyRequired** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more ManyRequireds
    * const manyRequireds = await prisma.manyRequired.findMany()
    * \`\`\`
    */
  get manyRequired(): Prisma.ManyRequiredDelegate<ExtArgs>;

  /**
   * \`prisma.optionalSide1\`: Exposes CRUD operations for the **OptionalSide1** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more OptionalSide1s
    * const optionalSide1s = await prisma.optionalSide1.findMany()
    * \`\`\`
    */
  get optionalSide1(): Prisma.OptionalSide1Delegate<ExtArgs>;

  /**
   * \`prisma.optionalSide2\`: Exposes CRUD operations for the **OptionalSide2** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more OptionalSide2s
    * const optionalSide2s = await prisma.optionalSide2.findMany()
    * \`\`\`
    */
  get optionalSide2(): Prisma.OptionalSide2Delegate<ExtArgs>;

  /**
   * \`prisma.a\`: Exposes CRUD operations for the **A** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more As
    * const as = await prisma.a.findMany()
    * \`\`\`
    */
  get a(): Prisma.ADelegate<ExtArgs>;

  /**
   * \`prisma.b\`: Exposes CRUD operations for the **B** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Bs
    * const bs = await prisma.b.findMany()
    * \`\`\`
    */
  get b(): Prisma.BDelegate<ExtArgs>;

  /**
   * \`prisma.c\`: Exposes CRUD operations for the **C** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Cs
    * const cs = await prisma.c.findMany()
    * \`\`\`
    */
  get c(): Prisma.CDelegate<ExtArgs>;

  /**
   * \`prisma.d\`: Exposes CRUD operations for the **D** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Ds
    * const ds = await prisma.d.findMany()
    * \`\`\`
    */
  get d(): Prisma.DDelegate<ExtArgs>;

  /**
   * \`prisma.e\`: Exposes CRUD operations for the **E** model.
    * Example usage:
    * \`\`\`ts
    * // Fetch zero or more Es
    * const es = await prisma.e.findMany()
    * \`\`\`
    */
  get e(): Prisma.EDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: local
   * Query Engine version: local
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike \`JsonObject\`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike \`JsonArray\`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike \`JsonValue\`, this
   * type allows read-only arrays and read-only object properties and disallows
   * \`null\` at the top level.
   *
   * \`null\` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use \`Prisma.JsonNull\` to store the JSON null value or
   * \`Prisma.DbNull\` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of \`null\` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of \`Prisma.DbNull\`.
    * 
    * You cannot use other instances of this class. Please use the \`Prisma.DbNull\` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of \`Prisma.JsonNull\`.
    * 
    * You cannot use other instances of this class. Please use the \`Prisma.JsonNull\` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of \`Prisma.AnyNull\`.
    * 
    * You cannot use other instances of this class. Please use the \`Prisma.AnyNull\` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have \`null\` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON \`null\` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are \`Prisma.DbNull\` or \`Prisma.JsonNull\`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose \`select\` or \`include\`.'
      : T extends SelectAndOmit
        ? 'Please either choose \`select\` or \`omit\`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From \`T\` pick properties that exist in \`U\` and intersect \`K\`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything \`never\` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like \`Pick\`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends \`_\${string}\` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Post: 'Post',
    User: 'User',
    EmbedHolder: 'EmbedHolder',
    M: 'M',
    N: 'N',
    OneOptional: 'OneOptional',
    ManyRequired: 'ManyRequired',
    OptionalSide1: 'OptionalSide1',
    OptionalSide2: 'OptionalSide2',
    A: 'A',
    B: 'B',
    C: 'C',
    D: 'D',
    E: 'E'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "post" | "user" | "embedHolder" | "m" | "n" | "oneOptional" | "manyRequired" | "optionalSide1" | "optionalSide2" | "a" | "b" | "c" | "d" | "e"
      txIsolationLevel: never
    }
    model: {
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      EmbedHolder: {
        payload: Prisma.$EmbedHolderPayload<ExtArgs>
        fields: Prisma.EmbedHolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmbedHolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbedHolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmbedHolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbedHolderPayload>
          }
          findFirst: {
            args: Prisma.EmbedHolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbedHolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmbedHolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbedHolderPayload>
          }
          findMany: {
            args: Prisma.EmbedHolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbedHolderPayload>[]
          }
          create: {
            args: Prisma.EmbedHolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbedHolderPayload>
          }
          createMany: {
            args: Prisma.EmbedHolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmbedHolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbedHolderPayload>
          }
          update: {
            args: Prisma.EmbedHolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbedHolderPayload>
          }
          deleteMany: {
            args: Prisma.EmbedHolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmbedHolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmbedHolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmbedHolderPayload>
          }
          aggregate: {
            args: Prisma.EmbedHolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmbedHolder>
          }
          groupBy: {
            args: Prisma.EmbedHolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmbedHolderGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EmbedHolderFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EmbedHolderAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EmbedHolderCountArgs<ExtArgs>
            result: $Utils.Optional<EmbedHolderCountAggregateOutputType> | number
          }
        }
      }
      M: {
        payload: Prisma.$MPayload<ExtArgs>
        fields: Prisma.MFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MPayload>
          }
          findFirst: {
            args: Prisma.MFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MPayload>
          }
          findMany: {
            args: Prisma.MFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MPayload>[]
          }
          create: {
            args: Prisma.MCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MPayload>
          }
          createMany: {
            args: Prisma.MCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MPayload>
          }
          update: {
            args: Prisma.MUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MPayload>
          }
          deleteMany: {
            args: Prisma.MDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MPayload>
          }
          aggregate: {
            args: Prisma.MAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateM>
          }
          groupBy: {
            args: Prisma.MGroupByArgs<ExtArgs>
            result: $Utils.Optional<MGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MCountArgs<ExtArgs>
            result: $Utils.Optional<MCountAggregateOutputType> | number
          }
        }
      }
      N: {
        payload: Prisma.$NPayload<ExtArgs>
        fields: Prisma.NFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPayload>
          }
          findFirst: {
            args: Prisma.NFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPayload>
          }
          findMany: {
            args: Prisma.NFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPayload>[]
          }
          create: {
            args: Prisma.NCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPayload>
          }
          createMany: {
            args: Prisma.NCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPayload>
          }
          update: {
            args: Prisma.NUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPayload>
          }
          deleteMany: {
            args: Prisma.NDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPayload>
          }
          aggregate: {
            args: Prisma.NAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateN>
          }
          groupBy: {
            args: Prisma.NGroupByArgs<ExtArgs>
            result: $Utils.Optional<NGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NCountArgs<ExtArgs>
            result: $Utils.Optional<NCountAggregateOutputType> | number
          }
        }
      }
      OneOptional: {
        payload: Prisma.$OneOptionalPayload<ExtArgs>
        fields: Prisma.OneOptionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OneOptionalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneOptionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OneOptionalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneOptionalPayload>
          }
          findFirst: {
            args: Prisma.OneOptionalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneOptionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OneOptionalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneOptionalPayload>
          }
          findMany: {
            args: Prisma.OneOptionalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneOptionalPayload>[]
          }
          create: {
            args: Prisma.OneOptionalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneOptionalPayload>
          }
          createMany: {
            args: Prisma.OneOptionalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OneOptionalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneOptionalPayload>
          }
          update: {
            args: Prisma.OneOptionalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneOptionalPayload>
          }
          deleteMany: {
            args: Prisma.OneOptionalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OneOptionalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OneOptionalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OneOptionalPayload>
          }
          aggregate: {
            args: Prisma.OneOptionalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOneOptional>
          }
          groupBy: {
            args: Prisma.OneOptionalGroupByArgs<ExtArgs>
            result: $Utils.Optional<OneOptionalGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OneOptionalFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OneOptionalAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OneOptionalCountArgs<ExtArgs>
            result: $Utils.Optional<OneOptionalCountAggregateOutputType> | number
          }
        }
      }
      ManyRequired: {
        payload: Prisma.$ManyRequiredPayload<ExtArgs>
        fields: Prisma.ManyRequiredFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManyRequiredFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManyRequiredPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManyRequiredFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManyRequiredPayload>
          }
          findFirst: {
            args: Prisma.ManyRequiredFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManyRequiredPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManyRequiredFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManyRequiredPayload>
          }
          findMany: {
            args: Prisma.ManyRequiredFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManyRequiredPayload>[]
          }
          create: {
            args: Prisma.ManyRequiredCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManyRequiredPayload>
          }
          createMany: {
            args: Prisma.ManyRequiredCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ManyRequiredDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManyRequiredPayload>
          }
          update: {
            args: Prisma.ManyRequiredUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManyRequiredPayload>
          }
          deleteMany: {
            args: Prisma.ManyRequiredDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManyRequiredUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManyRequiredUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManyRequiredPayload>
          }
          aggregate: {
            args: Prisma.ManyRequiredAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManyRequired>
          }
          groupBy: {
            args: Prisma.ManyRequiredGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManyRequiredGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ManyRequiredFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ManyRequiredAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ManyRequiredCountArgs<ExtArgs>
            result: $Utils.Optional<ManyRequiredCountAggregateOutputType> | number
          }
        }
      }
      OptionalSide1: {
        payload: Prisma.$OptionalSide1Payload<ExtArgs>
        fields: Prisma.OptionalSide1FieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptionalSide1FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide1Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptionalSide1FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide1Payload>
          }
          findFirst: {
            args: Prisma.OptionalSide1FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide1Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptionalSide1FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide1Payload>
          }
          findMany: {
            args: Prisma.OptionalSide1FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide1Payload>[]
          }
          create: {
            args: Prisma.OptionalSide1CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide1Payload>
          }
          createMany: {
            args: Prisma.OptionalSide1CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OptionalSide1DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide1Payload>
          }
          update: {
            args: Prisma.OptionalSide1UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide1Payload>
          }
          deleteMany: {
            args: Prisma.OptionalSide1DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptionalSide1UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OptionalSide1UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide1Payload>
          }
          aggregate: {
            args: Prisma.OptionalSide1AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOptionalSide1>
          }
          groupBy: {
            args: Prisma.OptionalSide1GroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionalSide1GroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OptionalSide1FindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OptionalSide1AggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OptionalSide1CountArgs<ExtArgs>
            result: $Utils.Optional<OptionalSide1CountAggregateOutputType> | number
          }
        }
      }
      OptionalSide2: {
        payload: Prisma.$OptionalSide2Payload<ExtArgs>
        fields: Prisma.OptionalSide2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptionalSide2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptionalSide2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide2Payload>
          }
          findFirst: {
            args: Prisma.OptionalSide2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptionalSide2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide2Payload>
          }
          findMany: {
            args: Prisma.OptionalSide2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide2Payload>[]
          }
          create: {
            args: Prisma.OptionalSide2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide2Payload>
          }
          createMany: {
            args: Prisma.OptionalSide2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OptionalSide2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide2Payload>
          }
          update: {
            args: Prisma.OptionalSide2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide2Payload>
          }
          deleteMany: {
            args: Prisma.OptionalSide2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptionalSide2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OptionalSide2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionalSide2Payload>
          }
          aggregate: {
            args: Prisma.OptionalSide2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOptionalSide2>
          }
          groupBy: {
            args: Prisma.OptionalSide2GroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionalSide2GroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OptionalSide2FindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OptionalSide2AggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OptionalSide2CountArgs<ExtArgs>
            result: $Utils.Optional<OptionalSide2CountAggregateOutputType> | number
          }
        }
      }
      A: {
        payload: Prisma.$APayload<ExtArgs>
        fields: Prisma.AFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APayload>
          }
          findFirst: {
            args: Prisma.AFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APayload>
          }
          findMany: {
            args: Prisma.AFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APayload>[]
          }
          create: {
            args: Prisma.ACreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APayload>
          }
          createMany: {
            args: Prisma.ACreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ADeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APayload>
          }
          update: {
            args: Prisma.AUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APayload>
          }
          deleteMany: {
            args: Prisma.ADeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$APayload>
          }
          aggregate: {
            args: Prisma.AAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateA>
          }
          groupBy: {
            args: Prisma.AGroupByArgs<ExtArgs>
            result: $Utils.Optional<AGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ACountArgs<ExtArgs>
            result: $Utils.Optional<ACountAggregateOutputType> | number
          }
        }
      }
      B: {
        payload: Prisma.$BPayload<ExtArgs>
        fields: Prisma.BFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BPayload>
          }
          findFirst: {
            args: Prisma.BFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BPayload>
          }
          findMany: {
            args: Prisma.BFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BPayload>[]
          }
          create: {
            args: Prisma.BCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BPayload>
          }
          createMany: {
            args: Prisma.BCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BPayload>
          }
          update: {
            args: Prisma.BUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BPayload>
          }
          deleteMany: {
            args: Prisma.BDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BPayload>
          }
          aggregate: {
            args: Prisma.BAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateB>
          }
          groupBy: {
            args: Prisma.BGroupByArgs<ExtArgs>
            result: $Utils.Optional<BGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BCountArgs<ExtArgs>
            result: $Utils.Optional<BCountAggregateOutputType> | number
          }
        }
      }
      C: {
        payload: Prisma.$CPayload<ExtArgs>
        fields: Prisma.CFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPayload>
          }
          findFirst: {
            args: Prisma.CFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPayload>
          }
          findMany: {
            args: Prisma.CFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPayload>[]
          }
          create: {
            args: Prisma.CCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPayload>
          }
          createMany: {
            args: Prisma.CCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPayload>
          }
          update: {
            args: Prisma.CUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPayload>
          }
          deleteMany: {
            args: Prisma.CDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPayload>
          }
          aggregate: {
            args: Prisma.CAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateC>
          }
          groupBy: {
            args: Prisma.CGroupByArgs<ExtArgs>
            result: $Utils.Optional<CGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CCountArgs<ExtArgs>
            result: $Utils.Optional<CCountAggregateOutputType> | number
          }
        }
      }
      D: {
        payload: Prisma.$DPayload<ExtArgs>
        fields: Prisma.DFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DPayload>
          }
          findFirst: {
            args: Prisma.DFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DPayload>
          }
          findMany: {
            args: Prisma.DFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DPayload>[]
          }
          create: {
            args: Prisma.DCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DPayload>
          }
          createMany: {
            args: Prisma.DCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DPayload>
          }
          update: {
            args: Prisma.DUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DPayload>
          }
          deleteMany: {
            args: Prisma.DDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DPayload>
          }
          aggregate: {
            args: Prisma.DAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateD>
          }
          groupBy: {
            args: Prisma.DGroupByArgs<ExtArgs>
            result: $Utils.Optional<DGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DCountArgs<ExtArgs>
            result: $Utils.Optional<DCountAggregateOutputType> | number
          }
        }
      }
      E: {
        payload: Prisma.$EPayload<ExtArgs>
        fields: Prisma.EFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPayload>
          }
          findFirst: {
            args: Prisma.EFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPayload>
          }
          findMany: {
            args: Prisma.EFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPayload>[]
          }
          create: {
            args: Prisma.ECreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPayload>
          }
          createMany: {
            args: Prisma.ECreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPayload>
          }
          update: {
            args: Prisma.EUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPayload>
          }
          deleteMany: {
            args: Prisma.EDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EPayload>
          }
          aggregate: {
            args: Prisma.EAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateE>
          }
          groupBy: {
            args: Prisma.EGroupByArgs<ExtArgs>
            result: $Utils.Optional<EGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ECountArgs<ExtArgs>
            result: $Utils.Optional<ECountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * \`\`\`
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * \`\`\`
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The \`T\` type makes sure, that the \`return proceed\` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * \`PrismaClient\` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    posts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | UserCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type EmbedHolderCountOutputType
   */

  export type EmbedHolderCountOutputType = {
    User: number
  }

  export type EmbedHolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | EmbedHolderCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * EmbedHolderCountOutputType without action
   */
  export type EmbedHolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolderCountOutputType
     */
    select?: EmbedHolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmbedHolderCountOutputType without action
   */
  export type EmbedHolderCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type MCountOutputType
   */

  export type MCountOutputType = {
    n: number
  }

  export type MCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    n?: boolean | MCountOutputTypeCountNArgs
  }

  // Custom InputTypes
  /**
   * MCountOutputType without action
   */
  export type MCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCountOutputType
     */
    select?: MCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MCountOutputType without action
   */
  export type MCountOutputTypeCountNArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NWhereInput
  }


  /**
   * Count Type NCountOutputType
   */

  export type NCountOutputType = {
    m: number
  }

  export type NCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    m?: boolean | NCountOutputTypeCountMArgs
  }

  // Custom InputTypes
  /**
   * NCountOutputType without action
   */
  export type NCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCountOutputType
     */
    select?: NCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NCountOutputType without action
   */
  export type NCountOutputTypeCountMArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MWhereInput
  }


  /**
   * Count Type OneOptionalCountOutputType
   */

  export type OneOptionalCountOutputType = {
    many: number
  }

  export type OneOptionalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    many?: boolean | OneOptionalCountOutputTypeCountManyArgs
  }

  // Custom InputTypes
  /**
   * OneOptionalCountOutputType without action
   */
  export type OneOptionalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptionalCountOutputType
     */
    select?: OneOptionalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OneOptionalCountOutputType without action
   */
  export type OneOptionalCountOutputTypeCountManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManyRequiredWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Embed
   */





  export type EmbedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    text?: boolean
    boolean?: boolean
    embedEmbedList?: boolean | EmbedEmbedDefaultArgs<ExtArgs>
    requiredEmbedEmbed?: boolean | EmbedEmbedDefaultArgs<ExtArgs>
    optionalEmbedEmbed?: boolean | EmbedEmbedDefaultArgs<ExtArgs>
    scalarList?: boolean
  }, ExtArgs["result"]["embed"]>


  export type EmbedSelectScalar = {
    text?: boolean
    boolean?: boolean
    scalarList?: boolean
  }

  export type EmbedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmbedPayload = {
    name: "Embed"
    objects: {}
    scalars: {
      text: string
      boolean: boolean
      scalarList: number[]
    }
    composites: {
      embedEmbedList: Prisma.$EmbedEmbedPayload[]
      requiredEmbedEmbed: Prisma.$EmbedEmbedPayload
      optionalEmbedEmbed: Prisma.$EmbedEmbedPayload | null
    }
  }

  type EmbedGetPayload<S extends boolean | null | undefined | EmbedDefaultArgs> = $Result.GetResult<Prisma.$EmbedPayload, S>





  /**
   * Fields of the Embed model
   */ 
  interface EmbedFieldRefs {
    readonly text: FieldRef<"Embed", 'String'>
    readonly boolean: FieldRef<"Embed", 'Boolean'>
    readonly scalarList: FieldRef<"Embed", 'Int[]'>
  }
    

  // Custom InputTypes
  /**
   * Embed without action
   */
  export type EmbedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Embed
     */
    select?: EmbedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedInclude<ExtArgs> | null
  }


  /**
   * Model EmbedEmbed
   */





  export type EmbedEmbedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    text?: boolean
    boolean?: boolean
  }, ExtArgs["result"]["embedEmbed"]>


  export type EmbedEmbedSelectScalar = {
    text?: boolean
    boolean?: boolean
  }


  export type $EmbedEmbedPayload = {
    name: "EmbedEmbed"
    objects: {}
    scalars: {
      text: string
      boolean: boolean
    }
    composites: {}
  }

  type EmbedEmbedGetPayload<S extends boolean | null | undefined | EmbedEmbedDefaultArgs> = $Result.GetResult<Prisma.$EmbedEmbedPayload, S>





  /**
   * Fields of the EmbedEmbed model
   */ 
  interface EmbedEmbedFieldRefs {
    readonly text: FieldRef<"EmbedEmbed", 'String'>
    readonly boolean: FieldRef<"EmbedEmbed", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EmbedEmbed without action
   */
  export type EmbedEmbedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedEmbed
     */
    select?: EmbedEmbedSelect<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    title: string | null
    content: string | null
    published: boolean | null
    authorId: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    title: string | null
    content: string | null
    published: boolean | null
    authorId: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    createdAt: number
    title: number
    content: number
    published: number
    authorId: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    published?: true
    authorId?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    published?: true
    authorId?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    content?: true
    published?: true
    authorId?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    createdAt: Date
    title: string
    content: string | null
    published: boolean
    authorId: string
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    authorId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>


  export type PostSelectScalar = {
    id?: boolean
    createdAt?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    authorId?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      title: string
      content: string | null
      published: boolean
      authorId: string
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * @param {PostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const post = await prisma.post.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Post.
     * @param {PostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const post = await prisma.post.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Posts.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly published: FieldRef<"Post", 'Boolean'>
    readonly authorId: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the \`where\` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }

  /**
   * Post findRaw
   */
  export type PostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Post aggregateRaw
   */
  export type PostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type UserSumAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
    embedHolderId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
    embedHolderId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    int: number
    optionalInt: number
    float: number
    optionalFloat: number
    string: number
    optionalString: number
    json: number
    optionalJson: number
    enum: number
    optionalEnum: number
    boolean: number
    optionalBoolean: number
    embedHolderId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type UserSumAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
    embedHolderId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
    embedHolderId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    json?: true
    optionalJson?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
    embedHolderId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    int: number
    optionalInt: number | null
    float: number
    optionalFloat: number | null
    string: string
    optionalString: string | null
    json: JsonValue
    optionalJson: JsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean: boolean | null
    embedHolderId: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
    embedHolderId?: boolean
    posts?: boolean | User$postsArgs<ExtArgs>
    embedHolder?: boolean | EmbedHolderDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
    embedHolderId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | User$postsArgs<ExtArgs>
    embedHolder?: boolean | EmbedHolderDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
      embedHolder: Prisma.$EmbedHolderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      int: number
      optionalInt: number | null
      float: number
      optionalFloat: number | null
      string: string
      optionalString: string | null
      json: Prisma.JsonValue
      optionalJson: Prisma.JsonValue | null
      enum: $Enums.ABeautifulEnum
      optionalEnum: $Enums.ABeautifulEnum | null
      boolean: boolean
      optionalBoolean: boolean | null
      embedHolderId: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    embedHolder<T extends EmbedHolderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmbedHolderDefaultArgs<ExtArgs>>): Prisma__EmbedHolderClient<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly int: FieldRef<"User", 'Int'>
    readonly optionalInt: FieldRef<"User", 'Int'>
    readonly float: FieldRef<"User", 'Float'>
    readonly optionalFloat: FieldRef<"User", 'Float'>
    readonly string: FieldRef<"User", 'String'>
    readonly optionalString: FieldRef<"User", 'String'>
    readonly json: FieldRef<"User", 'Json'>
    readonly optionalJson: FieldRef<"User", 'Json'>
    readonly enum: FieldRef<"User", 'ABeautifulEnum'>
    readonly optionalEnum: FieldRef<"User", 'ABeautifulEnum'>
    readonly boolean: FieldRef<"User", 'Boolean'>
    readonly optionalBoolean: FieldRef<"User", 'Boolean'>
    readonly embedHolderId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the \`where\` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model EmbedHolder
   */

  export type AggregateEmbedHolder = {
    _count: EmbedHolderCountAggregateOutputType | null
    _min: EmbedHolderMinAggregateOutputType | null
    _max: EmbedHolderMaxAggregateOutputType | null
  }

  export type EmbedHolderMinAggregateOutputType = {
    id: string | null
    time: Date | null
    text: string | null
    boolean: boolean | null
  }

  export type EmbedHolderMaxAggregateOutputType = {
    id: string | null
    time: Date | null
    text: string | null
    boolean: boolean | null
  }

  export type EmbedHolderCountAggregateOutputType = {
    id: number
    time: number
    text: number
    boolean: number
    _all: number
  }


  export type EmbedHolderMinAggregateInputType = {
    id?: true
    time?: true
    text?: true
    boolean?: true
  }

  export type EmbedHolderMaxAggregateInputType = {
    id?: true
    time?: true
    text?: true
    boolean?: true
  }

  export type EmbedHolderCountAggregateInputType = {
    id?: true
    time?: true
    text?: true
    boolean?: true
    _all?: true
  }

  export type EmbedHolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmbedHolder to aggregate.
     */
    where?: EmbedHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmbedHolders to fetch.
     */
    orderBy?: EmbedHolderOrderByWithRelationInput | EmbedHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmbedHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` EmbedHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` EmbedHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmbedHolders
    **/
    _count?: true | EmbedHolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmbedHolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmbedHolderMaxAggregateInputType
  }

  export type GetEmbedHolderAggregateType<T extends EmbedHolderAggregateArgs> = {
        [P in keyof T & keyof AggregateEmbedHolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmbedHolder[P]>
      : GetScalarType<T[P], AggregateEmbedHolder[P]>
  }




  export type EmbedHolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmbedHolderWhereInput
    orderBy?: EmbedHolderOrderByWithAggregationInput | EmbedHolderOrderByWithAggregationInput[]
    by: EmbedHolderScalarFieldEnum[] | EmbedHolderScalarFieldEnum
    having?: EmbedHolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmbedHolderCountAggregateInputType | true
    _min?: EmbedHolderMinAggregateInputType
    _max?: EmbedHolderMaxAggregateInputType
  }

  export type EmbedHolderGroupByOutputType = {
    id: string
    time: Date
    text: string
    boolean: boolean
    _count: EmbedHolderCountAggregateOutputType | null
    _min: EmbedHolderMinAggregateOutputType | null
    _max: EmbedHolderMaxAggregateOutputType | null
  }

  type GetEmbedHolderGroupByPayload<T extends EmbedHolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmbedHolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmbedHolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmbedHolderGroupByOutputType[P]>
            : GetScalarType<T[P], EmbedHolderGroupByOutputType[P]>
        }
      >
    >


  export type EmbedHolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    time?: boolean
    text?: boolean
    boolean?: boolean
    embedList?: boolean | EmbedDefaultArgs<ExtArgs>
    requiredEmbed?: boolean | EmbedDefaultArgs<ExtArgs>
    optionalEmbed?: boolean | EmbedDefaultArgs<ExtArgs>
    User?: boolean | EmbedHolder$UserArgs<ExtArgs>
    _count?: boolean | EmbedHolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["embedHolder"]>


  export type EmbedHolderSelectScalar = {
    id?: boolean
    time?: boolean
    text?: boolean
    boolean?: boolean
  }

  export type EmbedHolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | EmbedHolder$UserArgs<ExtArgs>
    _count?: boolean | EmbedHolderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmbedHolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmbedHolder"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      time: Date
      text: string
      boolean: boolean
    }, ExtArgs["result"]["embedHolder"]>
    composites: {
      embedList: Prisma.$EmbedPayload[]
      requiredEmbed: Prisma.$EmbedPayload
      optionalEmbed: Prisma.$EmbedPayload | null
    }
  }

  type EmbedHolderGetPayload<S extends boolean | null | undefined | EmbedHolderDefaultArgs> = $Result.GetResult<Prisma.$EmbedHolderPayload, S>

  type EmbedHolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmbedHolderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmbedHolderCountAggregateInputType | true
    }

  export interface EmbedHolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmbedHolder'], meta: { name: 'EmbedHolder' } }
    /**
     * Find zero or one EmbedHolder that matches the filter.
     * @param {EmbedHolderFindUniqueArgs} args - Arguments to find a EmbedHolder
     * @example
     * // Get one EmbedHolder
     * const embedHolder = await prisma.embedHolder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmbedHolderFindUniqueArgs>(args: SelectSubset<T, EmbedHolderFindUniqueArgs<ExtArgs>>): Prisma__EmbedHolderClient<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmbedHolder that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {EmbedHolderFindUniqueOrThrowArgs} args - Arguments to find a EmbedHolder
     * @example
     * // Get one EmbedHolder
     * const embedHolder = await prisma.embedHolder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmbedHolderFindUniqueOrThrowArgs>(args: SelectSubset<T, EmbedHolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmbedHolderClient<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmbedHolder that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbedHolderFindFirstArgs} args - Arguments to find a EmbedHolder
     * @example
     * // Get one EmbedHolder
     * const embedHolder = await prisma.embedHolder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmbedHolderFindFirstArgs>(args?: SelectSubset<T, EmbedHolderFindFirstArgs<ExtArgs>>): Prisma__EmbedHolderClient<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmbedHolder that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbedHolderFindFirstOrThrowArgs} args - Arguments to find a EmbedHolder
     * @example
     * // Get one EmbedHolder
     * const embedHolder = await prisma.embedHolder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmbedHolderFindFirstOrThrowArgs>(args?: SelectSubset<T, EmbedHolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmbedHolderClient<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmbedHolders that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbedHolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmbedHolders
     * const embedHolders = await prisma.embedHolder.findMany()
     * 
     * // Get first 10 EmbedHolders
     * const embedHolders = await prisma.embedHolder.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const embedHolderWithIdOnly = await prisma.embedHolder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmbedHolderFindManyArgs>(args?: SelectSubset<T, EmbedHolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmbedHolder.
     * @param {EmbedHolderCreateArgs} args - Arguments to create a EmbedHolder.
     * @example
     * // Create one EmbedHolder
     * const EmbedHolder = await prisma.embedHolder.create({
     *   data: {
     *     // ... data to create a EmbedHolder
     *   }
     * })
     * 
     */
    create<T extends EmbedHolderCreateArgs>(args: SelectSubset<T, EmbedHolderCreateArgs<ExtArgs>>): Prisma__EmbedHolderClient<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmbedHolders.
     * @param {EmbedHolderCreateManyArgs} args - Arguments to create many EmbedHolders.
     * @example
     * // Create many EmbedHolders
     * const embedHolder = await prisma.embedHolder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmbedHolderCreateManyArgs>(args?: SelectSubset<T, EmbedHolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmbedHolder.
     * @param {EmbedHolderDeleteArgs} args - Arguments to delete one EmbedHolder.
     * @example
     * // Delete one EmbedHolder
     * const EmbedHolder = await prisma.embedHolder.delete({
     *   where: {
     *     // ... filter to delete one EmbedHolder
     *   }
     * })
     * 
     */
    delete<T extends EmbedHolderDeleteArgs>(args: SelectSubset<T, EmbedHolderDeleteArgs<ExtArgs>>): Prisma__EmbedHolderClient<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmbedHolder.
     * @param {EmbedHolderUpdateArgs} args - Arguments to update one EmbedHolder.
     * @example
     * // Update one EmbedHolder
     * const embedHolder = await prisma.embedHolder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmbedHolderUpdateArgs>(args: SelectSubset<T, EmbedHolderUpdateArgs<ExtArgs>>): Prisma__EmbedHolderClient<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmbedHolders.
     * @param {EmbedHolderDeleteManyArgs} args - Arguments to filter EmbedHolders to delete.
     * @example
     * // Delete a few EmbedHolders
     * const { count } = await prisma.embedHolder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmbedHolderDeleteManyArgs>(args?: SelectSubset<T, EmbedHolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmbedHolders.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbedHolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmbedHolders
     * const embedHolder = await prisma.embedHolder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmbedHolderUpdateManyArgs>(args: SelectSubset<T, EmbedHolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmbedHolder.
     * @param {EmbedHolderUpsertArgs} args - Arguments to update or create a EmbedHolder.
     * @example
     * // Update or create a EmbedHolder
     * const embedHolder = await prisma.embedHolder.upsert({
     *   create: {
     *     // ... data to create a EmbedHolder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmbedHolder we want to update
     *   }
     * })
     */
    upsert<T extends EmbedHolderUpsertArgs>(args: SelectSubset<T, EmbedHolderUpsertArgs<ExtArgs>>): Prisma__EmbedHolderClient<$Result.GetResult<Prisma.$EmbedHolderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more EmbedHolders that matches the filter.
     * @param {EmbedHolderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const embedHolder = await prisma.embedHolder.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: EmbedHolderFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EmbedHolder.
     * @param {EmbedHolderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const embedHolder = await prisma.embedHolder.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EmbedHolderAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of EmbedHolders.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbedHolderCountArgs} args - Arguments to filter EmbedHolders to count.
     * @example
     * // Count the number of EmbedHolders
     * const count = await prisma.embedHolder.count({
     *   where: {
     *     // ... the filter for the EmbedHolders we want to count
     *   }
     * })
    **/
    count<T extends EmbedHolderCountArgs>(
      args?: Subset<T, EmbedHolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmbedHolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmbedHolder.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbedHolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmbedHolderAggregateArgs>(args: Subset<T, EmbedHolderAggregateArgs>): Prisma.PrismaPromise<GetEmbedHolderAggregateType<T>>

    /**
     * Group by EmbedHolder.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmbedHolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmbedHolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmbedHolderGroupByArgs['orderBy'] }
        : { orderBy?: EmbedHolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmbedHolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmbedHolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmbedHolder model
   */
  readonly fields: EmbedHolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmbedHolder.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmbedHolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends EmbedHolder$UserArgs<ExtArgs> = {}>(args?: Subset<T, EmbedHolder$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmbedHolder model
   */ 
  interface EmbedHolderFieldRefs {
    readonly id: FieldRef<"EmbedHolder", 'String'>
    readonly time: FieldRef<"EmbedHolder", 'DateTime'>
    readonly text: FieldRef<"EmbedHolder", 'String'>
    readonly boolean: FieldRef<"EmbedHolder", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EmbedHolder findUnique
   */
  export type EmbedHolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
    /**
     * Filter, which EmbedHolder to fetch.
     */
    where: EmbedHolderWhereUniqueInput
  }

  /**
   * EmbedHolder findUniqueOrThrow
   */
  export type EmbedHolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
    /**
     * Filter, which EmbedHolder to fetch.
     */
    where: EmbedHolderWhereUniqueInput
  }

  /**
   * EmbedHolder findFirst
   */
  export type EmbedHolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
    /**
     * Filter, which EmbedHolder to fetch.
     */
    where?: EmbedHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmbedHolders to fetch.
     */
    orderBy?: EmbedHolderOrderByWithRelationInput | EmbedHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmbedHolders.
     */
    cursor?: EmbedHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` EmbedHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` EmbedHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmbedHolders.
     */
    distinct?: EmbedHolderScalarFieldEnum | EmbedHolderScalarFieldEnum[]
  }

  /**
   * EmbedHolder findFirstOrThrow
   */
  export type EmbedHolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
    /**
     * Filter, which EmbedHolder to fetch.
     */
    where?: EmbedHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmbedHolders to fetch.
     */
    orderBy?: EmbedHolderOrderByWithRelationInput | EmbedHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmbedHolders.
     */
    cursor?: EmbedHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` EmbedHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` EmbedHolders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmbedHolders.
     */
    distinct?: EmbedHolderScalarFieldEnum | EmbedHolderScalarFieldEnum[]
  }

  /**
   * EmbedHolder findMany
   */
  export type EmbedHolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
    /**
     * Filter, which EmbedHolders to fetch.
     */
    where?: EmbedHolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmbedHolders to fetch.
     */
    orderBy?: EmbedHolderOrderByWithRelationInput | EmbedHolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmbedHolders.
     */
    cursor?: EmbedHolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` EmbedHolders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` EmbedHolders.
     */
    skip?: number
    distinct?: EmbedHolderScalarFieldEnum | EmbedHolderScalarFieldEnum[]
  }

  /**
   * EmbedHolder create
   */
  export type EmbedHolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
    /**
     * The data needed to create a EmbedHolder.
     */
    data: XOR<EmbedHolderCreateInput, EmbedHolderUncheckedCreateInput>
  }

  /**
   * EmbedHolder createMany
   */
  export type EmbedHolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmbedHolders.
     */
    data: EmbedHolderCreateManyInput | EmbedHolderCreateManyInput[]
  }

  /**
   * EmbedHolder update
   */
  export type EmbedHolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
    /**
     * The data needed to update a EmbedHolder.
     */
    data: XOR<EmbedHolderUpdateInput, EmbedHolderUncheckedUpdateInput>
    /**
     * Choose, which EmbedHolder to update.
     */
    where: EmbedHolderWhereUniqueInput
  }

  /**
   * EmbedHolder updateMany
   */
  export type EmbedHolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmbedHolders.
     */
    data: XOR<EmbedHolderUpdateManyMutationInput, EmbedHolderUncheckedUpdateManyInput>
    /**
     * Filter which EmbedHolders to update
     */
    where?: EmbedHolderWhereInput
  }

  /**
   * EmbedHolder upsert
   */
  export type EmbedHolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
    /**
     * The filter to search for the EmbedHolder to update in case it exists.
     */
    where: EmbedHolderWhereUniqueInput
    /**
     * In case the EmbedHolder found by the \`where\` argument doesn't exist, create a new EmbedHolder with this data.
     */
    create: XOR<EmbedHolderCreateInput, EmbedHolderUncheckedCreateInput>
    /**
     * In case the EmbedHolder was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<EmbedHolderUpdateInput, EmbedHolderUncheckedUpdateInput>
  }

  /**
   * EmbedHolder delete
   */
  export type EmbedHolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
    /**
     * Filter which EmbedHolder to delete.
     */
    where: EmbedHolderWhereUniqueInput
  }

  /**
   * EmbedHolder deleteMany
   */
  export type EmbedHolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmbedHolders to delete
     */
    where?: EmbedHolderWhereInput
  }

  /**
   * EmbedHolder findRaw
   */
  export type EmbedHolderFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EmbedHolder aggregateRaw
   */
  export type EmbedHolderAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EmbedHolder.User
   */
  export type EmbedHolder$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * EmbedHolder without action
   */
  export type EmbedHolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmbedHolder
     */
    select?: EmbedHolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmbedHolderInclude<ExtArgs> | null
  }


  /**
   * Model M
   */

  export type AggregateM = {
    _count: MCountAggregateOutputType | null
    _avg: MAvgAggregateOutputType | null
    _sum: MSumAggregateOutputType | null
    _min: MMinAggregateOutputType | null
    _max: MMaxAggregateOutputType | null
  }

  export type MAvgAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type MSumAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type MMinAggregateOutputType = {
    id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type MMaxAggregateOutputType = {
    id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type MCountAggregateOutputType = {
    id: number
    n_ids: number
    int: number
    optionalInt: number
    float: number
    optionalFloat: number
    string: number
    optionalString: number
    json: number
    optionalJson: number
    enum: number
    optionalEnum: number
    boolean: number
    optionalBoolean: number
    _all: number
  }


  export type MAvgAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type MSumAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type MMinAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type MMaxAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type MCountAggregateInputType = {
    id?: true
    n_ids?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    json?: true
    optionalJson?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
    _all?: true
  }

  export type MAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which M to aggregate.
     */
    where?: MWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MS to fetch.
     */
    orderBy?: MOrderByWithRelationInput | MOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` MS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` MS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MS
    **/
    _count?: true | MCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MMaxAggregateInputType
  }

  export type GetMAggregateType<T extends MAggregateArgs> = {
        [P in keyof T & keyof AggregateM]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateM[P]>
      : GetScalarType<T[P], AggregateM[P]>
  }




  export type MGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MWhereInput
    orderBy?: MOrderByWithAggregationInput | MOrderByWithAggregationInput[]
    by: MScalarFieldEnum[] | MScalarFieldEnum
    having?: MScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCountAggregateInputType | true
    _avg?: MAvgAggregateInputType
    _sum?: MSumAggregateInputType
    _min?: MMinAggregateInputType
    _max?: MMaxAggregateInputType
  }

  export type MGroupByOutputType = {
    id: string
    n_ids: string[]
    int: number
    optionalInt: number | null
    float: number
    optionalFloat: number | null
    string: string
    optionalString: string | null
    json: JsonValue
    optionalJson: JsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean: boolean | null
    _count: MCountAggregateOutputType | null
    _avg: MAvgAggregateOutputType | null
    _sum: MSumAggregateOutputType | null
    _min: MMinAggregateOutputType | null
    _max: MMaxAggregateOutputType | null
  }

  type GetMGroupByPayload<T extends MGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MGroupByOutputType[P]>
            : GetScalarType<T[P], MGroupByOutputType[P]>
        }
      >
    >


  export type MSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    n_ids?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
    n?: boolean | M$nArgs<ExtArgs>
    _count?: boolean | MCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["m"]>


  export type MSelectScalar = {
    id?: boolean
    n_ids?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
  }

  export type MInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    n?: boolean | M$nArgs<ExtArgs>
    _count?: boolean | MCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "M"
    objects: {
      n: Prisma.$NPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      n_ids: string[]
      int: number
      optionalInt: number | null
      float: number
      optionalFloat: number | null
      string: string
      optionalString: string | null
      json: Prisma.JsonValue
      optionalJson: Prisma.JsonValue | null
      enum: $Enums.ABeautifulEnum
      optionalEnum: $Enums.ABeautifulEnum | null
      boolean: boolean
      optionalBoolean: boolean | null
    }, ExtArgs["result"]["m"]>
    composites: {}
  }

  type MGetPayload<S extends boolean | null | undefined | MDefaultArgs> = $Result.GetResult<Prisma.$MPayload, S>

  type MCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MCountAggregateInputType | true
    }

  export interface MDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['M'], meta: { name: 'M' } }
    /**
     * Find zero or one M that matches the filter.
     * @param {MFindUniqueArgs} args - Arguments to find a M
     * @example
     * // Get one M
     * const m = await prisma.m.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MFindUniqueArgs>(args: SelectSubset<T, MFindUniqueArgs<ExtArgs>>): Prisma__MClient<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one M that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {MFindUniqueOrThrowArgs} args - Arguments to find a M
     * @example
     * // Get one M
     * const m = await prisma.m.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MFindUniqueOrThrowArgs>(args: SelectSubset<T, MFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MClient<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first M that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MFindFirstArgs} args - Arguments to find a M
     * @example
     * // Get one M
     * const m = await prisma.m.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MFindFirstArgs>(args?: SelectSubset<T, MFindFirstArgs<ExtArgs>>): Prisma__MClient<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first M that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MFindFirstOrThrowArgs} args - Arguments to find a M
     * @example
     * // Get one M
     * const m = await prisma.m.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MFindFirstOrThrowArgs>(args?: SelectSubset<T, MFindFirstOrThrowArgs<ExtArgs>>): Prisma__MClient<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ms that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ms
     * const ms = await prisma.m.findMany()
     * 
     * // Get first 10 Ms
     * const ms = await prisma.m.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const mWithIdOnly = await prisma.m.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MFindManyArgs>(args?: SelectSubset<T, MFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a M.
     * @param {MCreateArgs} args - Arguments to create a M.
     * @example
     * // Create one M
     * const M = await prisma.m.create({
     *   data: {
     *     // ... data to create a M
     *   }
     * })
     * 
     */
    create<T extends MCreateArgs>(args: SelectSubset<T, MCreateArgs<ExtArgs>>): Prisma__MClient<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ms.
     * @param {MCreateManyArgs} args - Arguments to create many Ms.
     * @example
     * // Create many Ms
     * const m = await prisma.m.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MCreateManyArgs>(args?: SelectSubset<T, MCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a M.
     * @param {MDeleteArgs} args - Arguments to delete one M.
     * @example
     * // Delete one M
     * const M = await prisma.m.delete({
     *   where: {
     *     // ... filter to delete one M
     *   }
     * })
     * 
     */
    delete<T extends MDeleteArgs>(args: SelectSubset<T, MDeleteArgs<ExtArgs>>): Prisma__MClient<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one M.
     * @param {MUpdateArgs} args - Arguments to update one M.
     * @example
     * // Update one M
     * const m = await prisma.m.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MUpdateArgs>(args: SelectSubset<T, MUpdateArgs<ExtArgs>>): Prisma__MClient<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ms.
     * @param {MDeleteManyArgs} args - Arguments to filter Ms to delete.
     * @example
     * // Delete a few Ms
     * const { count } = await prisma.m.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MDeleteManyArgs>(args?: SelectSubset<T, MDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ms.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ms
     * const m = await prisma.m.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MUpdateManyArgs>(args: SelectSubset<T, MUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one M.
     * @param {MUpsertArgs} args - Arguments to update or create a M.
     * @example
     * // Update or create a M
     * const m = await prisma.m.upsert({
     *   create: {
     *     // ... data to create a M
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the M we want to update
     *   }
     * })
     */
    upsert<T extends MUpsertArgs>(args: SelectSubset<T, MUpsertArgs<ExtArgs>>): Prisma__MClient<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Ms that matches the filter.
     * @param {MFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const m = await prisma.m.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: MFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a M.
     * @param {MAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const m = await prisma.m.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Ms.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCountArgs} args - Arguments to filter Ms to count.
     * @example
     * // Count the number of Ms
     * const count = await prisma.m.count({
     *   where: {
     *     // ... the filter for the Ms we want to count
     *   }
     * })
    **/
    count<T extends MCountArgs>(
      args?: Subset<T, MCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a M.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MAggregateArgs>(args: Subset<T, MAggregateArgs>): Prisma.PrismaPromise<GetMAggregateType<T>>

    /**
     * Group by M.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MGroupByArgs['orderBy'] }
        : { orderBy?: MGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, MGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the M model
   */
  readonly fields: MFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for M.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    n<T extends M$nArgs<ExtArgs> = {}>(args?: Subset<T, M$nArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the M model
   */ 
  interface MFieldRefs {
    readonly id: FieldRef<"M", 'String'>
    readonly n_ids: FieldRef<"M", 'String[]'>
    readonly int: FieldRef<"M", 'Int'>
    readonly optionalInt: FieldRef<"M", 'Int'>
    readonly float: FieldRef<"M", 'Float'>
    readonly optionalFloat: FieldRef<"M", 'Float'>
    readonly string: FieldRef<"M", 'String'>
    readonly optionalString: FieldRef<"M", 'String'>
    readonly json: FieldRef<"M", 'Json'>
    readonly optionalJson: FieldRef<"M", 'Json'>
    readonly enum: FieldRef<"M", 'ABeautifulEnum'>
    readonly optionalEnum: FieldRef<"M", 'ABeautifulEnum'>
    readonly boolean: FieldRef<"M", 'Boolean'>
    readonly optionalBoolean: FieldRef<"M", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * M findUnique
   */
  export type MFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    /**
     * Filter, which M to fetch.
     */
    where: MWhereUniqueInput
  }

  /**
   * M findUniqueOrThrow
   */
  export type MFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    /**
     * Filter, which M to fetch.
     */
    where: MWhereUniqueInput
  }

  /**
   * M findFirst
   */
  export type MFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    /**
     * Filter, which M to fetch.
     */
    where?: MWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MS to fetch.
     */
    orderBy?: MOrderByWithRelationInput | MOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MS.
     */
    cursor?: MWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` MS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` MS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MS.
     */
    distinct?: MScalarFieldEnum | MScalarFieldEnum[]
  }

  /**
   * M findFirstOrThrow
   */
  export type MFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    /**
     * Filter, which M to fetch.
     */
    where?: MWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MS to fetch.
     */
    orderBy?: MOrderByWithRelationInput | MOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MS.
     */
    cursor?: MWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` MS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` MS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MS.
     */
    distinct?: MScalarFieldEnum | MScalarFieldEnum[]
  }

  /**
   * M findMany
   */
  export type MFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    /**
     * Filter, which MS to fetch.
     */
    where?: MWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MS to fetch.
     */
    orderBy?: MOrderByWithRelationInput | MOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MS.
     */
    cursor?: MWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` MS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` MS.
     */
    skip?: number
    distinct?: MScalarFieldEnum | MScalarFieldEnum[]
  }

  /**
   * M create
   */
  export type MCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    /**
     * The data needed to create a M.
     */
    data: XOR<MCreateInput, MUncheckedCreateInput>
  }

  /**
   * M createMany
   */
  export type MCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MS.
     */
    data: MCreateManyInput | MCreateManyInput[]
  }

  /**
   * M update
   */
  export type MUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    /**
     * The data needed to update a M.
     */
    data: XOR<MUpdateInput, MUncheckedUpdateInput>
    /**
     * Choose, which M to update.
     */
    where: MWhereUniqueInput
  }

  /**
   * M updateMany
   */
  export type MUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MS.
     */
    data: XOR<MUpdateManyMutationInput, MUncheckedUpdateManyInput>
    /**
     * Filter which MS to update
     */
    where?: MWhereInput
  }

  /**
   * M upsert
   */
  export type MUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    /**
     * The filter to search for the M to update in case it exists.
     */
    where: MWhereUniqueInput
    /**
     * In case the M found by the \`where\` argument doesn't exist, create a new M with this data.
     */
    create: XOR<MCreateInput, MUncheckedCreateInput>
    /**
     * In case the M was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<MUpdateInput, MUncheckedUpdateInput>
  }

  /**
   * M delete
   */
  export type MDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    /**
     * Filter which M to delete.
     */
    where: MWhereUniqueInput
  }

  /**
   * M deleteMany
   */
  export type MDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MS to delete
     */
    where?: MWhereInput
  }

  /**
   * M findRaw
   */
  export type MFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * M aggregateRaw
   */
  export type MAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * M.n
   */
  export type M$nArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    where?: NWhereInput
    orderBy?: NOrderByWithRelationInput | NOrderByWithRelationInput[]
    cursor?: NWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NScalarFieldEnum | NScalarFieldEnum[]
  }

  /**
   * M without action
   */
  export type MDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
  }


  /**
   * Model N
   */

  export type AggregateN = {
    _count: NCountAggregateOutputType | null
    _avg: NAvgAggregateOutputType | null
    _sum: NSumAggregateOutputType | null
    _min: NMinAggregateOutputType | null
    _max: NMaxAggregateOutputType | null
  }

  export type NAvgAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type NSumAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type NMinAggregateOutputType = {
    id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type NMaxAggregateOutputType = {
    id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type NCountAggregateOutputType = {
    id: number
    m_ids: number
    int: number
    optionalInt: number
    float: number
    optionalFloat: number
    string: number
    optionalString: number
    json: number
    optionalJson: number
    enum: number
    optionalEnum: number
    boolean: number
    optionalBoolean: number
    _all: number
  }


  export type NAvgAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type NSumAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type NMinAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type NMaxAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type NCountAggregateInputType = {
    id?: true
    m_ids?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    json?: true
    optionalJson?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
    _all?: true
  }

  export type NAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which N to aggregate.
     */
    where?: NWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NS to fetch.
     */
    orderBy?: NOrderByWithRelationInput | NOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` NS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` NS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NS
    **/
    _count?: true | NCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NMaxAggregateInputType
  }

  export type GetNAggregateType<T extends NAggregateArgs> = {
        [P in keyof T & keyof AggregateN]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateN[P]>
      : GetScalarType<T[P], AggregateN[P]>
  }




  export type NGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NWhereInput
    orderBy?: NOrderByWithAggregationInput | NOrderByWithAggregationInput[]
    by: NScalarFieldEnum[] | NScalarFieldEnum
    having?: NScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NCountAggregateInputType | true
    _avg?: NAvgAggregateInputType
    _sum?: NSumAggregateInputType
    _min?: NMinAggregateInputType
    _max?: NMaxAggregateInputType
  }

  export type NGroupByOutputType = {
    id: string
    m_ids: string[]
    int: number
    optionalInt: number | null
    float: number
    optionalFloat: number | null
    string: string
    optionalString: string | null
    json: JsonValue
    optionalJson: JsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean: boolean | null
    _count: NCountAggregateOutputType | null
    _avg: NAvgAggregateOutputType | null
    _sum: NSumAggregateOutputType | null
    _min: NMinAggregateOutputType | null
    _max: NMaxAggregateOutputType | null
  }

  type GetNGroupByPayload<T extends NGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NGroupByOutputType[P]>
            : GetScalarType<T[P], NGroupByOutputType[P]>
        }
      >
    >


  export type NSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    m_ids?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
    m?: boolean | N$mArgs<ExtArgs>
    _count?: boolean | NCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["n"]>


  export type NSelectScalar = {
    id?: boolean
    m_ids?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
  }

  export type NInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    m?: boolean | N$mArgs<ExtArgs>
    _count?: boolean | NCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "N"
    objects: {
      m: Prisma.$MPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      m_ids: string[]
      int: number
      optionalInt: number | null
      float: number
      optionalFloat: number | null
      string: string
      optionalString: string | null
      json: Prisma.JsonValue
      optionalJson: Prisma.JsonValue | null
      enum: $Enums.ABeautifulEnum
      optionalEnum: $Enums.ABeautifulEnum | null
      boolean: boolean
      optionalBoolean: boolean | null
    }, ExtArgs["result"]["n"]>
    composites: {}
  }

  type NGetPayload<S extends boolean | null | undefined | NDefaultArgs> = $Result.GetResult<Prisma.$NPayload, S>

  type NCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NCountAggregateInputType | true
    }

  export interface NDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['N'], meta: { name: 'N' } }
    /**
     * Find zero or one N that matches the filter.
     * @param {NFindUniqueArgs} args - Arguments to find a N
     * @example
     * // Get one N
     * const n = await prisma.n.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NFindUniqueArgs>(args: SelectSubset<T, NFindUniqueArgs<ExtArgs>>): Prisma__NClient<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one N that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {NFindUniqueOrThrowArgs} args - Arguments to find a N
     * @example
     * // Get one N
     * const n = await prisma.n.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NFindUniqueOrThrowArgs>(args: SelectSubset<T, NFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NClient<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first N that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFindFirstArgs} args - Arguments to find a N
     * @example
     * // Get one N
     * const n = await prisma.n.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NFindFirstArgs>(args?: SelectSubset<T, NFindFirstArgs<ExtArgs>>): Prisma__NClient<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first N that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFindFirstOrThrowArgs} args - Arguments to find a N
     * @example
     * // Get one N
     * const n = await prisma.n.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NFindFirstOrThrowArgs>(args?: SelectSubset<T, NFindFirstOrThrowArgs<ExtArgs>>): Prisma__NClient<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ns that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ns
     * const ns = await prisma.n.findMany()
     * 
     * // Get first 10 Ns
     * const ns = await prisma.n.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const nWithIdOnly = await prisma.n.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NFindManyArgs>(args?: SelectSubset<T, NFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a N.
     * @param {NCreateArgs} args - Arguments to create a N.
     * @example
     * // Create one N
     * const N = await prisma.n.create({
     *   data: {
     *     // ... data to create a N
     *   }
     * })
     * 
     */
    create<T extends NCreateArgs>(args: SelectSubset<T, NCreateArgs<ExtArgs>>): Prisma__NClient<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ns.
     * @param {NCreateManyArgs} args - Arguments to create many Ns.
     * @example
     * // Create many Ns
     * const n = await prisma.n.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NCreateManyArgs>(args?: SelectSubset<T, NCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a N.
     * @param {NDeleteArgs} args - Arguments to delete one N.
     * @example
     * // Delete one N
     * const N = await prisma.n.delete({
     *   where: {
     *     // ... filter to delete one N
     *   }
     * })
     * 
     */
    delete<T extends NDeleteArgs>(args: SelectSubset<T, NDeleteArgs<ExtArgs>>): Prisma__NClient<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one N.
     * @param {NUpdateArgs} args - Arguments to update one N.
     * @example
     * // Update one N
     * const n = await prisma.n.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NUpdateArgs>(args: SelectSubset<T, NUpdateArgs<ExtArgs>>): Prisma__NClient<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ns.
     * @param {NDeleteManyArgs} args - Arguments to filter Ns to delete.
     * @example
     * // Delete a few Ns
     * const { count } = await prisma.n.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NDeleteManyArgs>(args?: SelectSubset<T, NDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ns.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ns
     * const n = await prisma.n.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NUpdateManyArgs>(args: SelectSubset<T, NUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one N.
     * @param {NUpsertArgs} args - Arguments to update or create a N.
     * @example
     * // Update or create a N
     * const n = await prisma.n.upsert({
     *   create: {
     *     // ... data to create a N
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the N we want to update
     *   }
     * })
     */
    upsert<T extends NUpsertArgs>(args: SelectSubset<T, NUpsertArgs<ExtArgs>>): Prisma__NClient<$Result.GetResult<Prisma.$NPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Ns that matches the filter.
     * @param {NFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const n = await prisma.n.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: NFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a N.
     * @param {NAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const n = await prisma.n.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Ns.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCountArgs} args - Arguments to filter Ns to count.
     * @example
     * // Count the number of Ns
     * const count = await prisma.n.count({
     *   where: {
     *     // ... the filter for the Ns we want to count
     *   }
     * })
    **/
    count<T extends NCountArgs>(
      args?: Subset<T, NCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a N.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NAggregateArgs>(args: Subset<T, NAggregateArgs>): Prisma.PrismaPromise<GetNAggregateType<T>>

    /**
     * Group by N.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NGroupByArgs['orderBy'] }
        : { orderBy?: NGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, NGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the N model
   */
  readonly fields: NFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for N.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    m<T extends N$mArgs<ExtArgs> = {}>(args?: Subset<T, N$mArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the N model
   */ 
  interface NFieldRefs {
    readonly id: FieldRef<"N", 'String'>
    readonly m_ids: FieldRef<"N", 'String[]'>
    readonly int: FieldRef<"N", 'Int'>
    readonly optionalInt: FieldRef<"N", 'Int'>
    readonly float: FieldRef<"N", 'Float'>
    readonly optionalFloat: FieldRef<"N", 'Float'>
    readonly string: FieldRef<"N", 'String'>
    readonly optionalString: FieldRef<"N", 'String'>
    readonly json: FieldRef<"N", 'Json'>
    readonly optionalJson: FieldRef<"N", 'Json'>
    readonly enum: FieldRef<"N", 'ABeautifulEnum'>
    readonly optionalEnum: FieldRef<"N", 'ABeautifulEnum'>
    readonly boolean: FieldRef<"N", 'Boolean'>
    readonly optionalBoolean: FieldRef<"N", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * N findUnique
   */
  export type NFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    /**
     * Filter, which N to fetch.
     */
    where: NWhereUniqueInput
  }

  /**
   * N findUniqueOrThrow
   */
  export type NFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    /**
     * Filter, which N to fetch.
     */
    where: NWhereUniqueInput
  }

  /**
   * N findFirst
   */
  export type NFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    /**
     * Filter, which N to fetch.
     */
    where?: NWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NS to fetch.
     */
    orderBy?: NOrderByWithRelationInput | NOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NS.
     */
    cursor?: NWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` NS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` NS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NS.
     */
    distinct?: NScalarFieldEnum | NScalarFieldEnum[]
  }

  /**
   * N findFirstOrThrow
   */
  export type NFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    /**
     * Filter, which N to fetch.
     */
    where?: NWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NS to fetch.
     */
    orderBy?: NOrderByWithRelationInput | NOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NS.
     */
    cursor?: NWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` NS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` NS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NS.
     */
    distinct?: NScalarFieldEnum | NScalarFieldEnum[]
  }

  /**
   * N findMany
   */
  export type NFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    /**
     * Filter, which NS to fetch.
     */
    where?: NWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NS to fetch.
     */
    orderBy?: NOrderByWithRelationInput | NOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NS.
     */
    cursor?: NWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` NS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` NS.
     */
    skip?: number
    distinct?: NScalarFieldEnum | NScalarFieldEnum[]
  }

  /**
   * N create
   */
  export type NCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    /**
     * The data needed to create a N.
     */
    data: XOR<NCreateInput, NUncheckedCreateInput>
  }

  /**
   * N createMany
   */
  export type NCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NS.
     */
    data: NCreateManyInput | NCreateManyInput[]
  }

  /**
   * N update
   */
  export type NUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    /**
     * The data needed to update a N.
     */
    data: XOR<NUpdateInput, NUncheckedUpdateInput>
    /**
     * Choose, which N to update.
     */
    where: NWhereUniqueInput
  }

  /**
   * N updateMany
   */
  export type NUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NS.
     */
    data: XOR<NUpdateManyMutationInput, NUncheckedUpdateManyInput>
    /**
     * Filter which NS to update
     */
    where?: NWhereInput
  }

  /**
   * N upsert
   */
  export type NUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    /**
     * The filter to search for the N to update in case it exists.
     */
    where: NWhereUniqueInput
    /**
     * In case the N found by the \`where\` argument doesn't exist, create a new N with this data.
     */
    create: XOR<NCreateInput, NUncheckedCreateInput>
    /**
     * In case the N was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<NUpdateInput, NUncheckedUpdateInput>
  }

  /**
   * N delete
   */
  export type NDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
    /**
     * Filter which N to delete.
     */
    where: NWhereUniqueInput
  }

  /**
   * N deleteMany
   */
  export type NDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NS to delete
     */
    where?: NWhereInput
  }

  /**
   * N findRaw
   */
  export type NFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * N aggregateRaw
   */
  export type NAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * N.m
   */
  export type N$mArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the M
     */
    select?: MSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MInclude<ExtArgs> | null
    where?: MWhereInput
    orderBy?: MOrderByWithRelationInput | MOrderByWithRelationInput[]
    cursor?: MWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MScalarFieldEnum | MScalarFieldEnum[]
  }

  /**
   * N without action
   */
  export type NDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the N
     */
    select?: NSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NInclude<ExtArgs> | null
  }


  /**
   * Model OneOptional
   */

  export type AggregateOneOptional = {
    _count: OneOptionalCountAggregateOutputType | null
    _avg: OneOptionalAvgAggregateOutputType | null
    _sum: OneOptionalSumAggregateOutputType | null
    _min: OneOptionalMinAggregateOutputType | null
    _max: OneOptionalMaxAggregateOutputType | null
  }

  export type OneOptionalAvgAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type OneOptionalSumAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type OneOptionalMinAggregateOutputType = {
    id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type OneOptionalMaxAggregateOutputType = {
    id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type OneOptionalCountAggregateOutputType = {
    id: number
    int: number
    optionalInt: number
    float: number
    optionalFloat: number
    string: number
    optionalString: number
    json: number
    optionalJson: number
    enum: number
    optionalEnum: number
    boolean: number
    optionalBoolean: number
    _all: number
  }


  export type OneOptionalAvgAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type OneOptionalSumAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type OneOptionalMinAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type OneOptionalMaxAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type OneOptionalCountAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    json?: true
    optionalJson?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
    _all?: true
  }

  export type OneOptionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneOptional to aggregate.
     */
    where?: OneOptionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneOptionals to fetch.
     */
    orderBy?: OneOptionalOrderByWithRelationInput | OneOptionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OneOptionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OneOptionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OneOptionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OneOptionals
    **/
    _count?: true | OneOptionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OneOptionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OneOptionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OneOptionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OneOptionalMaxAggregateInputType
  }

  export type GetOneOptionalAggregateType<T extends OneOptionalAggregateArgs> = {
        [P in keyof T & keyof AggregateOneOptional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOneOptional[P]>
      : GetScalarType<T[P], AggregateOneOptional[P]>
  }




  export type OneOptionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OneOptionalWhereInput
    orderBy?: OneOptionalOrderByWithAggregationInput | OneOptionalOrderByWithAggregationInput[]
    by: OneOptionalScalarFieldEnum[] | OneOptionalScalarFieldEnum
    having?: OneOptionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OneOptionalCountAggregateInputType | true
    _avg?: OneOptionalAvgAggregateInputType
    _sum?: OneOptionalSumAggregateInputType
    _min?: OneOptionalMinAggregateInputType
    _max?: OneOptionalMaxAggregateInputType
  }

  export type OneOptionalGroupByOutputType = {
    id: string
    int: number
    optionalInt: number | null
    float: number
    optionalFloat: number | null
    string: string
    optionalString: string | null
    json: JsonValue
    optionalJson: JsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean: boolean | null
    _count: OneOptionalCountAggregateOutputType | null
    _avg: OneOptionalAvgAggregateOutputType | null
    _sum: OneOptionalSumAggregateOutputType | null
    _min: OneOptionalMinAggregateOutputType | null
    _max: OneOptionalMaxAggregateOutputType | null
  }

  type GetOneOptionalGroupByPayload<T extends OneOptionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OneOptionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OneOptionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OneOptionalGroupByOutputType[P]>
            : GetScalarType<T[P], OneOptionalGroupByOutputType[P]>
        }
      >
    >


  export type OneOptionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
    many?: boolean | OneOptional$manyArgs<ExtArgs>
    _count?: boolean | OneOptionalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oneOptional"]>


  export type OneOptionalSelectScalar = {
    id?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
  }

  export type OneOptionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    many?: boolean | OneOptional$manyArgs<ExtArgs>
    _count?: boolean | OneOptionalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OneOptionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OneOptional"
    objects: {
      many: Prisma.$ManyRequiredPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      int: number
      optionalInt: number | null
      float: number
      optionalFloat: number | null
      string: string
      optionalString: string | null
      json: Prisma.JsonValue
      optionalJson: Prisma.JsonValue | null
      enum: $Enums.ABeautifulEnum
      optionalEnum: $Enums.ABeautifulEnum | null
      boolean: boolean
      optionalBoolean: boolean | null
    }, ExtArgs["result"]["oneOptional"]>
    composites: {}
  }

  type OneOptionalGetPayload<S extends boolean | null | undefined | OneOptionalDefaultArgs> = $Result.GetResult<Prisma.$OneOptionalPayload, S>

  type OneOptionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OneOptionalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OneOptionalCountAggregateInputType | true
    }

  export interface OneOptionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OneOptional'], meta: { name: 'OneOptional' } }
    /**
     * Find zero or one OneOptional that matches the filter.
     * @param {OneOptionalFindUniqueArgs} args - Arguments to find a OneOptional
     * @example
     * // Get one OneOptional
     * const oneOptional = await prisma.oneOptional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OneOptionalFindUniqueArgs>(args: SelectSubset<T, OneOptionalFindUniqueArgs<ExtArgs>>): Prisma__OneOptionalClient<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OneOptional that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {OneOptionalFindUniqueOrThrowArgs} args - Arguments to find a OneOptional
     * @example
     * // Get one OneOptional
     * const oneOptional = await prisma.oneOptional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OneOptionalFindUniqueOrThrowArgs>(args: SelectSubset<T, OneOptionalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OneOptionalClient<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OneOptional that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneOptionalFindFirstArgs} args - Arguments to find a OneOptional
     * @example
     * // Get one OneOptional
     * const oneOptional = await prisma.oneOptional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OneOptionalFindFirstArgs>(args?: SelectSubset<T, OneOptionalFindFirstArgs<ExtArgs>>): Prisma__OneOptionalClient<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OneOptional that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneOptionalFindFirstOrThrowArgs} args - Arguments to find a OneOptional
     * @example
     * // Get one OneOptional
     * const oneOptional = await prisma.oneOptional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OneOptionalFindFirstOrThrowArgs>(args?: SelectSubset<T, OneOptionalFindFirstOrThrowArgs<ExtArgs>>): Prisma__OneOptionalClient<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OneOptionals that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneOptionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OneOptionals
     * const oneOptionals = await prisma.oneOptional.findMany()
     * 
     * // Get first 10 OneOptionals
     * const oneOptionals = await prisma.oneOptional.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const oneOptionalWithIdOnly = await prisma.oneOptional.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OneOptionalFindManyArgs>(args?: SelectSubset<T, OneOptionalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OneOptional.
     * @param {OneOptionalCreateArgs} args - Arguments to create a OneOptional.
     * @example
     * // Create one OneOptional
     * const OneOptional = await prisma.oneOptional.create({
     *   data: {
     *     // ... data to create a OneOptional
     *   }
     * })
     * 
     */
    create<T extends OneOptionalCreateArgs>(args: SelectSubset<T, OneOptionalCreateArgs<ExtArgs>>): Prisma__OneOptionalClient<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OneOptionals.
     * @param {OneOptionalCreateManyArgs} args - Arguments to create many OneOptionals.
     * @example
     * // Create many OneOptionals
     * const oneOptional = await prisma.oneOptional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OneOptionalCreateManyArgs>(args?: SelectSubset<T, OneOptionalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OneOptional.
     * @param {OneOptionalDeleteArgs} args - Arguments to delete one OneOptional.
     * @example
     * // Delete one OneOptional
     * const OneOptional = await prisma.oneOptional.delete({
     *   where: {
     *     // ... filter to delete one OneOptional
     *   }
     * })
     * 
     */
    delete<T extends OneOptionalDeleteArgs>(args: SelectSubset<T, OneOptionalDeleteArgs<ExtArgs>>): Prisma__OneOptionalClient<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OneOptional.
     * @param {OneOptionalUpdateArgs} args - Arguments to update one OneOptional.
     * @example
     * // Update one OneOptional
     * const oneOptional = await prisma.oneOptional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OneOptionalUpdateArgs>(args: SelectSubset<T, OneOptionalUpdateArgs<ExtArgs>>): Prisma__OneOptionalClient<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OneOptionals.
     * @param {OneOptionalDeleteManyArgs} args - Arguments to filter OneOptionals to delete.
     * @example
     * // Delete a few OneOptionals
     * const { count } = await prisma.oneOptional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OneOptionalDeleteManyArgs>(args?: SelectSubset<T, OneOptionalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OneOptionals.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneOptionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OneOptionals
     * const oneOptional = await prisma.oneOptional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OneOptionalUpdateManyArgs>(args: SelectSubset<T, OneOptionalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OneOptional.
     * @param {OneOptionalUpsertArgs} args - Arguments to update or create a OneOptional.
     * @example
     * // Update or create a OneOptional
     * const oneOptional = await prisma.oneOptional.upsert({
     *   create: {
     *     // ... data to create a OneOptional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OneOptional we want to update
     *   }
     * })
     */
    upsert<T extends OneOptionalUpsertArgs>(args: SelectSubset<T, OneOptionalUpsertArgs<ExtArgs>>): Prisma__OneOptionalClient<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more OneOptionals that matches the filter.
     * @param {OneOptionalFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const oneOptional = await prisma.oneOptional.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: OneOptionalFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OneOptional.
     * @param {OneOptionalAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const oneOptional = await prisma.oneOptional.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OneOptionalAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of OneOptionals.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneOptionalCountArgs} args - Arguments to filter OneOptionals to count.
     * @example
     * // Count the number of OneOptionals
     * const count = await prisma.oneOptional.count({
     *   where: {
     *     // ... the filter for the OneOptionals we want to count
     *   }
     * })
    **/
    count<T extends OneOptionalCountArgs>(
      args?: Subset<T, OneOptionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OneOptionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OneOptional.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneOptionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OneOptionalAggregateArgs>(args: Subset<T, OneOptionalAggregateArgs>): Prisma.PrismaPromise<GetOneOptionalAggregateType<T>>

    /**
     * Group by OneOptional.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneOptionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OneOptionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OneOptionalGroupByArgs['orderBy'] }
        : { orderBy?: OneOptionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, OneOptionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOneOptionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OneOptional model
   */
  readonly fields: OneOptionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OneOptional.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OneOptionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    many<T extends OneOptional$manyArgs<ExtArgs> = {}>(args?: Subset<T, OneOptional$manyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OneOptional model
   */ 
  interface OneOptionalFieldRefs {
    readonly id: FieldRef<"OneOptional", 'String'>
    readonly int: FieldRef<"OneOptional", 'Int'>
    readonly optionalInt: FieldRef<"OneOptional", 'Int'>
    readonly float: FieldRef<"OneOptional", 'Float'>
    readonly optionalFloat: FieldRef<"OneOptional", 'Float'>
    readonly string: FieldRef<"OneOptional", 'String'>
    readonly optionalString: FieldRef<"OneOptional", 'String'>
    readonly json: FieldRef<"OneOptional", 'Json'>
    readonly optionalJson: FieldRef<"OneOptional", 'Json'>
    readonly enum: FieldRef<"OneOptional", 'ABeautifulEnum'>
    readonly optionalEnum: FieldRef<"OneOptional", 'ABeautifulEnum'>
    readonly boolean: FieldRef<"OneOptional", 'Boolean'>
    readonly optionalBoolean: FieldRef<"OneOptional", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OneOptional findUnique
   */
  export type OneOptionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    /**
     * Filter, which OneOptional to fetch.
     */
    where: OneOptionalWhereUniqueInput
  }

  /**
   * OneOptional findUniqueOrThrow
   */
  export type OneOptionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    /**
     * Filter, which OneOptional to fetch.
     */
    where: OneOptionalWhereUniqueInput
  }

  /**
   * OneOptional findFirst
   */
  export type OneOptionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    /**
     * Filter, which OneOptional to fetch.
     */
    where?: OneOptionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneOptionals to fetch.
     */
    orderBy?: OneOptionalOrderByWithRelationInput | OneOptionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneOptionals.
     */
    cursor?: OneOptionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OneOptionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OneOptionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneOptionals.
     */
    distinct?: OneOptionalScalarFieldEnum | OneOptionalScalarFieldEnum[]
  }

  /**
   * OneOptional findFirstOrThrow
   */
  export type OneOptionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    /**
     * Filter, which OneOptional to fetch.
     */
    where?: OneOptionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneOptionals to fetch.
     */
    orderBy?: OneOptionalOrderByWithRelationInput | OneOptionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneOptionals.
     */
    cursor?: OneOptionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OneOptionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OneOptionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneOptionals.
     */
    distinct?: OneOptionalScalarFieldEnum | OneOptionalScalarFieldEnum[]
  }

  /**
   * OneOptional findMany
   */
  export type OneOptionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    /**
     * Filter, which OneOptionals to fetch.
     */
    where?: OneOptionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneOptionals to fetch.
     */
    orderBy?: OneOptionalOrderByWithRelationInput | OneOptionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OneOptionals.
     */
    cursor?: OneOptionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OneOptionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OneOptionals.
     */
    skip?: number
    distinct?: OneOptionalScalarFieldEnum | OneOptionalScalarFieldEnum[]
  }

  /**
   * OneOptional create
   */
  export type OneOptionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    /**
     * The data needed to create a OneOptional.
     */
    data: XOR<OneOptionalCreateInput, OneOptionalUncheckedCreateInput>
  }

  /**
   * OneOptional createMany
   */
  export type OneOptionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OneOptionals.
     */
    data: OneOptionalCreateManyInput | OneOptionalCreateManyInput[]
  }

  /**
   * OneOptional update
   */
  export type OneOptionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    /**
     * The data needed to update a OneOptional.
     */
    data: XOR<OneOptionalUpdateInput, OneOptionalUncheckedUpdateInput>
    /**
     * Choose, which OneOptional to update.
     */
    where: OneOptionalWhereUniqueInput
  }

  /**
   * OneOptional updateMany
   */
  export type OneOptionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OneOptionals.
     */
    data: XOR<OneOptionalUpdateManyMutationInput, OneOptionalUncheckedUpdateManyInput>
    /**
     * Filter which OneOptionals to update
     */
    where?: OneOptionalWhereInput
  }

  /**
   * OneOptional upsert
   */
  export type OneOptionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    /**
     * The filter to search for the OneOptional to update in case it exists.
     */
    where: OneOptionalWhereUniqueInput
    /**
     * In case the OneOptional found by the \`where\` argument doesn't exist, create a new OneOptional with this data.
     */
    create: XOR<OneOptionalCreateInput, OneOptionalUncheckedCreateInput>
    /**
     * In case the OneOptional was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<OneOptionalUpdateInput, OneOptionalUncheckedUpdateInput>
  }

  /**
   * OneOptional delete
   */
  export type OneOptionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    /**
     * Filter which OneOptional to delete.
     */
    where: OneOptionalWhereUniqueInput
  }

  /**
   * OneOptional deleteMany
   */
  export type OneOptionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneOptionals to delete
     */
    where?: OneOptionalWhereInput
  }

  /**
   * OneOptional findRaw
   */
  export type OneOptionalFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OneOptional aggregateRaw
   */
  export type OneOptionalAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OneOptional.many
   */
  export type OneOptional$manyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    where?: ManyRequiredWhereInput
    orderBy?: ManyRequiredOrderByWithRelationInput | ManyRequiredOrderByWithRelationInput[]
    cursor?: ManyRequiredWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManyRequiredScalarFieldEnum | ManyRequiredScalarFieldEnum[]
  }

  /**
   * OneOptional without action
   */
  export type OneOptionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
  }


  /**
   * Model ManyRequired
   */

  export type AggregateManyRequired = {
    _count: ManyRequiredCountAggregateOutputType | null
    _avg: ManyRequiredAvgAggregateOutputType | null
    _sum: ManyRequiredSumAggregateOutputType | null
    _min: ManyRequiredMinAggregateOutputType | null
    _max: ManyRequiredMaxAggregateOutputType | null
  }

  export type ManyRequiredAvgAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type ManyRequiredSumAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type ManyRequiredMinAggregateOutputType = {
    id: string | null
    oneOptionalId: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type ManyRequiredMaxAggregateOutputType = {
    id: string | null
    oneOptionalId: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type ManyRequiredCountAggregateOutputType = {
    id: number
    oneOptionalId: number
    int: number
    optionalInt: number
    float: number
    optionalFloat: number
    string: number
    optionalString: number
    json: number
    optionalJson: number
    enum: number
    optionalEnum: number
    boolean: number
    optionalBoolean: number
    _all: number
  }


  export type ManyRequiredAvgAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type ManyRequiredSumAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type ManyRequiredMinAggregateInputType = {
    id?: true
    oneOptionalId?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type ManyRequiredMaxAggregateInputType = {
    id?: true
    oneOptionalId?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type ManyRequiredCountAggregateInputType = {
    id?: true
    oneOptionalId?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    json?: true
    optionalJson?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
    _all?: true
  }

  export type ManyRequiredAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManyRequired to aggregate.
     */
    where?: ManyRequiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManyRequireds to fetch.
     */
    orderBy?: ManyRequiredOrderByWithRelationInput | ManyRequiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManyRequiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` ManyRequireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` ManyRequireds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManyRequireds
    **/
    _count?: true | ManyRequiredCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManyRequiredAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManyRequiredSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManyRequiredMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManyRequiredMaxAggregateInputType
  }

  export type GetManyRequiredAggregateType<T extends ManyRequiredAggregateArgs> = {
        [P in keyof T & keyof AggregateManyRequired]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManyRequired[P]>
      : GetScalarType<T[P], AggregateManyRequired[P]>
  }




  export type ManyRequiredGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManyRequiredWhereInput
    orderBy?: ManyRequiredOrderByWithAggregationInput | ManyRequiredOrderByWithAggregationInput[]
    by: ManyRequiredScalarFieldEnum[] | ManyRequiredScalarFieldEnum
    having?: ManyRequiredScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManyRequiredCountAggregateInputType | true
    _avg?: ManyRequiredAvgAggregateInputType
    _sum?: ManyRequiredSumAggregateInputType
    _min?: ManyRequiredMinAggregateInputType
    _max?: ManyRequiredMaxAggregateInputType
  }

  export type ManyRequiredGroupByOutputType = {
    id: string
    oneOptionalId: string | null
    int: number
    optionalInt: number | null
    float: number
    optionalFloat: number | null
    string: string
    optionalString: string | null
    json: JsonValue
    optionalJson: JsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean: boolean | null
    _count: ManyRequiredCountAggregateOutputType | null
    _avg: ManyRequiredAvgAggregateOutputType | null
    _sum: ManyRequiredSumAggregateOutputType | null
    _min: ManyRequiredMinAggregateOutputType | null
    _max: ManyRequiredMaxAggregateOutputType | null
  }

  type GetManyRequiredGroupByPayload<T extends ManyRequiredGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManyRequiredGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManyRequiredGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManyRequiredGroupByOutputType[P]>
            : GetScalarType<T[P], ManyRequiredGroupByOutputType[P]>
        }
      >
    >


  export type ManyRequiredSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    oneOptionalId?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
    one?: boolean | ManyRequired$oneArgs<ExtArgs>
  }, ExtArgs["result"]["manyRequired"]>


  export type ManyRequiredSelectScalar = {
    id?: boolean
    oneOptionalId?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
  }

  export type ManyRequiredInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    one?: boolean | ManyRequired$oneArgs<ExtArgs>
  }

  export type $ManyRequiredPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManyRequired"
    objects: {
      one: Prisma.$OneOptionalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      oneOptionalId: string | null
      int: number
      optionalInt: number | null
      float: number
      optionalFloat: number | null
      string: string
      optionalString: string | null
      json: Prisma.JsonValue
      optionalJson: Prisma.JsonValue | null
      enum: $Enums.ABeautifulEnum
      optionalEnum: $Enums.ABeautifulEnum | null
      boolean: boolean
      optionalBoolean: boolean | null
    }, ExtArgs["result"]["manyRequired"]>
    composites: {}
  }

  type ManyRequiredGetPayload<S extends boolean | null | undefined | ManyRequiredDefaultArgs> = $Result.GetResult<Prisma.$ManyRequiredPayload, S>

  type ManyRequiredCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ManyRequiredFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ManyRequiredCountAggregateInputType | true
    }

  export interface ManyRequiredDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManyRequired'], meta: { name: 'ManyRequired' } }
    /**
     * Find zero or one ManyRequired that matches the filter.
     * @param {ManyRequiredFindUniqueArgs} args - Arguments to find a ManyRequired
     * @example
     * // Get one ManyRequired
     * const manyRequired = await prisma.manyRequired.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManyRequiredFindUniqueArgs>(args: SelectSubset<T, ManyRequiredFindUniqueArgs<ExtArgs>>): Prisma__ManyRequiredClient<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ManyRequired that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {ManyRequiredFindUniqueOrThrowArgs} args - Arguments to find a ManyRequired
     * @example
     * // Get one ManyRequired
     * const manyRequired = await prisma.manyRequired.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManyRequiredFindUniqueOrThrowArgs>(args: SelectSubset<T, ManyRequiredFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManyRequiredClient<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ManyRequired that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManyRequiredFindFirstArgs} args - Arguments to find a ManyRequired
     * @example
     * // Get one ManyRequired
     * const manyRequired = await prisma.manyRequired.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManyRequiredFindFirstArgs>(args?: SelectSubset<T, ManyRequiredFindFirstArgs<ExtArgs>>): Prisma__ManyRequiredClient<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ManyRequired that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManyRequiredFindFirstOrThrowArgs} args - Arguments to find a ManyRequired
     * @example
     * // Get one ManyRequired
     * const manyRequired = await prisma.manyRequired.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManyRequiredFindFirstOrThrowArgs>(args?: SelectSubset<T, ManyRequiredFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManyRequiredClient<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ManyRequireds that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManyRequiredFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManyRequireds
     * const manyRequireds = await prisma.manyRequired.findMany()
     * 
     * // Get first 10 ManyRequireds
     * const manyRequireds = await prisma.manyRequired.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const manyRequiredWithIdOnly = await prisma.manyRequired.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManyRequiredFindManyArgs>(args?: SelectSubset<T, ManyRequiredFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ManyRequired.
     * @param {ManyRequiredCreateArgs} args - Arguments to create a ManyRequired.
     * @example
     * // Create one ManyRequired
     * const ManyRequired = await prisma.manyRequired.create({
     *   data: {
     *     // ... data to create a ManyRequired
     *   }
     * })
     * 
     */
    create<T extends ManyRequiredCreateArgs>(args: SelectSubset<T, ManyRequiredCreateArgs<ExtArgs>>): Prisma__ManyRequiredClient<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ManyRequireds.
     * @param {ManyRequiredCreateManyArgs} args - Arguments to create many ManyRequireds.
     * @example
     * // Create many ManyRequireds
     * const manyRequired = await prisma.manyRequired.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManyRequiredCreateManyArgs>(args?: SelectSubset<T, ManyRequiredCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ManyRequired.
     * @param {ManyRequiredDeleteArgs} args - Arguments to delete one ManyRequired.
     * @example
     * // Delete one ManyRequired
     * const ManyRequired = await prisma.manyRequired.delete({
     *   where: {
     *     // ... filter to delete one ManyRequired
     *   }
     * })
     * 
     */
    delete<T extends ManyRequiredDeleteArgs>(args: SelectSubset<T, ManyRequiredDeleteArgs<ExtArgs>>): Prisma__ManyRequiredClient<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ManyRequired.
     * @param {ManyRequiredUpdateArgs} args - Arguments to update one ManyRequired.
     * @example
     * // Update one ManyRequired
     * const manyRequired = await prisma.manyRequired.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManyRequiredUpdateArgs>(args: SelectSubset<T, ManyRequiredUpdateArgs<ExtArgs>>): Prisma__ManyRequiredClient<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ManyRequireds.
     * @param {ManyRequiredDeleteManyArgs} args - Arguments to filter ManyRequireds to delete.
     * @example
     * // Delete a few ManyRequireds
     * const { count } = await prisma.manyRequired.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManyRequiredDeleteManyArgs>(args?: SelectSubset<T, ManyRequiredDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManyRequireds.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManyRequiredUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManyRequireds
     * const manyRequired = await prisma.manyRequired.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManyRequiredUpdateManyArgs>(args: SelectSubset<T, ManyRequiredUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ManyRequired.
     * @param {ManyRequiredUpsertArgs} args - Arguments to update or create a ManyRequired.
     * @example
     * // Update or create a ManyRequired
     * const manyRequired = await prisma.manyRequired.upsert({
     *   create: {
     *     // ... data to create a ManyRequired
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManyRequired we want to update
     *   }
     * })
     */
    upsert<T extends ManyRequiredUpsertArgs>(args: SelectSubset<T, ManyRequiredUpsertArgs<ExtArgs>>): Prisma__ManyRequiredClient<$Result.GetResult<Prisma.$ManyRequiredPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more ManyRequireds that matches the filter.
     * @param {ManyRequiredFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const manyRequired = await prisma.manyRequired.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ManyRequiredFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ManyRequired.
     * @param {ManyRequiredAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const manyRequired = await prisma.manyRequired.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ManyRequiredAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ManyRequireds.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManyRequiredCountArgs} args - Arguments to filter ManyRequireds to count.
     * @example
     * // Count the number of ManyRequireds
     * const count = await prisma.manyRequired.count({
     *   where: {
     *     // ... the filter for the ManyRequireds we want to count
     *   }
     * })
    **/
    count<T extends ManyRequiredCountArgs>(
      args?: Subset<T, ManyRequiredCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManyRequiredCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManyRequired.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManyRequiredAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManyRequiredAggregateArgs>(args: Subset<T, ManyRequiredAggregateArgs>): Prisma.PrismaPromise<GetManyRequiredAggregateType<T>>

    /**
     * Group by ManyRequired.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManyRequiredGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManyRequiredGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManyRequiredGroupByArgs['orderBy'] }
        : { orderBy?: ManyRequiredGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManyRequiredGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManyRequiredGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManyRequired model
   */
  readonly fields: ManyRequiredFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManyRequired.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManyRequiredClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    one<T extends ManyRequired$oneArgs<ExtArgs> = {}>(args?: Subset<T, ManyRequired$oneArgs<ExtArgs>>): Prisma__OneOptionalClient<$Result.GetResult<Prisma.$OneOptionalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManyRequired model
   */ 
  interface ManyRequiredFieldRefs {
    readonly id: FieldRef<"ManyRequired", 'String'>
    readonly oneOptionalId: FieldRef<"ManyRequired", 'String'>
    readonly int: FieldRef<"ManyRequired", 'Int'>
    readonly optionalInt: FieldRef<"ManyRequired", 'Int'>
    readonly float: FieldRef<"ManyRequired", 'Float'>
    readonly optionalFloat: FieldRef<"ManyRequired", 'Float'>
    readonly string: FieldRef<"ManyRequired", 'String'>
    readonly optionalString: FieldRef<"ManyRequired", 'String'>
    readonly json: FieldRef<"ManyRequired", 'Json'>
    readonly optionalJson: FieldRef<"ManyRequired", 'Json'>
    readonly enum: FieldRef<"ManyRequired", 'ABeautifulEnum'>
    readonly optionalEnum: FieldRef<"ManyRequired", 'ABeautifulEnum'>
    readonly boolean: FieldRef<"ManyRequired", 'Boolean'>
    readonly optionalBoolean: FieldRef<"ManyRequired", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ManyRequired findUnique
   */
  export type ManyRequiredFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    /**
     * Filter, which ManyRequired to fetch.
     */
    where: ManyRequiredWhereUniqueInput
  }

  /**
   * ManyRequired findUniqueOrThrow
   */
  export type ManyRequiredFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    /**
     * Filter, which ManyRequired to fetch.
     */
    where: ManyRequiredWhereUniqueInput
  }

  /**
   * ManyRequired findFirst
   */
  export type ManyRequiredFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    /**
     * Filter, which ManyRequired to fetch.
     */
    where?: ManyRequiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManyRequireds to fetch.
     */
    orderBy?: ManyRequiredOrderByWithRelationInput | ManyRequiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManyRequireds.
     */
    cursor?: ManyRequiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` ManyRequireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` ManyRequireds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManyRequireds.
     */
    distinct?: ManyRequiredScalarFieldEnum | ManyRequiredScalarFieldEnum[]
  }

  /**
   * ManyRequired findFirstOrThrow
   */
  export type ManyRequiredFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    /**
     * Filter, which ManyRequired to fetch.
     */
    where?: ManyRequiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManyRequireds to fetch.
     */
    orderBy?: ManyRequiredOrderByWithRelationInput | ManyRequiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManyRequireds.
     */
    cursor?: ManyRequiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` ManyRequireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` ManyRequireds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManyRequireds.
     */
    distinct?: ManyRequiredScalarFieldEnum | ManyRequiredScalarFieldEnum[]
  }

  /**
   * ManyRequired findMany
   */
  export type ManyRequiredFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    /**
     * Filter, which ManyRequireds to fetch.
     */
    where?: ManyRequiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManyRequireds to fetch.
     */
    orderBy?: ManyRequiredOrderByWithRelationInput | ManyRequiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManyRequireds.
     */
    cursor?: ManyRequiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` ManyRequireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` ManyRequireds.
     */
    skip?: number
    distinct?: ManyRequiredScalarFieldEnum | ManyRequiredScalarFieldEnum[]
  }

  /**
   * ManyRequired create
   */
  export type ManyRequiredCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    /**
     * The data needed to create a ManyRequired.
     */
    data: XOR<ManyRequiredCreateInput, ManyRequiredUncheckedCreateInput>
  }

  /**
   * ManyRequired createMany
   */
  export type ManyRequiredCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManyRequireds.
     */
    data: ManyRequiredCreateManyInput | ManyRequiredCreateManyInput[]
  }

  /**
   * ManyRequired update
   */
  export type ManyRequiredUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    /**
     * The data needed to update a ManyRequired.
     */
    data: XOR<ManyRequiredUpdateInput, ManyRequiredUncheckedUpdateInput>
    /**
     * Choose, which ManyRequired to update.
     */
    where: ManyRequiredWhereUniqueInput
  }

  /**
   * ManyRequired updateMany
   */
  export type ManyRequiredUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManyRequireds.
     */
    data: XOR<ManyRequiredUpdateManyMutationInput, ManyRequiredUncheckedUpdateManyInput>
    /**
     * Filter which ManyRequireds to update
     */
    where?: ManyRequiredWhereInput
  }

  /**
   * ManyRequired upsert
   */
  export type ManyRequiredUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    /**
     * The filter to search for the ManyRequired to update in case it exists.
     */
    where: ManyRequiredWhereUniqueInput
    /**
     * In case the ManyRequired found by the \`where\` argument doesn't exist, create a new ManyRequired with this data.
     */
    create: XOR<ManyRequiredCreateInput, ManyRequiredUncheckedCreateInput>
    /**
     * In case the ManyRequired was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<ManyRequiredUpdateInput, ManyRequiredUncheckedUpdateInput>
  }

  /**
   * ManyRequired delete
   */
  export type ManyRequiredDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
    /**
     * Filter which ManyRequired to delete.
     */
    where: ManyRequiredWhereUniqueInput
  }

  /**
   * ManyRequired deleteMany
   */
  export type ManyRequiredDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManyRequireds to delete
     */
    where?: ManyRequiredWhereInput
  }

  /**
   * ManyRequired findRaw
   */
  export type ManyRequiredFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ManyRequired aggregateRaw
   */
  export type ManyRequiredAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ManyRequired.one
   */
  export type ManyRequired$oneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneOptional
     */
    select?: OneOptionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OneOptionalInclude<ExtArgs> | null
    where?: OneOptionalWhereInput
  }

  /**
   * ManyRequired without action
   */
  export type ManyRequiredDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManyRequired
     */
    select?: ManyRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManyRequiredInclude<ExtArgs> | null
  }


  /**
   * Model OptionalSide1
   */

  export type AggregateOptionalSide1 = {
    _count: OptionalSide1CountAggregateOutputType | null
    _avg: OptionalSide1AvgAggregateOutputType | null
    _sum: OptionalSide1SumAggregateOutputType | null
    _min: OptionalSide1MinAggregateOutputType | null
    _max: OptionalSide1MaxAggregateOutputType | null
  }

  export type OptionalSide1AvgAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type OptionalSide1SumAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type OptionalSide1MinAggregateOutputType = {
    id: string | null
    optionalSide2Id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type OptionalSide1MaxAggregateOutputType = {
    id: string | null
    optionalSide2Id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type OptionalSide1CountAggregateOutputType = {
    id: number
    optionalSide2Id: number
    int: number
    optionalInt: number
    float: number
    optionalFloat: number
    string: number
    optionalString: number
    json: number
    optionalJson: number
    enum: number
    optionalEnum: number
    boolean: number
    optionalBoolean: number
    _all: number
  }


  export type OptionalSide1AvgAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type OptionalSide1SumAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type OptionalSide1MinAggregateInputType = {
    id?: true
    optionalSide2Id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type OptionalSide1MaxAggregateInputType = {
    id?: true
    optionalSide2Id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type OptionalSide1CountAggregateInputType = {
    id?: true
    optionalSide2Id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    json?: true
    optionalJson?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
    _all?: true
  }

  export type OptionalSide1AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionalSide1 to aggregate.
     */
    where?: OptionalSide1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionalSide1s to fetch.
     */
    orderBy?: OptionalSide1OrderByWithRelationInput | OptionalSide1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionalSide1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OptionalSide1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OptionalSide1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptionalSide1s
    **/
    _count?: true | OptionalSide1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionalSide1AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionalSide1SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionalSide1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionalSide1MaxAggregateInputType
  }

  export type GetOptionalSide1AggregateType<T extends OptionalSide1AggregateArgs> = {
        [P in keyof T & keyof AggregateOptionalSide1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptionalSide1[P]>
      : GetScalarType<T[P], AggregateOptionalSide1[P]>
  }




  export type OptionalSide1GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionalSide1WhereInput
    orderBy?: OptionalSide1OrderByWithAggregationInput | OptionalSide1OrderByWithAggregationInput[]
    by: OptionalSide1ScalarFieldEnum[] | OptionalSide1ScalarFieldEnum
    having?: OptionalSide1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionalSide1CountAggregateInputType | true
    _avg?: OptionalSide1AvgAggregateInputType
    _sum?: OptionalSide1SumAggregateInputType
    _min?: OptionalSide1MinAggregateInputType
    _max?: OptionalSide1MaxAggregateInputType
  }

  export type OptionalSide1GroupByOutputType = {
    id: string
    optionalSide2Id: string | null
    int: number
    optionalInt: number | null
    float: number
    optionalFloat: number | null
    string: string
    optionalString: string | null
    json: JsonValue
    optionalJson: JsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean: boolean | null
    _count: OptionalSide1CountAggregateOutputType | null
    _avg: OptionalSide1AvgAggregateOutputType | null
    _sum: OptionalSide1SumAggregateOutputType | null
    _min: OptionalSide1MinAggregateOutputType | null
    _max: OptionalSide1MaxAggregateOutputType | null
  }

  type GetOptionalSide1GroupByPayload<T extends OptionalSide1GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionalSide1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionalSide1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionalSide1GroupByOutputType[P]>
            : GetScalarType<T[P], OptionalSide1GroupByOutputType[P]>
        }
      >
    >


  export type OptionalSide1Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionalSide2Id?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
    opti?: boolean | OptionalSide1$optiArgs<ExtArgs>
  }, ExtArgs["result"]["optionalSide1"]>


  export type OptionalSide1SelectScalar = {
    id?: boolean
    optionalSide2Id?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
  }

  export type OptionalSide1Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opti?: boolean | OptionalSide1$optiArgs<ExtArgs>
  }

  export type $OptionalSide1Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OptionalSide1"
    objects: {
      opti: Prisma.$OptionalSide2Payload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      optionalSide2Id: string | null
      int: number
      optionalInt: number | null
      float: number
      optionalFloat: number | null
      string: string
      optionalString: string | null
      json: Prisma.JsonValue
      optionalJson: Prisma.JsonValue | null
      enum: $Enums.ABeautifulEnum
      optionalEnum: $Enums.ABeautifulEnum | null
      boolean: boolean
      optionalBoolean: boolean | null
    }, ExtArgs["result"]["optionalSide1"]>
    composites: {}
  }

  type OptionalSide1GetPayload<S extends boolean | null | undefined | OptionalSide1DefaultArgs> = $Result.GetResult<Prisma.$OptionalSide1Payload, S>

  type OptionalSide1CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OptionalSide1FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OptionalSide1CountAggregateInputType | true
    }

  export interface OptionalSide1Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OptionalSide1'], meta: { name: 'OptionalSide1' } }
    /**
     * Find zero or one OptionalSide1 that matches the filter.
     * @param {OptionalSide1FindUniqueArgs} args - Arguments to find a OptionalSide1
     * @example
     * // Get one OptionalSide1
     * const optionalSide1 = await prisma.optionalSide1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptionalSide1FindUniqueArgs>(args: SelectSubset<T, OptionalSide1FindUniqueArgs<ExtArgs>>): Prisma__OptionalSide1Client<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OptionalSide1 that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {OptionalSide1FindUniqueOrThrowArgs} args - Arguments to find a OptionalSide1
     * @example
     * // Get one OptionalSide1
     * const optionalSide1 = await prisma.optionalSide1.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptionalSide1FindUniqueOrThrowArgs>(args: SelectSubset<T, OptionalSide1FindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptionalSide1Client<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OptionalSide1 that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide1FindFirstArgs} args - Arguments to find a OptionalSide1
     * @example
     * // Get one OptionalSide1
     * const optionalSide1 = await prisma.optionalSide1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptionalSide1FindFirstArgs>(args?: SelectSubset<T, OptionalSide1FindFirstArgs<ExtArgs>>): Prisma__OptionalSide1Client<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OptionalSide1 that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide1FindFirstOrThrowArgs} args - Arguments to find a OptionalSide1
     * @example
     * // Get one OptionalSide1
     * const optionalSide1 = await prisma.optionalSide1.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptionalSide1FindFirstOrThrowArgs>(args?: SelectSubset<T, OptionalSide1FindFirstOrThrowArgs<ExtArgs>>): Prisma__OptionalSide1Client<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OptionalSide1s that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide1FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptionalSide1s
     * const optionalSide1s = await prisma.optionalSide1.findMany()
     * 
     * // Get first 10 OptionalSide1s
     * const optionalSide1s = await prisma.optionalSide1.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const optionalSide1WithIdOnly = await prisma.optionalSide1.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptionalSide1FindManyArgs>(args?: SelectSubset<T, OptionalSide1FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "findMany">>

    /**
     * Create a OptionalSide1.
     * @param {OptionalSide1CreateArgs} args - Arguments to create a OptionalSide1.
     * @example
     * // Create one OptionalSide1
     * const OptionalSide1 = await prisma.optionalSide1.create({
     *   data: {
     *     // ... data to create a OptionalSide1
     *   }
     * })
     * 
     */
    create<T extends OptionalSide1CreateArgs>(args: SelectSubset<T, OptionalSide1CreateArgs<ExtArgs>>): Prisma__OptionalSide1Client<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OptionalSide1s.
     * @param {OptionalSide1CreateManyArgs} args - Arguments to create many OptionalSide1s.
     * @example
     * // Create many OptionalSide1s
     * const optionalSide1 = await prisma.optionalSide1.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptionalSide1CreateManyArgs>(args?: SelectSubset<T, OptionalSide1CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OptionalSide1.
     * @param {OptionalSide1DeleteArgs} args - Arguments to delete one OptionalSide1.
     * @example
     * // Delete one OptionalSide1
     * const OptionalSide1 = await prisma.optionalSide1.delete({
     *   where: {
     *     // ... filter to delete one OptionalSide1
     *   }
     * })
     * 
     */
    delete<T extends OptionalSide1DeleteArgs>(args: SelectSubset<T, OptionalSide1DeleteArgs<ExtArgs>>): Prisma__OptionalSide1Client<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OptionalSide1.
     * @param {OptionalSide1UpdateArgs} args - Arguments to update one OptionalSide1.
     * @example
     * // Update one OptionalSide1
     * const optionalSide1 = await prisma.optionalSide1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptionalSide1UpdateArgs>(args: SelectSubset<T, OptionalSide1UpdateArgs<ExtArgs>>): Prisma__OptionalSide1Client<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OptionalSide1s.
     * @param {OptionalSide1DeleteManyArgs} args - Arguments to filter OptionalSide1s to delete.
     * @example
     * // Delete a few OptionalSide1s
     * const { count } = await prisma.optionalSide1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptionalSide1DeleteManyArgs>(args?: SelectSubset<T, OptionalSide1DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptionalSide1s.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptionalSide1s
     * const optionalSide1 = await prisma.optionalSide1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptionalSide1UpdateManyArgs>(args: SelectSubset<T, OptionalSide1UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OptionalSide1.
     * @param {OptionalSide1UpsertArgs} args - Arguments to update or create a OptionalSide1.
     * @example
     * // Update or create a OptionalSide1
     * const optionalSide1 = await prisma.optionalSide1.upsert({
     *   create: {
     *     // ... data to create a OptionalSide1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptionalSide1 we want to update
     *   }
     * })
     */
    upsert<T extends OptionalSide1UpsertArgs>(args: SelectSubset<T, OptionalSide1UpsertArgs<ExtArgs>>): Prisma__OptionalSide1Client<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more OptionalSide1s that matches the filter.
     * @param {OptionalSide1FindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const optionalSide1 = await prisma.optionalSide1.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: OptionalSide1FindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OptionalSide1.
     * @param {OptionalSide1AggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const optionalSide1 = await prisma.optionalSide1.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OptionalSide1AggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of OptionalSide1s.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide1CountArgs} args - Arguments to filter OptionalSide1s to count.
     * @example
     * // Count the number of OptionalSide1s
     * const count = await prisma.optionalSide1.count({
     *   where: {
     *     // ... the filter for the OptionalSide1s we want to count
     *   }
     * })
    **/
    count<T extends OptionalSide1CountArgs>(
      args?: Subset<T, OptionalSide1CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionalSide1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptionalSide1.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionalSide1AggregateArgs>(args: Subset<T, OptionalSide1AggregateArgs>): Prisma.PrismaPromise<GetOptionalSide1AggregateType<T>>

    /**
     * Group by OptionalSide1.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionalSide1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionalSide1GroupByArgs['orderBy'] }
        : { orderBy?: OptionalSide1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionalSide1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionalSide1GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OptionalSide1 model
   */
  readonly fields: OptionalSide1FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OptionalSide1.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptionalSide1Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opti<T extends OptionalSide1$optiArgs<ExtArgs> = {}>(args?: Subset<T, OptionalSide1$optiArgs<ExtArgs>>): Prisma__OptionalSide2Client<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OptionalSide1 model
   */ 
  interface OptionalSide1FieldRefs {
    readonly id: FieldRef<"OptionalSide1", 'String'>
    readonly optionalSide2Id: FieldRef<"OptionalSide1", 'String'>
    readonly int: FieldRef<"OptionalSide1", 'Int'>
    readonly optionalInt: FieldRef<"OptionalSide1", 'Int'>
    readonly float: FieldRef<"OptionalSide1", 'Float'>
    readonly optionalFloat: FieldRef<"OptionalSide1", 'Float'>
    readonly string: FieldRef<"OptionalSide1", 'String'>
    readonly optionalString: FieldRef<"OptionalSide1", 'String'>
    readonly json: FieldRef<"OptionalSide1", 'Json'>
    readonly optionalJson: FieldRef<"OptionalSide1", 'Json'>
    readonly enum: FieldRef<"OptionalSide1", 'ABeautifulEnum'>
    readonly optionalEnum: FieldRef<"OptionalSide1", 'ABeautifulEnum'>
    readonly boolean: FieldRef<"OptionalSide1", 'Boolean'>
    readonly optionalBoolean: FieldRef<"OptionalSide1", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OptionalSide1 findUnique
   */
  export type OptionalSide1FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide1 to fetch.
     */
    where: OptionalSide1WhereUniqueInput
  }

  /**
   * OptionalSide1 findUniqueOrThrow
   */
  export type OptionalSide1FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide1 to fetch.
     */
    where: OptionalSide1WhereUniqueInput
  }

  /**
   * OptionalSide1 findFirst
   */
  export type OptionalSide1FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide1 to fetch.
     */
    where?: OptionalSide1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionalSide1s to fetch.
     */
    orderBy?: OptionalSide1OrderByWithRelationInput | OptionalSide1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionalSide1s.
     */
    cursor?: OptionalSide1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OptionalSide1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OptionalSide1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionalSide1s.
     */
    distinct?: OptionalSide1ScalarFieldEnum | OptionalSide1ScalarFieldEnum[]
  }

  /**
   * OptionalSide1 findFirstOrThrow
   */
  export type OptionalSide1FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide1 to fetch.
     */
    where?: OptionalSide1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionalSide1s to fetch.
     */
    orderBy?: OptionalSide1OrderByWithRelationInput | OptionalSide1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionalSide1s.
     */
    cursor?: OptionalSide1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OptionalSide1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OptionalSide1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionalSide1s.
     */
    distinct?: OptionalSide1ScalarFieldEnum | OptionalSide1ScalarFieldEnum[]
  }

  /**
   * OptionalSide1 findMany
   */
  export type OptionalSide1FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide1s to fetch.
     */
    where?: OptionalSide1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionalSide1s to fetch.
     */
    orderBy?: OptionalSide1OrderByWithRelationInput | OptionalSide1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptionalSide1s.
     */
    cursor?: OptionalSide1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OptionalSide1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OptionalSide1s.
     */
    skip?: number
    distinct?: OptionalSide1ScalarFieldEnum | OptionalSide1ScalarFieldEnum[]
  }

  /**
   * OptionalSide1 create
   */
  export type OptionalSide1CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    /**
     * The data needed to create a OptionalSide1.
     */
    data: XOR<OptionalSide1CreateInput, OptionalSide1UncheckedCreateInput>
  }

  /**
   * OptionalSide1 createMany
   */
  export type OptionalSide1CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OptionalSide1s.
     */
    data: OptionalSide1CreateManyInput | OptionalSide1CreateManyInput[]
  }

  /**
   * OptionalSide1 update
   */
  export type OptionalSide1UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    /**
     * The data needed to update a OptionalSide1.
     */
    data: XOR<OptionalSide1UpdateInput, OptionalSide1UncheckedUpdateInput>
    /**
     * Choose, which OptionalSide1 to update.
     */
    where: OptionalSide1WhereUniqueInput
  }

  /**
   * OptionalSide1 updateMany
   */
  export type OptionalSide1UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OptionalSide1s.
     */
    data: XOR<OptionalSide1UpdateManyMutationInput, OptionalSide1UncheckedUpdateManyInput>
    /**
     * Filter which OptionalSide1s to update
     */
    where?: OptionalSide1WhereInput
  }

  /**
   * OptionalSide1 upsert
   */
  export type OptionalSide1UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    /**
     * The filter to search for the OptionalSide1 to update in case it exists.
     */
    where: OptionalSide1WhereUniqueInput
    /**
     * In case the OptionalSide1 found by the \`where\` argument doesn't exist, create a new OptionalSide1 with this data.
     */
    create: XOR<OptionalSide1CreateInput, OptionalSide1UncheckedCreateInput>
    /**
     * In case the OptionalSide1 was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<OptionalSide1UpdateInput, OptionalSide1UncheckedUpdateInput>
  }

  /**
   * OptionalSide1 delete
   */
  export type OptionalSide1DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    /**
     * Filter which OptionalSide1 to delete.
     */
    where: OptionalSide1WhereUniqueInput
  }

  /**
   * OptionalSide1 deleteMany
   */
  export type OptionalSide1DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionalSide1s to delete
     */
    where?: OptionalSide1WhereInput
  }

  /**
   * OptionalSide1 findRaw
   */
  export type OptionalSide1FindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OptionalSide1 aggregateRaw
   */
  export type OptionalSide1AggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OptionalSide1.opti
   */
  export type OptionalSide1$optiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    where?: OptionalSide2WhereInput
  }

  /**
   * OptionalSide1 without action
   */
  export type OptionalSide1DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
  }


  /**
   * Model OptionalSide2
   */

  export type AggregateOptionalSide2 = {
    _count: OptionalSide2CountAggregateOutputType | null
    _avg: OptionalSide2AvgAggregateOutputType | null
    _sum: OptionalSide2SumAggregateOutputType | null
    _min: OptionalSide2MinAggregateOutputType | null
    _max: OptionalSide2MaxAggregateOutputType | null
  }

  export type OptionalSide2AvgAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type OptionalSide2SumAggregateOutputType = {
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
  }

  export type OptionalSide2MinAggregateOutputType = {
    id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type OptionalSide2MaxAggregateOutputType = {
    id: string | null
    int: number | null
    optionalInt: number | null
    float: number | null
    optionalFloat: number | null
    string: string | null
    optionalString: string | null
    enum: $Enums.ABeautifulEnum | null
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean | null
    optionalBoolean: boolean | null
  }

  export type OptionalSide2CountAggregateOutputType = {
    id: number
    int: number
    optionalInt: number
    float: number
    optionalFloat: number
    string: number
    optionalString: number
    json: number
    optionalJson: number
    enum: number
    optionalEnum: number
    boolean: number
    optionalBoolean: number
    _all: number
  }


  export type OptionalSide2AvgAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type OptionalSide2SumAggregateInputType = {
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
  }

  export type OptionalSide2MinAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type OptionalSide2MaxAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
  }

  export type OptionalSide2CountAggregateInputType = {
    id?: true
    int?: true
    optionalInt?: true
    float?: true
    optionalFloat?: true
    string?: true
    optionalString?: true
    json?: true
    optionalJson?: true
    enum?: true
    optionalEnum?: true
    boolean?: true
    optionalBoolean?: true
    _all?: true
  }

  export type OptionalSide2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionalSide2 to aggregate.
     */
    where?: OptionalSide2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionalSide2s to fetch.
     */
    orderBy?: OptionalSide2OrderByWithRelationInput | OptionalSide2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionalSide2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OptionalSide2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OptionalSide2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptionalSide2s
    **/
    _count?: true | OptionalSide2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionalSide2AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionalSide2SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionalSide2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionalSide2MaxAggregateInputType
  }

  export type GetOptionalSide2AggregateType<T extends OptionalSide2AggregateArgs> = {
        [P in keyof T & keyof AggregateOptionalSide2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptionalSide2[P]>
      : GetScalarType<T[P], AggregateOptionalSide2[P]>
  }




  export type OptionalSide2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionalSide2WhereInput
    orderBy?: OptionalSide2OrderByWithAggregationInput | OptionalSide2OrderByWithAggregationInput[]
    by: OptionalSide2ScalarFieldEnum[] | OptionalSide2ScalarFieldEnum
    having?: OptionalSide2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionalSide2CountAggregateInputType | true
    _avg?: OptionalSide2AvgAggregateInputType
    _sum?: OptionalSide2SumAggregateInputType
    _min?: OptionalSide2MinAggregateInputType
    _max?: OptionalSide2MaxAggregateInputType
  }

  export type OptionalSide2GroupByOutputType = {
    id: string
    int: number
    optionalInt: number | null
    float: number
    optionalFloat: number | null
    string: string
    optionalString: string | null
    json: JsonValue
    optionalJson: JsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean: boolean | null
    _count: OptionalSide2CountAggregateOutputType | null
    _avg: OptionalSide2AvgAggregateOutputType | null
    _sum: OptionalSide2SumAggregateOutputType | null
    _min: OptionalSide2MinAggregateOutputType | null
    _max: OptionalSide2MaxAggregateOutputType | null
  }

  type GetOptionalSide2GroupByPayload<T extends OptionalSide2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionalSide2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionalSide2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionalSide2GroupByOutputType[P]>
            : GetScalarType<T[P], OptionalSide2GroupByOutputType[P]>
        }
      >
    >


  export type OptionalSide2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
    opti?: boolean | OptionalSide2$optiArgs<ExtArgs>
  }, ExtArgs["result"]["optionalSide2"]>


  export type OptionalSide2SelectScalar = {
    id?: boolean
    int?: boolean
    optionalInt?: boolean
    float?: boolean
    optionalFloat?: boolean
    string?: boolean
    optionalString?: boolean
    json?: boolean
    optionalJson?: boolean
    enum?: boolean
    optionalEnum?: boolean
    boolean?: boolean
    optionalBoolean?: boolean
  }

  export type OptionalSide2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opti?: boolean | OptionalSide2$optiArgs<ExtArgs>
  }

  export type $OptionalSide2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OptionalSide2"
    objects: {
      opti: Prisma.$OptionalSide1Payload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      int: number
      optionalInt: number | null
      float: number
      optionalFloat: number | null
      string: string
      optionalString: string | null
      json: Prisma.JsonValue
      optionalJson: Prisma.JsonValue | null
      enum: $Enums.ABeautifulEnum
      optionalEnum: $Enums.ABeautifulEnum | null
      boolean: boolean
      optionalBoolean: boolean | null
    }, ExtArgs["result"]["optionalSide2"]>
    composites: {}
  }

  type OptionalSide2GetPayload<S extends boolean | null | undefined | OptionalSide2DefaultArgs> = $Result.GetResult<Prisma.$OptionalSide2Payload, S>

  type OptionalSide2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OptionalSide2FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OptionalSide2CountAggregateInputType | true
    }

  export interface OptionalSide2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OptionalSide2'], meta: { name: 'OptionalSide2' } }
    /**
     * Find zero or one OptionalSide2 that matches the filter.
     * @param {OptionalSide2FindUniqueArgs} args - Arguments to find a OptionalSide2
     * @example
     * // Get one OptionalSide2
     * const optionalSide2 = await prisma.optionalSide2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptionalSide2FindUniqueArgs>(args: SelectSubset<T, OptionalSide2FindUniqueArgs<ExtArgs>>): Prisma__OptionalSide2Client<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OptionalSide2 that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {OptionalSide2FindUniqueOrThrowArgs} args - Arguments to find a OptionalSide2
     * @example
     * // Get one OptionalSide2
     * const optionalSide2 = await prisma.optionalSide2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptionalSide2FindUniqueOrThrowArgs>(args: SelectSubset<T, OptionalSide2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptionalSide2Client<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OptionalSide2 that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide2FindFirstArgs} args - Arguments to find a OptionalSide2
     * @example
     * // Get one OptionalSide2
     * const optionalSide2 = await prisma.optionalSide2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptionalSide2FindFirstArgs>(args?: SelectSubset<T, OptionalSide2FindFirstArgs<ExtArgs>>): Prisma__OptionalSide2Client<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OptionalSide2 that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide2FindFirstOrThrowArgs} args - Arguments to find a OptionalSide2
     * @example
     * // Get one OptionalSide2
     * const optionalSide2 = await prisma.optionalSide2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptionalSide2FindFirstOrThrowArgs>(args?: SelectSubset<T, OptionalSide2FindFirstOrThrowArgs<ExtArgs>>): Prisma__OptionalSide2Client<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OptionalSide2s that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptionalSide2s
     * const optionalSide2s = await prisma.optionalSide2.findMany()
     * 
     * // Get first 10 OptionalSide2s
     * const optionalSide2s = await prisma.optionalSide2.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const optionalSide2WithIdOnly = await prisma.optionalSide2.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptionalSide2FindManyArgs>(args?: SelectSubset<T, OptionalSide2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "findMany">>

    /**
     * Create a OptionalSide2.
     * @param {OptionalSide2CreateArgs} args - Arguments to create a OptionalSide2.
     * @example
     * // Create one OptionalSide2
     * const OptionalSide2 = await prisma.optionalSide2.create({
     *   data: {
     *     // ... data to create a OptionalSide2
     *   }
     * })
     * 
     */
    create<T extends OptionalSide2CreateArgs>(args: SelectSubset<T, OptionalSide2CreateArgs<ExtArgs>>): Prisma__OptionalSide2Client<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OptionalSide2s.
     * @param {OptionalSide2CreateManyArgs} args - Arguments to create many OptionalSide2s.
     * @example
     * // Create many OptionalSide2s
     * const optionalSide2 = await prisma.optionalSide2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptionalSide2CreateManyArgs>(args?: SelectSubset<T, OptionalSide2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OptionalSide2.
     * @param {OptionalSide2DeleteArgs} args - Arguments to delete one OptionalSide2.
     * @example
     * // Delete one OptionalSide2
     * const OptionalSide2 = await prisma.optionalSide2.delete({
     *   where: {
     *     // ... filter to delete one OptionalSide2
     *   }
     * })
     * 
     */
    delete<T extends OptionalSide2DeleteArgs>(args: SelectSubset<T, OptionalSide2DeleteArgs<ExtArgs>>): Prisma__OptionalSide2Client<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OptionalSide2.
     * @param {OptionalSide2UpdateArgs} args - Arguments to update one OptionalSide2.
     * @example
     * // Update one OptionalSide2
     * const optionalSide2 = await prisma.optionalSide2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptionalSide2UpdateArgs>(args: SelectSubset<T, OptionalSide2UpdateArgs<ExtArgs>>): Prisma__OptionalSide2Client<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OptionalSide2s.
     * @param {OptionalSide2DeleteManyArgs} args - Arguments to filter OptionalSide2s to delete.
     * @example
     * // Delete a few OptionalSide2s
     * const { count } = await prisma.optionalSide2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptionalSide2DeleteManyArgs>(args?: SelectSubset<T, OptionalSide2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptionalSide2s.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptionalSide2s
     * const optionalSide2 = await prisma.optionalSide2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptionalSide2UpdateManyArgs>(args: SelectSubset<T, OptionalSide2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OptionalSide2.
     * @param {OptionalSide2UpsertArgs} args - Arguments to update or create a OptionalSide2.
     * @example
     * // Update or create a OptionalSide2
     * const optionalSide2 = await prisma.optionalSide2.upsert({
     *   create: {
     *     // ... data to create a OptionalSide2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptionalSide2 we want to update
     *   }
     * })
     */
    upsert<T extends OptionalSide2UpsertArgs>(args: SelectSubset<T, OptionalSide2UpsertArgs<ExtArgs>>): Prisma__OptionalSide2Client<$Result.GetResult<Prisma.$OptionalSide2Payload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more OptionalSide2s that matches the filter.
     * @param {OptionalSide2FindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const optionalSide2 = await prisma.optionalSide2.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: OptionalSide2FindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OptionalSide2.
     * @param {OptionalSide2AggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const optionalSide2 = await prisma.optionalSide2.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OptionalSide2AggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of OptionalSide2s.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide2CountArgs} args - Arguments to filter OptionalSide2s to count.
     * @example
     * // Count the number of OptionalSide2s
     * const count = await prisma.optionalSide2.count({
     *   where: {
     *     // ... the filter for the OptionalSide2s we want to count
     *   }
     * })
    **/
    count<T extends OptionalSide2CountArgs>(
      args?: Subset<T, OptionalSide2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionalSide2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptionalSide2.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionalSide2AggregateArgs>(args: Subset<T, OptionalSide2AggregateArgs>): Prisma.PrismaPromise<GetOptionalSide2AggregateType<T>>

    /**
     * Group by OptionalSide2.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionalSide2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionalSide2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionalSide2GroupByArgs['orderBy'] }
        : { orderBy?: OptionalSide2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionalSide2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionalSide2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OptionalSide2 model
   */
  readonly fields: OptionalSide2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OptionalSide2.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptionalSide2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opti<T extends OptionalSide2$optiArgs<ExtArgs> = {}>(args?: Subset<T, OptionalSide2$optiArgs<ExtArgs>>): Prisma__OptionalSide1Client<$Result.GetResult<Prisma.$OptionalSide1Payload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OptionalSide2 model
   */ 
  interface OptionalSide2FieldRefs {
    readonly id: FieldRef<"OptionalSide2", 'String'>
    readonly int: FieldRef<"OptionalSide2", 'Int'>
    readonly optionalInt: FieldRef<"OptionalSide2", 'Int'>
    readonly float: FieldRef<"OptionalSide2", 'Float'>
    readonly optionalFloat: FieldRef<"OptionalSide2", 'Float'>
    readonly string: FieldRef<"OptionalSide2", 'String'>
    readonly optionalString: FieldRef<"OptionalSide2", 'String'>
    readonly json: FieldRef<"OptionalSide2", 'Json'>
    readonly optionalJson: FieldRef<"OptionalSide2", 'Json'>
    readonly enum: FieldRef<"OptionalSide2", 'ABeautifulEnum'>
    readonly optionalEnum: FieldRef<"OptionalSide2", 'ABeautifulEnum'>
    readonly boolean: FieldRef<"OptionalSide2", 'Boolean'>
    readonly optionalBoolean: FieldRef<"OptionalSide2", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OptionalSide2 findUnique
   */
  export type OptionalSide2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide2 to fetch.
     */
    where: OptionalSide2WhereUniqueInput
  }

  /**
   * OptionalSide2 findUniqueOrThrow
   */
  export type OptionalSide2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide2 to fetch.
     */
    where: OptionalSide2WhereUniqueInput
  }

  /**
   * OptionalSide2 findFirst
   */
  export type OptionalSide2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide2 to fetch.
     */
    where?: OptionalSide2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionalSide2s to fetch.
     */
    orderBy?: OptionalSide2OrderByWithRelationInput | OptionalSide2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionalSide2s.
     */
    cursor?: OptionalSide2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OptionalSide2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OptionalSide2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionalSide2s.
     */
    distinct?: OptionalSide2ScalarFieldEnum | OptionalSide2ScalarFieldEnum[]
  }

  /**
   * OptionalSide2 findFirstOrThrow
   */
  export type OptionalSide2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide2 to fetch.
     */
    where?: OptionalSide2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionalSide2s to fetch.
     */
    orderBy?: OptionalSide2OrderByWithRelationInput | OptionalSide2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionalSide2s.
     */
    cursor?: OptionalSide2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OptionalSide2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OptionalSide2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionalSide2s.
     */
    distinct?: OptionalSide2ScalarFieldEnum | OptionalSide2ScalarFieldEnum[]
  }

  /**
   * OptionalSide2 findMany
   */
  export type OptionalSide2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    /**
     * Filter, which OptionalSide2s to fetch.
     */
    where?: OptionalSide2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionalSide2s to fetch.
     */
    orderBy?: OptionalSide2OrderByWithRelationInput | OptionalSide2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptionalSide2s.
     */
    cursor?: OptionalSide2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` OptionalSide2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` OptionalSide2s.
     */
    skip?: number
    distinct?: OptionalSide2ScalarFieldEnum | OptionalSide2ScalarFieldEnum[]
  }

  /**
   * OptionalSide2 create
   */
  export type OptionalSide2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    /**
     * The data needed to create a OptionalSide2.
     */
    data: XOR<OptionalSide2CreateInput, OptionalSide2UncheckedCreateInput>
  }

  /**
   * OptionalSide2 createMany
   */
  export type OptionalSide2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OptionalSide2s.
     */
    data: OptionalSide2CreateManyInput | OptionalSide2CreateManyInput[]
  }

  /**
   * OptionalSide2 update
   */
  export type OptionalSide2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    /**
     * The data needed to update a OptionalSide2.
     */
    data: XOR<OptionalSide2UpdateInput, OptionalSide2UncheckedUpdateInput>
    /**
     * Choose, which OptionalSide2 to update.
     */
    where: OptionalSide2WhereUniqueInput
  }

  /**
   * OptionalSide2 updateMany
   */
  export type OptionalSide2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OptionalSide2s.
     */
    data: XOR<OptionalSide2UpdateManyMutationInput, OptionalSide2UncheckedUpdateManyInput>
    /**
     * Filter which OptionalSide2s to update
     */
    where?: OptionalSide2WhereInput
  }

  /**
   * OptionalSide2 upsert
   */
  export type OptionalSide2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    /**
     * The filter to search for the OptionalSide2 to update in case it exists.
     */
    where: OptionalSide2WhereUniqueInput
    /**
     * In case the OptionalSide2 found by the \`where\` argument doesn't exist, create a new OptionalSide2 with this data.
     */
    create: XOR<OptionalSide2CreateInput, OptionalSide2UncheckedCreateInput>
    /**
     * In case the OptionalSide2 was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<OptionalSide2UpdateInput, OptionalSide2UncheckedUpdateInput>
  }

  /**
   * OptionalSide2 delete
   */
  export type OptionalSide2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
    /**
     * Filter which OptionalSide2 to delete.
     */
    where: OptionalSide2WhereUniqueInput
  }

  /**
   * OptionalSide2 deleteMany
   */
  export type OptionalSide2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionalSide2s to delete
     */
    where?: OptionalSide2WhereInput
  }

  /**
   * OptionalSide2 findRaw
   */
  export type OptionalSide2FindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OptionalSide2 aggregateRaw
   */
  export type OptionalSide2AggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OptionalSide2.opti
   */
  export type OptionalSide2$optiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide1
     */
    select?: OptionalSide1Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide1Include<ExtArgs> | null
    where?: OptionalSide1WhereInput
  }

  /**
   * OptionalSide2 without action
   */
  export type OptionalSide2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionalSide2
     */
    select?: OptionalSide2Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionalSide2Include<ExtArgs> | null
  }


  /**
   * Model A
   */

  export type AggregateA = {
    _count: ACountAggregateOutputType | null
    _avg: AAvgAggregateOutputType | null
    _sum: ASumAggregateOutputType | null
    _min: AMinAggregateOutputType | null
    _max: AMaxAggregateOutputType | null
  }

  export type AAvgAggregateOutputType = {
    int: number | null
    sInt: number | null
    bInt: number | null
  }

  export type ASumAggregateOutputType = {
    int: number | null
    sInt: number | null
    bInt: bigint | null
  }

  export type AMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    int: number | null
    sInt: number | null
    bInt: bigint | null
  }

  export type AMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    int: number | null
    sInt: number | null
    bInt: bigint | null
  }

  export type ACountAggregateOutputType = {
    id: number
    email: number
    name: number
    int: number
    sInt: number
    bInt: number
    _all: number
  }


  export type AAvgAggregateInputType = {
    int?: true
    sInt?: true
    bInt?: true
  }

  export type ASumAggregateInputType = {
    int?: true
    sInt?: true
    bInt?: true
  }

  export type AMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    int?: true
    sInt?: true
    bInt?: true
  }

  export type AMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    int?: true
    sInt?: true
    bInt?: true
  }

  export type ACountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    int?: true
    sInt?: true
    bInt?: true
    _all?: true
  }

  export type AAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which A to aggregate.
     */
    where?: AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AS to fetch.
     */
    orderBy?: AOrderByWithRelationInput | AOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` AS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AS
    **/
    _count?: true | ACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AMaxAggregateInputType
  }

  export type GetAAggregateType<T extends AAggregateArgs> = {
        [P in keyof T & keyof AggregateA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateA[P]>
      : GetScalarType<T[P], AggregateA[P]>
  }




  export type AGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AWhereInput
    orderBy?: AOrderByWithAggregationInput | AOrderByWithAggregationInput[]
    by: AScalarFieldEnum[] | AScalarFieldEnum
    having?: AScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ACountAggregateInputType | true
    _avg?: AAvgAggregateInputType
    _sum?: ASumAggregateInputType
    _min?: AMinAggregateInputType
    _max?: AMaxAggregateInputType
  }

  export type AGroupByOutputType = {
    id: string
    email: string
    name: string | null
    int: number
    sInt: number
    bInt: bigint
    _count: ACountAggregateOutputType | null
    _avg: AAvgAggregateOutputType | null
    _sum: ASumAggregateOutputType | null
    _min: AMinAggregateOutputType | null
    _max: AMaxAggregateOutputType | null
  }

  type GetAGroupByPayload<T extends AGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AGroupByOutputType[P]>
            : GetScalarType<T[P], AGroupByOutputType[P]>
        }
      >
    >


  export type ASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    int?: boolean
    sInt?: boolean
    bInt?: boolean
  }, ExtArgs["result"]["a"]>


  export type ASelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    int?: boolean
    sInt?: boolean
    bInt?: boolean
  }


  export type $APayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "A"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      /**
       * field comment 1
       */
      id: string
      email: string
      name: string | null
      /**
       * field comment 2
       */
      int: number
      sInt: number
      bInt: bigint
    }, ExtArgs["result"]["a"]>
    composites: {}
  }

  type AGetPayload<S extends boolean | null | undefined | ADefaultArgs> = $Result.GetResult<Prisma.$APayload, S>

  type ACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ACountAggregateInputType | true
    }

  export interface ADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['A'], meta: { name: 'A' } }
    /**
     * Find zero or one A that matches the filter.
     * @param {AFindUniqueArgs} args - Arguments to find a A
     * @example
     * // Get one A
     * const a = await prisma.a.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AFindUniqueArgs>(args: SelectSubset<T, AFindUniqueArgs<ExtArgs>>): Prisma__AClient<$Result.GetResult<Prisma.$APayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one A that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {AFindUniqueOrThrowArgs} args - Arguments to find a A
     * @example
     * // Get one A
     * const a = await prisma.a.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AFindUniqueOrThrowArgs>(args: SelectSubset<T, AFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AClient<$Result.GetResult<Prisma.$APayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first A that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AFindFirstArgs} args - Arguments to find a A
     * @example
     * // Get one A
     * const a = await prisma.a.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AFindFirstArgs>(args?: SelectSubset<T, AFindFirstArgs<ExtArgs>>): Prisma__AClient<$Result.GetResult<Prisma.$APayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first A that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AFindFirstOrThrowArgs} args - Arguments to find a A
     * @example
     * // Get one A
     * const a = await prisma.a.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AFindFirstOrThrowArgs>(args?: SelectSubset<T, AFindFirstOrThrowArgs<ExtArgs>>): Prisma__AClient<$Result.GetResult<Prisma.$APayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more As that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all As
     * const as = await prisma.a.findMany()
     * 
     * // Get first 10 As
     * const as = await prisma.a.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const aWithIdOnly = await prisma.a.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AFindManyArgs>(args?: SelectSubset<T, AFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$APayload<ExtArgs>, T, "findMany">>

    /**
     * Create a A.
     * @param {ACreateArgs} args - Arguments to create a A.
     * @example
     * // Create one A
     * const A = await prisma.a.create({
     *   data: {
     *     // ... data to create a A
     *   }
     * })
     * 
     */
    create<T extends ACreateArgs>(args: SelectSubset<T, ACreateArgs<ExtArgs>>): Prisma__AClient<$Result.GetResult<Prisma.$APayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many As.
     * @param {ACreateManyArgs} args - Arguments to create many As.
     * @example
     * // Create many As
     * const a = await prisma.a.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ACreateManyArgs>(args?: SelectSubset<T, ACreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a A.
     * @param {ADeleteArgs} args - Arguments to delete one A.
     * @example
     * // Delete one A
     * const A = await prisma.a.delete({
     *   where: {
     *     // ... filter to delete one A
     *   }
     * })
     * 
     */
    delete<T extends ADeleteArgs>(args: SelectSubset<T, ADeleteArgs<ExtArgs>>): Prisma__AClient<$Result.GetResult<Prisma.$APayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one A.
     * @param {AUpdateArgs} args - Arguments to update one A.
     * @example
     * // Update one A
     * const a = await prisma.a.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AUpdateArgs>(args: SelectSubset<T, AUpdateArgs<ExtArgs>>): Prisma__AClient<$Result.GetResult<Prisma.$APayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more As.
     * @param {ADeleteManyArgs} args - Arguments to filter As to delete.
     * @example
     * // Delete a few As
     * const { count } = await prisma.a.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ADeleteManyArgs>(args?: SelectSubset<T, ADeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more As.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many As
     * const a = await prisma.a.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AUpdateManyArgs>(args: SelectSubset<T, AUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one A.
     * @param {AUpsertArgs} args - Arguments to update or create a A.
     * @example
     * // Update or create a A
     * const a = await prisma.a.upsert({
     *   create: {
     *     // ... data to create a A
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the A we want to update
     *   }
     * })
     */
    upsert<T extends AUpsertArgs>(args: SelectSubset<T, AUpsertArgs<ExtArgs>>): Prisma__AClient<$Result.GetResult<Prisma.$APayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more As that matches the filter.
     * @param {AFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const a = await prisma.a.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a A.
     * @param {AAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const a = await prisma.a.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of As.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ACountArgs} args - Arguments to filter As to count.
     * @example
     * // Count the number of As
     * const count = await prisma.a.count({
     *   where: {
     *     // ... the filter for the As we want to count
     *   }
     * })
    **/
    count<T extends ACountArgs>(
      args?: Subset<T, ACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a A.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AAggregateArgs>(args: Subset<T, AAggregateArgs>): Prisma.PrismaPromise<GetAAggregateType<T>>

    /**
     * Group by A.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AGroupByArgs['orderBy'] }
        : { orderBy?: AGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, AGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the A model
   */
  readonly fields: AFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for A.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the A model
   */ 
  interface AFieldRefs {
    readonly id: FieldRef<"A", 'String'>
    readonly email: FieldRef<"A", 'String'>
    readonly name: FieldRef<"A", 'String'>
    readonly int: FieldRef<"A", 'Int'>
    readonly sInt: FieldRef<"A", 'Int'>
    readonly bInt: FieldRef<"A", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * A findUnique
   */
  export type AFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
    /**
     * Filter, which A to fetch.
     */
    where: AWhereUniqueInput
  }

  /**
   * A findUniqueOrThrow
   */
  export type AFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
    /**
     * Filter, which A to fetch.
     */
    where: AWhereUniqueInput
  }

  /**
   * A findFirst
   */
  export type AFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
    /**
     * Filter, which A to fetch.
     */
    where?: AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AS to fetch.
     */
    orderBy?: AOrderByWithRelationInput | AOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AS.
     */
    cursor?: AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` AS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AS.
     */
    distinct?: AScalarFieldEnum | AScalarFieldEnum[]
  }

  /**
   * A findFirstOrThrow
   */
  export type AFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
    /**
     * Filter, which A to fetch.
     */
    where?: AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AS to fetch.
     */
    orderBy?: AOrderByWithRelationInput | AOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AS.
     */
    cursor?: AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` AS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AS.
     */
    distinct?: AScalarFieldEnum | AScalarFieldEnum[]
  }

  /**
   * A findMany
   */
  export type AFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
    /**
     * Filter, which AS to fetch.
     */
    where?: AWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AS to fetch.
     */
    orderBy?: AOrderByWithRelationInput | AOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AS.
     */
    cursor?: AWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` AS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` AS.
     */
    skip?: number
    distinct?: AScalarFieldEnum | AScalarFieldEnum[]
  }

  /**
   * A create
   */
  export type ACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
    /**
     * The data needed to create a A.
     */
    data: XOR<ACreateInput, AUncheckedCreateInput>
  }

  /**
   * A createMany
   */
  export type ACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AS.
     */
    data: ACreateManyInput | ACreateManyInput[]
  }

  /**
   * A update
   */
  export type AUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
    /**
     * The data needed to update a A.
     */
    data: XOR<AUpdateInput, AUncheckedUpdateInput>
    /**
     * Choose, which A to update.
     */
    where: AWhereUniqueInput
  }

  /**
   * A updateMany
   */
  export type AUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AS.
     */
    data: XOR<AUpdateManyMutationInput, AUncheckedUpdateManyInput>
    /**
     * Filter which AS to update
     */
    where?: AWhereInput
  }

  /**
   * A upsert
   */
  export type AUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
    /**
     * The filter to search for the A to update in case it exists.
     */
    where: AWhereUniqueInput
    /**
     * In case the A found by the \`where\` argument doesn't exist, create a new A with this data.
     */
    create: XOR<ACreateInput, AUncheckedCreateInput>
    /**
     * In case the A was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<AUpdateInput, AUncheckedUpdateInput>
  }

  /**
   * A delete
   */
  export type ADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
    /**
     * Filter which A to delete.
     */
    where: AWhereUniqueInput
  }

  /**
   * A deleteMany
   */
  export type ADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AS to delete
     */
    where?: AWhereInput
  }

  /**
   * A findRaw
   */
  export type AFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * A aggregateRaw
   */
  export type AAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * A without action
   */
  export type ADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the A
     */
    select?: ASelect<ExtArgs> | null
  }


  /**
   * Model B
   */

  export type AggregateB = {
    _count: BCountAggregateOutputType | null
    _avg: BAvgAggregateOutputType | null
    _sum: BSumAggregateOutputType | null
    _min: BMinAggregateOutputType | null
    _max: BMaxAggregateOutputType | null
  }

  export type BAvgAggregateOutputType = {
    float: number | null
    dFloat: number | null
  }

  export type BSumAggregateOutputType = {
    float: number | null
    dFloat: number | null
  }

  export type BMinAggregateOutputType = {
    id: string | null
    float: number | null
    dFloat: number | null
  }

  export type BMaxAggregateOutputType = {
    id: string | null
    float: number | null
    dFloat: number | null
  }

  export type BCountAggregateOutputType = {
    id: number
    float: number
    dFloat: number
    _all: number
  }


  export type BAvgAggregateInputType = {
    float?: true
    dFloat?: true
  }

  export type BSumAggregateInputType = {
    float?: true
    dFloat?: true
  }

  export type BMinAggregateInputType = {
    id?: true
    float?: true
    dFloat?: true
  }

  export type BMaxAggregateInputType = {
    id?: true
    float?: true
    dFloat?: true
  }

  export type BCountAggregateInputType = {
    id?: true
    float?: true
    dFloat?: true
    _all?: true
  }

  export type BAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which B to aggregate.
     */
    where?: BWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BS to fetch.
     */
    orderBy?: BOrderByWithRelationInput | BOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` BS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` BS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BS
    **/
    _count?: true | BCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BMaxAggregateInputType
  }

  export type GetBAggregateType<T extends BAggregateArgs> = {
        [P in keyof T & keyof AggregateB]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateB[P]>
      : GetScalarType<T[P], AggregateB[P]>
  }




  export type BGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BWhereInput
    orderBy?: BOrderByWithAggregationInput | BOrderByWithAggregationInput[]
    by: BScalarFieldEnum[] | BScalarFieldEnum
    having?: BScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BCountAggregateInputType | true
    _avg?: BAvgAggregateInputType
    _sum?: BSumAggregateInputType
    _min?: BMinAggregateInputType
    _max?: BMaxAggregateInputType
  }

  export type BGroupByOutputType = {
    id: string
    float: number
    dFloat: number
    _count: BCountAggregateOutputType | null
    _avg: BAvgAggregateOutputType | null
    _sum: BSumAggregateOutputType | null
    _min: BMinAggregateOutputType | null
    _max: BMaxAggregateOutputType | null
  }

  type GetBGroupByPayload<T extends BGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BGroupByOutputType[P]>
            : GetScalarType<T[P], BGroupByOutputType[P]>
        }
      >
    >


  export type BSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    float?: boolean
    dFloat?: boolean
  }, ExtArgs["result"]["b"]>


  export type BSelectScalar = {
    id?: boolean
    float?: boolean
    dFloat?: boolean
  }


  export type $BPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "B"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      float: number
      dFloat: number
    }, ExtArgs["result"]["b"]>
    composites: {}
  }

  type BGetPayload<S extends boolean | null | undefined | BDefaultArgs> = $Result.GetResult<Prisma.$BPayload, S>

  type BCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BCountAggregateInputType | true
    }

  export interface BDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['B'], meta: { name: 'B' } }
    /**
     * Find zero or one B that matches the filter.
     * @param {BFindUniqueArgs} args - Arguments to find a B
     * @example
     * // Get one B
     * const b = await prisma.b.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BFindUniqueArgs>(args: SelectSubset<T, BFindUniqueArgs<ExtArgs>>): Prisma__BClient<$Result.GetResult<Prisma.$BPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one B that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {BFindUniqueOrThrowArgs} args - Arguments to find a B
     * @example
     * // Get one B
     * const b = await prisma.b.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BFindUniqueOrThrowArgs>(args: SelectSubset<T, BFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BClient<$Result.GetResult<Prisma.$BPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first B that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BFindFirstArgs} args - Arguments to find a B
     * @example
     * // Get one B
     * const b = await prisma.b.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BFindFirstArgs>(args?: SelectSubset<T, BFindFirstArgs<ExtArgs>>): Prisma__BClient<$Result.GetResult<Prisma.$BPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first B that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BFindFirstOrThrowArgs} args - Arguments to find a B
     * @example
     * // Get one B
     * const b = await prisma.b.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BFindFirstOrThrowArgs>(args?: SelectSubset<T, BFindFirstOrThrowArgs<ExtArgs>>): Prisma__BClient<$Result.GetResult<Prisma.$BPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bs that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bs
     * const bs = await prisma.b.findMany()
     * 
     * // Get first 10 Bs
     * const bs = await prisma.b.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const bWithIdOnly = await prisma.b.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BFindManyArgs>(args?: SelectSubset<T, BFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a B.
     * @param {BCreateArgs} args - Arguments to create a B.
     * @example
     * // Create one B
     * const B = await prisma.b.create({
     *   data: {
     *     // ... data to create a B
     *   }
     * })
     * 
     */
    create<T extends BCreateArgs>(args: SelectSubset<T, BCreateArgs<ExtArgs>>): Prisma__BClient<$Result.GetResult<Prisma.$BPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bs.
     * @param {BCreateManyArgs} args - Arguments to create many Bs.
     * @example
     * // Create many Bs
     * const b = await prisma.b.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BCreateManyArgs>(args?: SelectSubset<T, BCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a B.
     * @param {BDeleteArgs} args - Arguments to delete one B.
     * @example
     * // Delete one B
     * const B = await prisma.b.delete({
     *   where: {
     *     // ... filter to delete one B
     *   }
     * })
     * 
     */
    delete<T extends BDeleteArgs>(args: SelectSubset<T, BDeleteArgs<ExtArgs>>): Prisma__BClient<$Result.GetResult<Prisma.$BPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one B.
     * @param {BUpdateArgs} args - Arguments to update one B.
     * @example
     * // Update one B
     * const b = await prisma.b.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BUpdateArgs>(args: SelectSubset<T, BUpdateArgs<ExtArgs>>): Prisma__BClient<$Result.GetResult<Prisma.$BPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bs.
     * @param {BDeleteManyArgs} args - Arguments to filter Bs to delete.
     * @example
     * // Delete a few Bs
     * const { count } = await prisma.b.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BDeleteManyArgs>(args?: SelectSubset<T, BDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bs.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bs
     * const b = await prisma.b.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BUpdateManyArgs>(args: SelectSubset<T, BUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one B.
     * @param {BUpsertArgs} args - Arguments to update or create a B.
     * @example
     * // Update or create a B
     * const b = await prisma.b.upsert({
     *   create: {
     *     // ... data to create a B
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the B we want to update
     *   }
     * })
     */
    upsert<T extends BUpsertArgs>(args: SelectSubset<T, BUpsertArgs<ExtArgs>>): Prisma__BClient<$Result.GetResult<Prisma.$BPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Bs that matches the filter.
     * @param {BFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const b = await prisma.b.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: BFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a B.
     * @param {BAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const b = await prisma.b.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Bs.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BCountArgs} args - Arguments to filter Bs to count.
     * @example
     * // Count the number of Bs
     * const count = await prisma.b.count({
     *   where: {
     *     // ... the filter for the Bs we want to count
     *   }
     * })
    **/
    count<T extends BCountArgs>(
      args?: Subset<T, BCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a B.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BAggregateArgs>(args: Subset<T, BAggregateArgs>): Prisma.PrismaPromise<GetBAggregateType<T>>

    /**
     * Group by B.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BGroupByArgs['orderBy'] }
        : { orderBy?: BGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, BGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the B model
   */
  readonly fields: BFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for B.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the B model
   */ 
  interface BFieldRefs {
    readonly id: FieldRef<"B", 'String'>
    readonly float: FieldRef<"B", 'Float'>
    readonly dFloat: FieldRef<"B", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * B findUnique
   */
  export type BFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
    /**
     * Filter, which B to fetch.
     */
    where: BWhereUniqueInput
  }

  /**
   * B findUniqueOrThrow
   */
  export type BFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
    /**
     * Filter, which B to fetch.
     */
    where: BWhereUniqueInput
  }

  /**
   * B findFirst
   */
  export type BFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
    /**
     * Filter, which B to fetch.
     */
    where?: BWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BS to fetch.
     */
    orderBy?: BOrderByWithRelationInput | BOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BS.
     */
    cursor?: BWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` BS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` BS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BS.
     */
    distinct?: BScalarFieldEnum | BScalarFieldEnum[]
  }

  /**
   * B findFirstOrThrow
   */
  export type BFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
    /**
     * Filter, which B to fetch.
     */
    where?: BWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BS to fetch.
     */
    orderBy?: BOrderByWithRelationInput | BOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BS.
     */
    cursor?: BWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` BS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` BS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BS.
     */
    distinct?: BScalarFieldEnum | BScalarFieldEnum[]
  }

  /**
   * B findMany
   */
  export type BFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
    /**
     * Filter, which BS to fetch.
     */
    where?: BWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BS to fetch.
     */
    orderBy?: BOrderByWithRelationInput | BOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BS.
     */
    cursor?: BWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` BS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` BS.
     */
    skip?: number
    distinct?: BScalarFieldEnum | BScalarFieldEnum[]
  }

  /**
   * B create
   */
  export type BCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
    /**
     * The data needed to create a B.
     */
    data: XOR<BCreateInput, BUncheckedCreateInput>
  }

  /**
   * B createMany
   */
  export type BCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BS.
     */
    data: BCreateManyInput | BCreateManyInput[]
  }

  /**
   * B update
   */
  export type BUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
    /**
     * The data needed to update a B.
     */
    data: XOR<BUpdateInput, BUncheckedUpdateInput>
    /**
     * Choose, which B to update.
     */
    where: BWhereUniqueInput
  }

  /**
   * B updateMany
   */
  export type BUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BS.
     */
    data: XOR<BUpdateManyMutationInput, BUncheckedUpdateManyInput>
    /**
     * Filter which BS to update
     */
    where?: BWhereInput
  }

  /**
   * B upsert
   */
  export type BUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
    /**
     * The filter to search for the B to update in case it exists.
     */
    where: BWhereUniqueInput
    /**
     * In case the B found by the \`where\` argument doesn't exist, create a new B with this data.
     */
    create: XOR<BCreateInput, BUncheckedCreateInput>
    /**
     * In case the B was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<BUpdateInput, BUncheckedUpdateInput>
  }

  /**
   * B delete
   */
  export type BDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
    /**
     * Filter which B to delete.
     */
    where: BWhereUniqueInput
  }

  /**
   * B deleteMany
   */
  export type BDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BS to delete
     */
    where?: BWhereInput
  }

  /**
   * B findRaw
   */
  export type BFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * B aggregateRaw
   */
  export type BAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * B without action
   */
  export type BDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the B
     */
    select?: BSelect<ExtArgs> | null
  }


  /**
   * Model C
   */

  export type AggregateC = {
    _count: CCountAggregateOutputType | null
    _min: CMinAggregateOutputType | null
    _max: CMaxAggregateOutputType | null
  }

  export type CMinAggregateOutputType = {
    id: string | null
    char: string | null
    vChar: string | null
    text: string | null
    bit: string | null
    vBit: string | null
    uuid: string | null
  }

  export type CMaxAggregateOutputType = {
    id: string | null
    char: string | null
    vChar: string | null
    text: string | null
    bit: string | null
    vBit: string | null
    uuid: string | null
  }

  export type CCountAggregateOutputType = {
    id: number
    char: number
    vChar: number
    text: number
    bit: number
    vBit: number
    uuid: number
    _all: number
  }


  export type CMinAggregateInputType = {
    id?: true
    char?: true
    vChar?: true
    text?: true
    bit?: true
    vBit?: true
    uuid?: true
  }

  export type CMaxAggregateInputType = {
    id?: true
    char?: true
    vChar?: true
    text?: true
    bit?: true
    vBit?: true
    uuid?: true
  }

  export type CCountAggregateInputType = {
    id?: true
    char?: true
    vChar?: true
    text?: true
    bit?: true
    vBit?: true
    uuid?: true
    _all?: true
  }

  export type CAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which C to aggregate.
     */
    where?: CWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CS to fetch.
     */
    orderBy?: COrderByWithRelationInput | COrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` CS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` CS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CS
    **/
    _count?: true | CCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CMaxAggregateInputType
  }

  export type GetCAggregateType<T extends CAggregateArgs> = {
        [P in keyof T & keyof AggregateC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateC[P]>
      : GetScalarType<T[P], AggregateC[P]>
  }




  export type CGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CWhereInput
    orderBy?: COrderByWithAggregationInput | COrderByWithAggregationInput[]
    by: CScalarFieldEnum[] | CScalarFieldEnum
    having?: CScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CCountAggregateInputType | true
    _min?: CMinAggregateInputType
    _max?: CMaxAggregateInputType
  }

  export type CGroupByOutputType = {
    id: string
    char: string
    vChar: string
    text: string
    bit: string
    vBit: string
    uuid: string
    _count: CCountAggregateOutputType | null
    _min: CMinAggregateOutputType | null
    _max: CMaxAggregateOutputType | null
  }

  type GetCGroupByPayload<T extends CGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CGroupByOutputType[P]>
            : GetScalarType<T[P], CGroupByOutputType[P]>
        }
      >
    >


  export type CSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char?: boolean
    vChar?: boolean
    text?: boolean
    bit?: boolean
    vBit?: boolean
    uuid?: boolean
  }, ExtArgs["result"]["c"]>


  export type CSelectScalar = {
    id?: boolean
    char?: boolean
    vChar?: boolean
    text?: boolean
    bit?: boolean
    vBit?: boolean
    uuid?: boolean
  }


  export type $CPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "C"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char: string
      vChar: string
      text: string
      bit: string
      vBit: string
      uuid: string
    }, ExtArgs["result"]["c"]>
    composites: {}
  }

  type CGetPayload<S extends boolean | null | undefined | CDefaultArgs> = $Result.GetResult<Prisma.$CPayload, S>

  type CCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CCountAggregateInputType | true
    }

  export interface CDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['C'], meta: { name: 'C' } }
    /**
     * Find zero or one C that matches the filter.
     * @param {CFindUniqueArgs} args - Arguments to find a C
     * @example
     * // Get one C
     * const c = await prisma.c.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CFindUniqueArgs>(args: SelectSubset<T, CFindUniqueArgs<ExtArgs>>): Prisma__CClient<$Result.GetResult<Prisma.$CPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one C that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {CFindUniqueOrThrowArgs} args - Arguments to find a C
     * @example
     * // Get one C
     * const c = await prisma.c.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CFindUniqueOrThrowArgs>(args: SelectSubset<T, CFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CClient<$Result.GetResult<Prisma.$CPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first C that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFindFirstArgs} args - Arguments to find a C
     * @example
     * // Get one C
     * const c = await prisma.c.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CFindFirstArgs>(args?: SelectSubset<T, CFindFirstArgs<ExtArgs>>): Prisma__CClient<$Result.GetResult<Prisma.$CPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first C that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFindFirstOrThrowArgs} args - Arguments to find a C
     * @example
     * // Get one C
     * const c = await prisma.c.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CFindFirstOrThrowArgs>(args?: SelectSubset<T, CFindFirstOrThrowArgs<ExtArgs>>): Prisma__CClient<$Result.GetResult<Prisma.$CPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cs that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cs
     * const cs = await prisma.c.findMany()
     * 
     * // Get first 10 Cs
     * const cs = await prisma.c.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const cWithIdOnly = await prisma.c.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CFindManyArgs>(args?: SelectSubset<T, CFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a C.
     * @param {CCreateArgs} args - Arguments to create a C.
     * @example
     * // Create one C
     * const C = await prisma.c.create({
     *   data: {
     *     // ... data to create a C
     *   }
     * })
     * 
     */
    create<T extends CCreateArgs>(args: SelectSubset<T, CCreateArgs<ExtArgs>>): Prisma__CClient<$Result.GetResult<Prisma.$CPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cs.
     * @param {CCreateManyArgs} args - Arguments to create many Cs.
     * @example
     * // Create many Cs
     * const c = await prisma.c.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CCreateManyArgs>(args?: SelectSubset<T, CCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a C.
     * @param {CDeleteArgs} args - Arguments to delete one C.
     * @example
     * // Delete one C
     * const C = await prisma.c.delete({
     *   where: {
     *     // ... filter to delete one C
     *   }
     * })
     * 
     */
    delete<T extends CDeleteArgs>(args: SelectSubset<T, CDeleteArgs<ExtArgs>>): Prisma__CClient<$Result.GetResult<Prisma.$CPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one C.
     * @param {CUpdateArgs} args - Arguments to update one C.
     * @example
     * // Update one C
     * const c = await prisma.c.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CUpdateArgs>(args: SelectSubset<T, CUpdateArgs<ExtArgs>>): Prisma__CClient<$Result.GetResult<Prisma.$CPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cs.
     * @param {CDeleteManyArgs} args - Arguments to filter Cs to delete.
     * @example
     * // Delete a few Cs
     * const { count } = await prisma.c.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CDeleteManyArgs>(args?: SelectSubset<T, CDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cs.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cs
     * const c = await prisma.c.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CUpdateManyArgs>(args: SelectSubset<T, CUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one C.
     * @param {CUpsertArgs} args - Arguments to update or create a C.
     * @example
     * // Update or create a C
     * const c = await prisma.c.upsert({
     *   create: {
     *     // ... data to create a C
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the C we want to update
     *   }
     * })
     */
    upsert<T extends CUpsertArgs>(args: SelectSubset<T, CUpsertArgs<ExtArgs>>): Prisma__CClient<$Result.GetResult<Prisma.$CPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Cs that matches the filter.
     * @param {CFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const c = await prisma.c.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a C.
     * @param {CAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const c = await prisma.c.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Cs.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CCountArgs} args - Arguments to filter Cs to count.
     * @example
     * // Count the number of Cs
     * const count = await prisma.c.count({
     *   where: {
     *     // ... the filter for the Cs we want to count
     *   }
     * })
    **/
    count<T extends CCountArgs>(
      args?: Subset<T, CCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a C.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CAggregateArgs>(args: Subset<T, CAggregateArgs>): Prisma.PrismaPromise<GetCAggregateType<T>>

    /**
     * Group by C.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CGroupByArgs['orderBy'] }
        : { orderBy?: CGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, CGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the C model
   */
  readonly fields: CFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for C.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the C model
   */ 
  interface CFieldRefs {
    readonly id: FieldRef<"C", 'String'>
    readonly char: FieldRef<"C", 'String'>
    readonly vChar: FieldRef<"C", 'String'>
    readonly text: FieldRef<"C", 'String'>
    readonly bit: FieldRef<"C", 'String'>
    readonly vBit: FieldRef<"C", 'String'>
    readonly uuid: FieldRef<"C", 'String'>
  }
    

  // Custom InputTypes
  /**
   * C findUnique
   */
  export type CFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
    /**
     * Filter, which C to fetch.
     */
    where: CWhereUniqueInput
  }

  /**
   * C findUniqueOrThrow
   */
  export type CFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
    /**
     * Filter, which C to fetch.
     */
    where: CWhereUniqueInput
  }

  /**
   * C findFirst
   */
  export type CFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
    /**
     * Filter, which C to fetch.
     */
    where?: CWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CS to fetch.
     */
    orderBy?: COrderByWithRelationInput | COrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CS.
     */
    cursor?: CWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` CS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` CS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CS.
     */
    distinct?: CScalarFieldEnum | CScalarFieldEnum[]
  }

  /**
   * C findFirstOrThrow
   */
  export type CFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
    /**
     * Filter, which C to fetch.
     */
    where?: CWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CS to fetch.
     */
    orderBy?: COrderByWithRelationInput | COrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CS.
     */
    cursor?: CWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` CS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` CS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CS.
     */
    distinct?: CScalarFieldEnum | CScalarFieldEnum[]
  }

  /**
   * C findMany
   */
  export type CFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
    /**
     * Filter, which CS to fetch.
     */
    where?: CWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CS to fetch.
     */
    orderBy?: COrderByWithRelationInput | COrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CS.
     */
    cursor?: CWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` CS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` CS.
     */
    skip?: number
    distinct?: CScalarFieldEnum | CScalarFieldEnum[]
  }

  /**
   * C create
   */
  export type CCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
    /**
     * The data needed to create a C.
     */
    data: XOR<CCreateInput, CUncheckedCreateInput>
  }

  /**
   * C createMany
   */
  export type CCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CS.
     */
    data: CCreateManyInput | CCreateManyInput[]
  }

  /**
   * C update
   */
  export type CUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
    /**
     * The data needed to update a C.
     */
    data: XOR<CUpdateInput, CUncheckedUpdateInput>
    /**
     * Choose, which C to update.
     */
    where: CWhereUniqueInput
  }

  /**
   * C updateMany
   */
  export type CUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CS.
     */
    data: XOR<CUpdateManyMutationInput, CUncheckedUpdateManyInput>
    /**
     * Filter which CS to update
     */
    where?: CWhereInput
  }

  /**
   * C upsert
   */
  export type CUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
    /**
     * The filter to search for the C to update in case it exists.
     */
    where: CWhereUniqueInput
    /**
     * In case the C found by the \`where\` argument doesn't exist, create a new C with this data.
     */
    create: XOR<CCreateInput, CUncheckedCreateInput>
    /**
     * In case the C was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<CUpdateInput, CUncheckedUpdateInput>
  }

  /**
   * C delete
   */
  export type CDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
    /**
     * Filter which C to delete.
     */
    where: CWhereUniqueInput
  }

  /**
   * C deleteMany
   */
  export type CDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CS to delete
     */
    where?: CWhereInput
  }

  /**
   * C findRaw
   */
  export type CFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * C aggregateRaw
   */
  export type CAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * C without action
   */
  export type CDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the C
     */
    select?: CSelect<ExtArgs> | null
  }


  /**
   * Model D
   */

  export type AggregateD = {
    _count: DCountAggregateOutputType | null
    _avg: DAvgAggregateOutputType | null
    _sum: DSumAggregateOutputType | null
    _min: DMinAggregateOutputType | null
    _max: DMaxAggregateOutputType | null
  }

  export type DAvgAggregateOutputType = {
    list: number | null
  }

  export type DSumAggregateOutputType = {
    list: number[]
  }

  export type DMinAggregateOutputType = {
    id: string | null
    bool: boolean | null
    byteA: Buffer | null
    xml: string | null
  }

  export type DMaxAggregateOutputType = {
    id: string | null
    bool: boolean | null
    byteA: Buffer | null
    xml: string | null
  }

  export type DCountAggregateOutputType = {
    id: number
    bool: number
    byteA: number
    xml: number
    json: number
    jsonb: number
    list: number
    _all: number
  }


  export type DAvgAggregateInputType = {
    list?: true
  }

  export type DSumAggregateInputType = {
    list?: true
  }

  export type DMinAggregateInputType = {
    id?: true
    bool?: true
    byteA?: true
    xml?: true
  }

  export type DMaxAggregateInputType = {
    id?: true
    bool?: true
    byteA?: true
    xml?: true
  }

  export type DCountAggregateInputType = {
    id?: true
    bool?: true
    byteA?: true
    xml?: true
    json?: true
    jsonb?: true
    list?: true
    _all?: true
  }

  export type DAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which D to aggregate.
     */
    where?: DWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DS to fetch.
     */
    orderBy?: DOrderByWithRelationInput | DOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` DS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` DS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DS
    **/
    _count?: true | DCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DMaxAggregateInputType
  }

  export type GetDAggregateType<T extends DAggregateArgs> = {
        [P in keyof T & keyof AggregateD]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateD[P]>
      : GetScalarType<T[P], AggregateD[P]>
  }




  export type DGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DWhereInput
    orderBy?: DOrderByWithAggregationInput | DOrderByWithAggregationInput[]
    by: DScalarFieldEnum[] | DScalarFieldEnum
    having?: DScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DCountAggregateInputType | true
    _avg?: DAvgAggregateInputType
    _sum?: DSumAggregateInputType
    _min?: DMinAggregateInputType
    _max?: DMaxAggregateInputType
  }

  export type DGroupByOutputType = {
    id: string
    bool: boolean
    byteA: Buffer
    xml: string
    json: JsonValue
    jsonb: JsonValue
    list: number[]
    _count: DCountAggregateOutputType | null
    _avg: DAvgAggregateOutputType | null
    _sum: DSumAggregateOutputType | null
    _min: DMinAggregateOutputType | null
    _max: DMaxAggregateOutputType | null
  }

  type GetDGroupByPayload<T extends DGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DGroupByOutputType[P]>
            : GetScalarType<T[P], DGroupByOutputType[P]>
        }
      >
    >


  export type DSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bool?: boolean
    byteA?: boolean
    xml?: boolean
    json?: boolean
    jsonb?: boolean
    list?: boolean
  }, ExtArgs["result"]["d"]>


  export type DSelectScalar = {
    id?: boolean
    bool?: boolean
    byteA?: boolean
    xml?: boolean
    json?: boolean
    jsonb?: boolean
    list?: boolean
  }


  export type $DPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "D"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bool: boolean
      byteA: Buffer
      xml: string
      json: Prisma.JsonValue
      jsonb: Prisma.JsonValue
      list: number[]
    }, ExtArgs["result"]["d"]>
    composites: {}
  }

  type DGetPayload<S extends boolean | null | undefined | DDefaultArgs> = $Result.GetResult<Prisma.$DPayload, S>

  type DCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DCountAggregateInputType | true
    }

  export interface DDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['D'], meta: { name: 'D' } }
    /**
     * Find zero or one D that matches the filter.
     * @param {DFindUniqueArgs} args - Arguments to find a D
     * @example
     * // Get one D
     * const d = await prisma.d.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DFindUniqueArgs>(args: SelectSubset<T, DFindUniqueArgs<ExtArgs>>): Prisma__DClient<$Result.GetResult<Prisma.$DPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one D that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {DFindUniqueOrThrowArgs} args - Arguments to find a D
     * @example
     * // Get one D
     * const d = await prisma.d.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DFindUniqueOrThrowArgs>(args: SelectSubset<T, DFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DClient<$Result.GetResult<Prisma.$DPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first D that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DFindFirstArgs} args - Arguments to find a D
     * @example
     * // Get one D
     * const d = await prisma.d.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DFindFirstArgs>(args?: SelectSubset<T, DFindFirstArgs<ExtArgs>>): Prisma__DClient<$Result.GetResult<Prisma.$DPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first D that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DFindFirstOrThrowArgs} args - Arguments to find a D
     * @example
     * // Get one D
     * const d = await prisma.d.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DFindFirstOrThrowArgs>(args?: SelectSubset<T, DFindFirstOrThrowArgs<ExtArgs>>): Prisma__DClient<$Result.GetResult<Prisma.$DPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ds that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ds
     * const ds = await prisma.d.findMany()
     * 
     * // Get first 10 Ds
     * const ds = await prisma.d.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const dWithIdOnly = await prisma.d.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DFindManyArgs>(args?: SelectSubset<T, DFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a D.
     * @param {DCreateArgs} args - Arguments to create a D.
     * @example
     * // Create one D
     * const D = await prisma.d.create({
     *   data: {
     *     // ... data to create a D
     *   }
     * })
     * 
     */
    create<T extends DCreateArgs>(args: SelectSubset<T, DCreateArgs<ExtArgs>>): Prisma__DClient<$Result.GetResult<Prisma.$DPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ds.
     * @param {DCreateManyArgs} args - Arguments to create many Ds.
     * @example
     * // Create many Ds
     * const d = await prisma.d.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DCreateManyArgs>(args?: SelectSubset<T, DCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a D.
     * @param {DDeleteArgs} args - Arguments to delete one D.
     * @example
     * // Delete one D
     * const D = await prisma.d.delete({
     *   where: {
     *     // ... filter to delete one D
     *   }
     * })
     * 
     */
    delete<T extends DDeleteArgs>(args: SelectSubset<T, DDeleteArgs<ExtArgs>>): Prisma__DClient<$Result.GetResult<Prisma.$DPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one D.
     * @param {DUpdateArgs} args - Arguments to update one D.
     * @example
     * // Update one D
     * const d = await prisma.d.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DUpdateArgs>(args: SelectSubset<T, DUpdateArgs<ExtArgs>>): Prisma__DClient<$Result.GetResult<Prisma.$DPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ds.
     * @param {DDeleteManyArgs} args - Arguments to filter Ds to delete.
     * @example
     * // Delete a few Ds
     * const { count } = await prisma.d.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DDeleteManyArgs>(args?: SelectSubset<T, DDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ds.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ds
     * const d = await prisma.d.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DUpdateManyArgs>(args: SelectSubset<T, DUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one D.
     * @param {DUpsertArgs} args - Arguments to update or create a D.
     * @example
     * // Update or create a D
     * const d = await prisma.d.upsert({
     *   create: {
     *     // ... data to create a D
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the D we want to update
     *   }
     * })
     */
    upsert<T extends DUpsertArgs>(args: SelectSubset<T, DUpsertArgs<ExtArgs>>): Prisma__DClient<$Result.GetResult<Prisma.$DPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Ds that matches the filter.
     * @param {DFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const d = await prisma.d.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a D.
     * @param {DAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const d = await prisma.d.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Ds.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DCountArgs} args - Arguments to filter Ds to count.
     * @example
     * // Count the number of Ds
     * const count = await prisma.d.count({
     *   where: {
     *     // ... the filter for the Ds we want to count
     *   }
     * })
    **/
    count<T extends DCountArgs>(
      args?: Subset<T, DCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a D.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DAggregateArgs>(args: Subset<T, DAggregateArgs>): Prisma.PrismaPromise<GetDAggregateType<T>>

    /**
     * Group by D.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DGroupByArgs['orderBy'] }
        : { orderBy?: DGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, DGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the D model
   */
  readonly fields: DFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for D.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the D model
   */ 
  interface DFieldRefs {
    readonly id: FieldRef<"D", 'String'>
    readonly bool: FieldRef<"D", 'Boolean'>
    readonly byteA: FieldRef<"D", 'Bytes'>
    readonly xml: FieldRef<"D", 'String'>
    readonly json: FieldRef<"D", 'Json'>
    readonly jsonb: FieldRef<"D", 'Json'>
    readonly list: FieldRef<"D", 'Int[]'>
  }
    

  // Custom InputTypes
  /**
   * D findUnique
   */
  export type DFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
    /**
     * Filter, which D to fetch.
     */
    where: DWhereUniqueInput
  }

  /**
   * D findUniqueOrThrow
   */
  export type DFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
    /**
     * Filter, which D to fetch.
     */
    where: DWhereUniqueInput
  }

  /**
   * D findFirst
   */
  export type DFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
    /**
     * Filter, which D to fetch.
     */
    where?: DWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DS to fetch.
     */
    orderBy?: DOrderByWithRelationInput | DOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DS.
     */
    cursor?: DWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` DS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` DS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DS.
     */
    distinct?: DScalarFieldEnum | DScalarFieldEnum[]
  }

  /**
   * D findFirstOrThrow
   */
  export type DFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
    /**
     * Filter, which D to fetch.
     */
    where?: DWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DS to fetch.
     */
    orderBy?: DOrderByWithRelationInput | DOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DS.
     */
    cursor?: DWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` DS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` DS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DS.
     */
    distinct?: DScalarFieldEnum | DScalarFieldEnum[]
  }

  /**
   * D findMany
   */
  export type DFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
    /**
     * Filter, which DS to fetch.
     */
    where?: DWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DS to fetch.
     */
    orderBy?: DOrderByWithRelationInput | DOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DS.
     */
    cursor?: DWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` DS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` DS.
     */
    skip?: number
    distinct?: DScalarFieldEnum | DScalarFieldEnum[]
  }

  /**
   * D create
   */
  export type DCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
    /**
     * The data needed to create a D.
     */
    data: XOR<DCreateInput, DUncheckedCreateInput>
  }

  /**
   * D createMany
   */
  export type DCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DS.
     */
    data: DCreateManyInput | DCreateManyInput[]
  }

  /**
   * D update
   */
  export type DUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
    /**
     * The data needed to update a D.
     */
    data: XOR<DUpdateInput, DUncheckedUpdateInput>
    /**
     * Choose, which D to update.
     */
    where: DWhereUniqueInput
  }

  /**
   * D updateMany
   */
  export type DUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DS.
     */
    data: XOR<DUpdateManyMutationInput, DUncheckedUpdateManyInput>
    /**
     * Filter which DS to update
     */
    where?: DWhereInput
  }

  /**
   * D upsert
   */
  export type DUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
    /**
     * The filter to search for the D to update in case it exists.
     */
    where: DWhereUniqueInput
    /**
     * In case the D found by the \`where\` argument doesn't exist, create a new D with this data.
     */
    create: XOR<DCreateInput, DUncheckedCreateInput>
    /**
     * In case the D was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<DUpdateInput, DUncheckedUpdateInput>
  }

  /**
   * D delete
   */
  export type DDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
    /**
     * Filter which D to delete.
     */
    where: DWhereUniqueInput
  }

  /**
   * D deleteMany
   */
  export type DDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DS to delete
     */
    where?: DWhereInput
  }

  /**
   * D findRaw
   */
  export type DFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * D aggregateRaw
   */
  export type DAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * D without action
   */
  export type DDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the D
     */
    select?: DSelect<ExtArgs> | null
  }


  /**
   * Model E
   */

  export type AggregateE = {
    _count: ECountAggregateOutputType | null
    _min: EMinAggregateOutputType | null
    _max: EMaxAggregateOutputType | null
  }

  export type EMinAggregateOutputType = {
    id: string | null
    date: Date | null
    time: Date | null
    ts: Date | null
  }

  export type EMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    time: Date | null
    ts: Date | null
  }

  export type ECountAggregateOutputType = {
    id: number
    date: number
    time: number
    ts: number
    _all: number
  }


  export type EMinAggregateInputType = {
    id?: true
    date?: true
    time?: true
    ts?: true
  }

  export type EMaxAggregateInputType = {
    id?: true
    date?: true
    time?: true
    ts?: true
  }

  export type ECountAggregateInputType = {
    id?: true
    date?: true
    time?: true
    ts?: true
    _all?: true
  }

  export type EAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which E to aggregate.
     */
    where?: EWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ES to fetch.
     */
    orderBy?: EOrderByWithRelationInput | EOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` ES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` ES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ES
    **/
    _count?: true | ECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EMaxAggregateInputType
  }

  export type GetEAggregateType<T extends EAggregateArgs> = {
        [P in keyof T & keyof AggregateE]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateE[P]>
      : GetScalarType<T[P], AggregateE[P]>
  }




  export type EGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EWhereInput
    orderBy?: EOrderByWithAggregationInput | EOrderByWithAggregationInput[]
    by: EScalarFieldEnum[] | EScalarFieldEnum
    having?: EScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ECountAggregateInputType | true
    _min?: EMinAggregateInputType
    _max?: EMaxAggregateInputType
  }

  export type EGroupByOutputType = {
    id: string
    date: Date
    time: Date
    ts: Date
    _count: ECountAggregateOutputType | null
    _min: EMinAggregateOutputType | null
    _max: EMaxAggregateOutputType | null
  }

  type GetEGroupByPayload<T extends EGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EGroupByOutputType[P]>
            : GetScalarType<T[P], EGroupByOutputType[P]>
        }
      >
    >


  export type ESelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    ts?: boolean
  }, ExtArgs["result"]["e"]>


  export type ESelectScalar = {
    id?: boolean
    date?: boolean
    time?: boolean
    ts?: boolean
  }


  export type $EPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "E"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      time: Date
      ts: Date
    }, ExtArgs["result"]["e"]>
    composites: {}
  }

  type EGetPayload<S extends boolean | null | undefined | EDefaultArgs> = $Result.GetResult<Prisma.$EPayload, S>

  type ECountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ECountAggregateInputType | true
    }

  export interface EDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['E'], meta: { name: 'E' } }
    /**
     * Find zero or one E that matches the filter.
     * @param {EFindUniqueArgs} args - Arguments to find a E
     * @example
     * // Get one E
     * const e = await prisma.e.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EFindUniqueArgs>(args: SelectSubset<T, EFindUniqueArgs<ExtArgs>>): Prisma__EClient<$Result.GetResult<Prisma.$EPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one E that matches the filter or throw an error with \`error.code='P2025'\` 
     * if no matches were found.
     * @param {EFindUniqueOrThrowArgs} args - Arguments to find a E
     * @example
     * // Get one E
     * const e = await prisma.e.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EFindUniqueOrThrowArgs>(args: SelectSubset<T, EFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EClient<$Result.GetResult<Prisma.$EPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first E that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFindFirstArgs} args - Arguments to find a E
     * @example
     * // Get one E
     * const e = await prisma.e.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EFindFirstArgs>(args?: SelectSubset<T, EFindFirstArgs<ExtArgs>>): Prisma__EClient<$Result.GetResult<Prisma.$EPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first E that matches the filter or
     * throw \`PrismaKnownClientError\` with \`P2025\` code if no matches were found.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFindFirstOrThrowArgs} args - Arguments to find a E
     * @example
     * // Get one E
     * const e = await prisma.e.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EFindFirstOrThrowArgs>(args?: SelectSubset<T, EFindFirstOrThrowArgs<ExtArgs>>): Prisma__EClient<$Result.GetResult<Prisma.$EPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Es that matches the filter.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Es
     * const es = await prisma.e.findMany()
     * 
     * // Get first 10 Es
     * const es = await prisma.e.findMany({ take: 10 })
     * 
     * // Only select the \`id\`
     * const eWithIdOnly = await prisma.e.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EFindManyArgs>(args?: SelectSubset<T, EFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a E.
     * @param {ECreateArgs} args - Arguments to create a E.
     * @example
     * // Create one E
     * const E = await prisma.e.create({
     *   data: {
     *     // ... data to create a E
     *   }
     * })
     * 
     */
    create<T extends ECreateArgs>(args: SelectSubset<T, ECreateArgs<ExtArgs>>): Prisma__EClient<$Result.GetResult<Prisma.$EPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Es.
     * @param {ECreateManyArgs} args - Arguments to create many Es.
     * @example
     * // Create many Es
     * const e = await prisma.e.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ECreateManyArgs>(args?: SelectSubset<T, ECreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a E.
     * @param {EDeleteArgs} args - Arguments to delete one E.
     * @example
     * // Delete one E
     * const E = await prisma.e.delete({
     *   where: {
     *     // ... filter to delete one E
     *   }
     * })
     * 
     */
    delete<T extends EDeleteArgs>(args: SelectSubset<T, EDeleteArgs<ExtArgs>>): Prisma__EClient<$Result.GetResult<Prisma.$EPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one E.
     * @param {EUpdateArgs} args - Arguments to update one E.
     * @example
     * // Update one E
     * const e = await prisma.e.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EUpdateArgs>(args: SelectSubset<T, EUpdateArgs<ExtArgs>>): Prisma__EClient<$Result.GetResult<Prisma.$EPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Es.
     * @param {EDeleteManyArgs} args - Arguments to filter Es to delete.
     * @example
     * // Delete a few Es
     * const { count } = await prisma.e.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EDeleteManyArgs>(args?: SelectSubset<T, EDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Es.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Es
     * const e = await prisma.e.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EUpdateManyArgs>(args: SelectSubset<T, EUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one E.
     * @param {EUpsertArgs} args - Arguments to update or create a E.
     * @example
     * // Update or create a E
     * const e = await prisma.e.upsert({
     *   create: {
     *     // ... data to create a E
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the E we want to update
     *   }
     * })
     */
    upsert<T extends EUpsertArgs>(args: SelectSubset<T, EUpsertArgs<ExtArgs>>): Prisma__EClient<$Result.GetResult<Prisma.$EPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Es that matches the filter.
     * @param {EFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const e = await prisma.e.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: EFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a E.
     * @param {EAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const e = await prisma.e.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Es.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECountArgs} args - Arguments to filter Es to count.
     * @example
     * // Count the number of Es
     * const count = await prisma.e.count({
     *   where: {
     *     // ... the filter for the Es we want to count
     *   }
     * })
    **/
    count<T extends ECountArgs>(
      args?: Subset<T, ECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a E.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EAggregateArgs>(args: Subset<T, EAggregateArgs>): Prisma.PrismaPromise<GetEAggregateType<T>>

    /**
     * Group by E.
     * Note, that providing \`undefined\` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EGroupByArgs['orderBy'] }
        : { orderBy?: EGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? \`Error: "by" must not be empty.\`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? \`Error: Field "\${P}" used in "having" needs to be provided in "by".\`
            : [
                Error,
                'Field ',
                P,
                \` in "having" needs to be provided in "by"\`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : \`Error: Field "\${P}" in "orderBy" needs to be provided in "by"\`
        }[OrderFields]
    >(args: SubsetIntersection<T, EGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the E model
   */
  readonly fields: EFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for E.
   * Why is this prefixed with \`Prisma__\`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the E model
   */ 
  interface EFieldRefs {
    readonly id: FieldRef<"E", 'String'>
    readonly date: FieldRef<"E", 'DateTime'>
    readonly time: FieldRef<"E", 'DateTime'>
    readonly ts: FieldRef<"E", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * E findUnique
   */
  export type EFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
    /**
     * Filter, which E to fetch.
     */
    where: EWhereUniqueInput
  }

  /**
   * E findUniqueOrThrow
   */
  export type EFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
    /**
     * Filter, which E to fetch.
     */
    where: EWhereUniqueInput
  }

  /**
   * E findFirst
   */
  export type EFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
    /**
     * Filter, which E to fetch.
     */
    where?: EWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ES to fetch.
     */
    orderBy?: EOrderByWithRelationInput | EOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ES.
     */
    cursor?: EWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` ES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` ES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ES.
     */
    distinct?: EScalarFieldEnum | EScalarFieldEnum[]
  }

  /**
   * E findFirstOrThrow
   */
  export type EFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
    /**
     * Filter, which E to fetch.
     */
    where?: EWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ES to fetch.
     */
    orderBy?: EOrderByWithRelationInput | EOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ES.
     */
    cursor?: EWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` ES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` ES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ES.
     */
    distinct?: EScalarFieldEnum | EScalarFieldEnum[]
  }

  /**
   * E findMany
   */
  export type EFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
    /**
     * Filter, which ES to fetch.
     */
    where?: EWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ES to fetch.
     */
    orderBy?: EOrderByWithRelationInput | EOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ES.
     */
    cursor?: EWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take \`±n\` ES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first \`n\` ES.
     */
    skip?: number
    distinct?: EScalarFieldEnum | EScalarFieldEnum[]
  }

  /**
   * E create
   */
  export type ECreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
    /**
     * The data needed to create a E.
     */
    data: XOR<ECreateInput, EUncheckedCreateInput>
  }

  /**
   * E createMany
   */
  export type ECreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ES.
     */
    data: ECreateManyInput | ECreateManyInput[]
  }

  /**
   * E update
   */
  export type EUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
    /**
     * The data needed to update a E.
     */
    data: XOR<EUpdateInput, EUncheckedUpdateInput>
    /**
     * Choose, which E to update.
     */
    where: EWhereUniqueInput
  }

  /**
   * E updateMany
   */
  export type EUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ES.
     */
    data: XOR<EUpdateManyMutationInput, EUncheckedUpdateManyInput>
    /**
     * Filter which ES to update
     */
    where?: EWhereInput
  }

  /**
   * E upsert
   */
  export type EUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
    /**
     * The filter to search for the E to update in case it exists.
     */
    where: EWhereUniqueInput
    /**
     * In case the E found by the \`where\` argument doesn't exist, create a new E with this data.
     */
    create: XOR<ECreateInput, EUncheckedCreateInput>
    /**
     * In case the E was found with the provided \`where\` argument, update it with this data.
     */
    update: XOR<EUpdateInput, EUncheckedUpdateInput>
  }

  /**
   * E delete
   */
  export type EDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
    /**
     * Filter which E to delete.
     */
    where: EWhereUniqueInput
  }

  /**
   * E deleteMany
   */
  export type EDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ES to delete
     */
    where?: EWhereInput
  }

  /**
   * E findRaw
   */
  export type EFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. \${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the \`find\` command \${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * E aggregateRaw
   */
  export type EAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. \${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the \`aggregate\` command \${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * E without action
   */
  export type EDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the E
     */
    select?: ESelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const PostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    title: 'title',
    content: 'content',
    published: 'published',
    authorId: 'authorId'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    int: 'int',
    optionalInt: 'optionalInt',
    float: 'float',
    optionalFloat: 'optionalFloat',
    string: 'string',
    optionalString: 'optionalString',
    json: 'json',
    optionalJson: 'optionalJson',
    enum: 'enum',
    optionalEnum: 'optionalEnum',
    boolean: 'boolean',
    optionalBoolean: 'optionalBoolean',
    embedHolderId: 'embedHolderId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmbedHolderScalarFieldEnum: {
    id: 'id',
    time: 'time',
    text: 'text',
    boolean: 'boolean'
  };

  export type EmbedHolderScalarFieldEnum = (typeof EmbedHolderScalarFieldEnum)[keyof typeof EmbedHolderScalarFieldEnum]


  export const MScalarFieldEnum: {
    id: 'id',
    n_ids: 'n_ids',
    int: 'int',
    optionalInt: 'optionalInt',
    float: 'float',
    optionalFloat: 'optionalFloat',
    string: 'string',
    optionalString: 'optionalString',
    json: 'json',
    optionalJson: 'optionalJson',
    enum: 'enum',
    optionalEnum: 'optionalEnum',
    boolean: 'boolean',
    optionalBoolean: 'optionalBoolean'
  };

  export type MScalarFieldEnum = (typeof MScalarFieldEnum)[keyof typeof MScalarFieldEnum]


  export const NScalarFieldEnum: {
    id: 'id',
    m_ids: 'm_ids',
    int: 'int',
    optionalInt: 'optionalInt',
    float: 'float',
    optionalFloat: 'optionalFloat',
    string: 'string',
    optionalString: 'optionalString',
    json: 'json',
    optionalJson: 'optionalJson',
    enum: 'enum',
    optionalEnum: 'optionalEnum',
    boolean: 'boolean',
    optionalBoolean: 'optionalBoolean'
  };

  export type NScalarFieldEnum = (typeof NScalarFieldEnum)[keyof typeof NScalarFieldEnum]


  export const OneOptionalScalarFieldEnum: {
    id: 'id',
    int: 'int',
    optionalInt: 'optionalInt',
    float: 'float',
    optionalFloat: 'optionalFloat',
    string: 'string',
    optionalString: 'optionalString',
    json: 'json',
    optionalJson: 'optionalJson',
    enum: 'enum',
    optionalEnum: 'optionalEnum',
    boolean: 'boolean',
    optionalBoolean: 'optionalBoolean'
  };

  export type OneOptionalScalarFieldEnum = (typeof OneOptionalScalarFieldEnum)[keyof typeof OneOptionalScalarFieldEnum]


  export const ManyRequiredScalarFieldEnum: {
    id: 'id',
    oneOptionalId: 'oneOptionalId',
    int: 'int',
    optionalInt: 'optionalInt',
    float: 'float',
    optionalFloat: 'optionalFloat',
    string: 'string',
    optionalString: 'optionalString',
    json: 'json',
    optionalJson: 'optionalJson',
    enum: 'enum',
    optionalEnum: 'optionalEnum',
    boolean: 'boolean',
    optionalBoolean: 'optionalBoolean'
  };

  export type ManyRequiredScalarFieldEnum = (typeof ManyRequiredScalarFieldEnum)[keyof typeof ManyRequiredScalarFieldEnum]


  export const OptionalSide1ScalarFieldEnum: {
    id: 'id',
    optionalSide2Id: 'optionalSide2Id',
    int: 'int',
    optionalInt: 'optionalInt',
    float: 'float',
    optionalFloat: 'optionalFloat',
    string: 'string',
    optionalString: 'optionalString',
    json: 'json',
    optionalJson: 'optionalJson',
    enum: 'enum',
    optionalEnum: 'optionalEnum',
    boolean: 'boolean',
    optionalBoolean: 'optionalBoolean'
  };

  export type OptionalSide1ScalarFieldEnum = (typeof OptionalSide1ScalarFieldEnum)[keyof typeof OptionalSide1ScalarFieldEnum]


  export const OptionalSide2ScalarFieldEnum: {
    id: 'id',
    int: 'int',
    optionalInt: 'optionalInt',
    float: 'float',
    optionalFloat: 'optionalFloat',
    string: 'string',
    optionalString: 'optionalString',
    json: 'json',
    optionalJson: 'optionalJson',
    enum: 'enum',
    optionalEnum: 'optionalEnum',
    boolean: 'boolean',
    optionalBoolean: 'optionalBoolean'
  };

  export type OptionalSide2ScalarFieldEnum = (typeof OptionalSide2ScalarFieldEnum)[keyof typeof OptionalSide2ScalarFieldEnum]


  export const AScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    int: 'int',
    sInt: 'sInt',
    bInt: 'bInt'
  };

  export type AScalarFieldEnum = (typeof AScalarFieldEnum)[keyof typeof AScalarFieldEnum]


  export const BScalarFieldEnum: {
    id: 'id',
    float: 'float',
    dFloat: 'dFloat'
  };

  export type BScalarFieldEnum = (typeof BScalarFieldEnum)[keyof typeof BScalarFieldEnum]


  export const CScalarFieldEnum: {
    id: 'id',
    char: 'char',
    vChar: 'vChar',
    text: 'text',
    bit: 'bit',
    vBit: 'vBit',
    uuid: 'uuid'
  };

  export type CScalarFieldEnum = (typeof CScalarFieldEnum)[keyof typeof CScalarFieldEnum]


  export const DScalarFieldEnum: {
    id: 'id',
    bool: 'bool',
    byteA: 'byteA',
    xml: 'xml',
    json: 'json',
    jsonb: 'jsonb',
    list: 'list'
  };

  export type DScalarFieldEnum = (typeof DScalarFieldEnum)[keyof typeof DScalarFieldEnum]


  export const EScalarFieldEnum: {
    id: 'id',
    date: 'date',
    time: 'time',
    ts: 'ts'
  };

  export type EScalarFieldEnum = (typeof EScalarFieldEnum)[keyof typeof EScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ABeautifulEnum'
   */
  export type EnumABeautifulEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ABeautifulEnum'>
    


  /**
   * Reference to a field of type 'ABeautifulEnum[]'
   */
  export type ListEnumABeautifulEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ABeautifulEnum[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    
  /**
   * Deep Input Types
   */


  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    title?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    published?: BoolFilter<"Post"> | boolean
    authorId?: StringFilter<"Post"> | string
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    createdAt?: DateTimeFilter<"Post"> | Date | string
    title?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    published?: BoolFilter<"Post"> | boolean
    authorId?: StringFilter<"Post"> | string
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    title?: StringWithAggregatesFilter<"Post"> | string
    content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    published?: BoolWithAggregatesFilter<"Post"> | boolean
    authorId?: StringWithAggregatesFilter<"Post"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    int?: IntFilter<"User"> | number
    optionalInt?: IntNullableFilter<"User"> | number | null
    float?: FloatFilter<"User"> | number
    optionalFloat?: FloatNullableFilter<"User"> | number | null
    string?: StringFilter<"User"> | string
    optionalString?: StringNullableFilter<"User"> | string | null
    json?: JsonFilter<"User">
    optionalJson?: JsonNullableFilter<"User">
    enum?: EnumABeautifulEnumFilter<"User"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"User"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"User"> | boolean
    optionalBoolean?: BoolNullableFilter<"User"> | boolean | null
    embedHolderId?: StringFilter<"User"> | string
    posts?: PostListRelationFilter
    embedHolder?: XOR<EmbedHolderRelationFilter, EmbedHolderWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    embedHolderId?: SortOrder
    posts?: PostOrderByRelationAggregateInput
    embedHolder?: EmbedHolderOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    int?: IntFilter<"User"> | number
    optionalInt?: IntNullableFilter<"User"> | number | null
    float?: FloatFilter<"User"> | number
    optionalFloat?: FloatNullableFilter<"User"> | number | null
    string?: StringFilter<"User"> | string
    optionalString?: StringNullableFilter<"User"> | string | null
    json?: JsonFilter<"User">
    optionalJson?: JsonNullableFilter<"User">
    enum?: EnumABeautifulEnumFilter<"User"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"User"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"User"> | boolean
    optionalBoolean?: BoolNullableFilter<"User"> | boolean | null
    embedHolderId?: StringFilter<"User"> | string
    posts?: PostListRelationFilter
    embedHolder?: XOR<EmbedHolderRelationFilter, EmbedHolderWhereInput>
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    embedHolderId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    int?: IntWithAggregatesFilter<"User"> | number
    optionalInt?: IntNullableWithAggregatesFilter<"User"> | number | null
    float?: FloatWithAggregatesFilter<"User"> | number
    optionalFloat?: FloatNullableWithAggregatesFilter<"User"> | number | null
    string?: StringWithAggregatesFilter<"User"> | string
    optionalString?: StringNullableWithAggregatesFilter<"User"> | string | null
    json?: JsonWithAggregatesFilter<"User">
    optionalJson?: JsonNullableWithAggregatesFilter<"User">
    enum?: EnumABeautifulEnumWithAggregatesFilter<"User"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableWithAggregatesFilter<"User"> | $Enums.ABeautifulEnum | null
    boolean?: BoolWithAggregatesFilter<"User"> | boolean
    optionalBoolean?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    embedHolderId?: StringWithAggregatesFilter<"User"> | string
  }

  export type EmbedHolderWhereInput = {
    AND?: EmbedHolderWhereInput | EmbedHolderWhereInput[]
    OR?: EmbedHolderWhereInput[]
    NOT?: EmbedHolderWhereInput | EmbedHolderWhereInput[]
    id?: StringFilter<"EmbedHolder"> | string
    time?: DateTimeFilter<"EmbedHolder"> | Date | string
    text?: StringFilter<"EmbedHolder"> | string
    boolean?: BoolFilter<"EmbedHolder"> | boolean
    embedList?: EmbedCompositeListFilter | EmbedObjectEqualityInput[]
    requiredEmbed?: XOR<EmbedCompositeFilter, EmbedObjectEqualityInput>
    optionalEmbed?: XOR<EmbedNullableCompositeFilter, EmbedObjectEqualityInput> | null
    User?: UserListRelationFilter
  }

  export type EmbedHolderOrderByWithRelationInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    boolean?: SortOrder
    embedList?: EmbedOrderByCompositeAggregateInput
    requiredEmbed?: EmbedOrderByInput
    optionalEmbed?: EmbedOrderByInput
    User?: UserOrderByRelationAggregateInput
  }

  export type EmbedHolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmbedHolderWhereInput | EmbedHolderWhereInput[]
    OR?: EmbedHolderWhereInput[]
    NOT?: EmbedHolderWhereInput | EmbedHolderWhereInput[]
    time?: DateTimeFilter<"EmbedHolder"> | Date | string
    text?: StringFilter<"EmbedHolder"> | string
    boolean?: BoolFilter<"EmbedHolder"> | boolean
    embedList?: EmbedCompositeListFilter | EmbedObjectEqualityInput[]
    requiredEmbed?: XOR<EmbedCompositeFilter, EmbedObjectEqualityInput>
    optionalEmbed?: XOR<EmbedNullableCompositeFilter, EmbedObjectEqualityInput> | null
    User?: UserListRelationFilter
  }, "id">

  export type EmbedHolderOrderByWithAggregationInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    boolean?: SortOrder
    _count?: EmbedHolderCountOrderByAggregateInput
    _max?: EmbedHolderMaxOrderByAggregateInput
    _min?: EmbedHolderMinOrderByAggregateInput
  }

  export type EmbedHolderScalarWhereWithAggregatesInput = {
    AND?: EmbedHolderScalarWhereWithAggregatesInput | EmbedHolderScalarWhereWithAggregatesInput[]
    OR?: EmbedHolderScalarWhereWithAggregatesInput[]
    NOT?: EmbedHolderScalarWhereWithAggregatesInput | EmbedHolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmbedHolder"> | string
    time?: DateTimeWithAggregatesFilter<"EmbedHolder"> | Date | string
    text?: StringWithAggregatesFilter<"EmbedHolder"> | string
    boolean?: BoolWithAggregatesFilter<"EmbedHolder"> | boolean
  }

  export type MWhereInput = {
    AND?: MWhereInput | MWhereInput[]
    OR?: MWhereInput[]
    NOT?: MWhereInput | MWhereInput[]
    id?: StringFilter<"M"> | string
    n_ids?: StringNullableListFilter<"M">
    int?: IntFilter<"M"> | number
    optionalInt?: IntNullableFilter<"M"> | number | null
    float?: FloatFilter<"M"> | number
    optionalFloat?: FloatNullableFilter<"M"> | number | null
    string?: StringFilter<"M"> | string
    optionalString?: StringNullableFilter<"M"> | string | null
    json?: JsonFilter<"M">
    optionalJson?: JsonNullableFilter<"M">
    enum?: EnumABeautifulEnumFilter<"M"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"M"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"M"> | boolean
    optionalBoolean?: BoolNullableFilter<"M"> | boolean | null
    n?: NListRelationFilter
  }

  export type MOrderByWithRelationInput = {
    id?: SortOrder
    n_ids?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    n?: NOrderByRelationAggregateInput
  }

  export type MWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MWhereInput | MWhereInput[]
    OR?: MWhereInput[]
    NOT?: MWhereInput | MWhereInput[]
    n_ids?: StringNullableListFilter<"M">
    int?: IntFilter<"M"> | number
    optionalInt?: IntNullableFilter<"M"> | number | null
    float?: FloatFilter<"M"> | number
    optionalFloat?: FloatNullableFilter<"M"> | number | null
    string?: StringFilter<"M"> | string
    optionalString?: StringNullableFilter<"M"> | string | null
    json?: JsonFilter<"M">
    optionalJson?: JsonNullableFilter<"M">
    enum?: EnumABeautifulEnumFilter<"M"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"M"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"M"> | boolean
    optionalBoolean?: BoolNullableFilter<"M"> | boolean | null
    n?: NListRelationFilter
  }, "id">

  export type MOrderByWithAggregationInput = {
    id?: SortOrder
    n_ids?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    _count?: MCountOrderByAggregateInput
    _avg?: MAvgOrderByAggregateInput
    _max?: MMaxOrderByAggregateInput
    _min?: MMinOrderByAggregateInput
    _sum?: MSumOrderByAggregateInput
  }

  export type MScalarWhereWithAggregatesInput = {
    AND?: MScalarWhereWithAggregatesInput | MScalarWhereWithAggregatesInput[]
    OR?: MScalarWhereWithAggregatesInput[]
    NOT?: MScalarWhereWithAggregatesInput | MScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"M"> | string
    n_ids?: StringNullableListFilter<"M">
    int?: IntWithAggregatesFilter<"M"> | number
    optionalInt?: IntNullableWithAggregatesFilter<"M"> | number | null
    float?: FloatWithAggregatesFilter<"M"> | number
    optionalFloat?: FloatNullableWithAggregatesFilter<"M"> | number | null
    string?: StringWithAggregatesFilter<"M"> | string
    optionalString?: StringNullableWithAggregatesFilter<"M"> | string | null
    json?: JsonWithAggregatesFilter<"M">
    optionalJson?: JsonNullableWithAggregatesFilter<"M">
    enum?: EnumABeautifulEnumWithAggregatesFilter<"M"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableWithAggregatesFilter<"M"> | $Enums.ABeautifulEnum | null
    boolean?: BoolWithAggregatesFilter<"M"> | boolean
    optionalBoolean?: BoolNullableWithAggregatesFilter<"M"> | boolean | null
  }

  export type NWhereInput = {
    AND?: NWhereInput | NWhereInput[]
    OR?: NWhereInput[]
    NOT?: NWhereInput | NWhereInput[]
    id?: StringFilter<"N"> | string
    m_ids?: StringNullableListFilter<"N">
    int?: IntFilter<"N"> | number
    optionalInt?: IntNullableFilter<"N"> | number | null
    float?: FloatFilter<"N"> | number
    optionalFloat?: FloatNullableFilter<"N"> | number | null
    string?: StringFilter<"N"> | string
    optionalString?: StringNullableFilter<"N"> | string | null
    json?: JsonFilter<"N">
    optionalJson?: JsonNullableFilter<"N">
    enum?: EnumABeautifulEnumFilter<"N"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"N"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"N"> | boolean
    optionalBoolean?: BoolNullableFilter<"N"> | boolean | null
    m?: MListRelationFilter
  }

  export type NOrderByWithRelationInput = {
    id?: SortOrder
    m_ids?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    m?: MOrderByRelationAggregateInput
  }

  export type NWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NWhereInput | NWhereInput[]
    OR?: NWhereInput[]
    NOT?: NWhereInput | NWhereInput[]
    m_ids?: StringNullableListFilter<"N">
    int?: IntFilter<"N"> | number
    optionalInt?: IntNullableFilter<"N"> | number | null
    float?: FloatFilter<"N"> | number
    optionalFloat?: FloatNullableFilter<"N"> | number | null
    string?: StringFilter<"N"> | string
    optionalString?: StringNullableFilter<"N"> | string | null
    json?: JsonFilter<"N">
    optionalJson?: JsonNullableFilter<"N">
    enum?: EnumABeautifulEnumFilter<"N"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"N"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"N"> | boolean
    optionalBoolean?: BoolNullableFilter<"N"> | boolean | null
    m?: MListRelationFilter
  }, "id">

  export type NOrderByWithAggregationInput = {
    id?: SortOrder
    m_ids?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    _count?: NCountOrderByAggregateInput
    _avg?: NAvgOrderByAggregateInput
    _max?: NMaxOrderByAggregateInput
    _min?: NMinOrderByAggregateInput
    _sum?: NSumOrderByAggregateInput
  }

  export type NScalarWhereWithAggregatesInput = {
    AND?: NScalarWhereWithAggregatesInput | NScalarWhereWithAggregatesInput[]
    OR?: NScalarWhereWithAggregatesInput[]
    NOT?: NScalarWhereWithAggregatesInput | NScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"N"> | string
    m_ids?: StringNullableListFilter<"N">
    int?: IntWithAggregatesFilter<"N"> | number
    optionalInt?: IntNullableWithAggregatesFilter<"N"> | number | null
    float?: FloatWithAggregatesFilter<"N"> | number
    optionalFloat?: FloatNullableWithAggregatesFilter<"N"> | number | null
    string?: StringWithAggregatesFilter<"N"> | string
    optionalString?: StringNullableWithAggregatesFilter<"N"> | string | null
    json?: JsonWithAggregatesFilter<"N">
    optionalJson?: JsonNullableWithAggregatesFilter<"N">
    enum?: EnumABeautifulEnumWithAggregatesFilter<"N"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableWithAggregatesFilter<"N"> | $Enums.ABeautifulEnum | null
    boolean?: BoolWithAggregatesFilter<"N"> | boolean
    optionalBoolean?: BoolNullableWithAggregatesFilter<"N"> | boolean | null
  }

  export type OneOptionalWhereInput = {
    AND?: OneOptionalWhereInput | OneOptionalWhereInput[]
    OR?: OneOptionalWhereInput[]
    NOT?: OneOptionalWhereInput | OneOptionalWhereInput[]
    id?: StringFilter<"OneOptional"> | string
    int?: IntFilter<"OneOptional"> | number
    optionalInt?: IntNullableFilter<"OneOptional"> | number | null
    float?: FloatFilter<"OneOptional"> | number
    optionalFloat?: FloatNullableFilter<"OneOptional"> | number | null
    string?: StringFilter<"OneOptional"> | string
    optionalString?: StringNullableFilter<"OneOptional"> | string | null
    json?: JsonFilter<"OneOptional">
    optionalJson?: JsonNullableFilter<"OneOptional">
    enum?: EnumABeautifulEnumFilter<"OneOptional"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"OneOptional"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"OneOptional"> | boolean
    optionalBoolean?: BoolNullableFilter<"OneOptional"> | boolean | null
    many?: ManyRequiredListRelationFilter
  }

  export type OneOptionalOrderByWithRelationInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    many?: ManyRequiredOrderByRelationAggregateInput
  }

  export type OneOptionalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OneOptionalWhereInput | OneOptionalWhereInput[]
    OR?: OneOptionalWhereInput[]
    NOT?: OneOptionalWhereInput | OneOptionalWhereInput[]
    int?: IntFilter<"OneOptional"> | number
    optionalInt?: IntNullableFilter<"OneOptional"> | number | null
    float?: FloatFilter<"OneOptional"> | number
    optionalFloat?: FloatNullableFilter<"OneOptional"> | number | null
    string?: StringFilter<"OneOptional"> | string
    optionalString?: StringNullableFilter<"OneOptional"> | string | null
    json?: JsonFilter<"OneOptional">
    optionalJson?: JsonNullableFilter<"OneOptional">
    enum?: EnumABeautifulEnumFilter<"OneOptional"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"OneOptional"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"OneOptional"> | boolean
    optionalBoolean?: BoolNullableFilter<"OneOptional"> | boolean | null
    many?: ManyRequiredListRelationFilter
  }, "id">

  export type OneOptionalOrderByWithAggregationInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    _count?: OneOptionalCountOrderByAggregateInput
    _avg?: OneOptionalAvgOrderByAggregateInput
    _max?: OneOptionalMaxOrderByAggregateInput
    _min?: OneOptionalMinOrderByAggregateInput
    _sum?: OneOptionalSumOrderByAggregateInput
  }

  export type OneOptionalScalarWhereWithAggregatesInput = {
    AND?: OneOptionalScalarWhereWithAggregatesInput | OneOptionalScalarWhereWithAggregatesInput[]
    OR?: OneOptionalScalarWhereWithAggregatesInput[]
    NOT?: OneOptionalScalarWhereWithAggregatesInput | OneOptionalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OneOptional"> | string
    int?: IntWithAggregatesFilter<"OneOptional"> | number
    optionalInt?: IntNullableWithAggregatesFilter<"OneOptional"> | number | null
    float?: FloatWithAggregatesFilter<"OneOptional"> | number
    optionalFloat?: FloatNullableWithAggregatesFilter<"OneOptional"> | number | null
    string?: StringWithAggregatesFilter<"OneOptional"> | string
    optionalString?: StringNullableWithAggregatesFilter<"OneOptional"> | string | null
    json?: JsonWithAggregatesFilter<"OneOptional">
    optionalJson?: JsonNullableWithAggregatesFilter<"OneOptional">
    enum?: EnumABeautifulEnumWithAggregatesFilter<"OneOptional"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableWithAggregatesFilter<"OneOptional"> | $Enums.ABeautifulEnum | null
    boolean?: BoolWithAggregatesFilter<"OneOptional"> | boolean
    optionalBoolean?: BoolNullableWithAggregatesFilter<"OneOptional"> | boolean | null
  }

  export type ManyRequiredWhereInput = {
    AND?: ManyRequiredWhereInput | ManyRequiredWhereInput[]
    OR?: ManyRequiredWhereInput[]
    NOT?: ManyRequiredWhereInput | ManyRequiredWhereInput[]
    id?: StringFilter<"ManyRequired"> | string
    oneOptionalId?: StringNullableFilter<"ManyRequired"> | string | null
    int?: IntFilter<"ManyRequired"> | number
    optionalInt?: IntNullableFilter<"ManyRequired"> | number | null
    float?: FloatFilter<"ManyRequired"> | number
    optionalFloat?: FloatNullableFilter<"ManyRequired"> | number | null
    string?: StringFilter<"ManyRequired"> | string
    optionalString?: StringNullableFilter<"ManyRequired"> | string | null
    json?: JsonFilter<"ManyRequired">
    optionalJson?: JsonNullableFilter<"ManyRequired">
    enum?: EnumABeautifulEnumFilter<"ManyRequired"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"ManyRequired"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"ManyRequired"> | boolean
    optionalBoolean?: BoolNullableFilter<"ManyRequired"> | boolean | null
    one?: XOR<OneOptionalNullableRelationFilter, OneOptionalWhereInput> | null
  }

  export type ManyRequiredOrderByWithRelationInput = {
    id?: SortOrder
    oneOptionalId?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    one?: OneOptionalOrderByWithRelationInput
  }

  export type ManyRequiredWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ManyRequiredWhereInput | ManyRequiredWhereInput[]
    OR?: ManyRequiredWhereInput[]
    NOT?: ManyRequiredWhereInput | ManyRequiredWhereInput[]
    oneOptionalId?: StringNullableFilter<"ManyRequired"> | string | null
    int?: IntFilter<"ManyRequired"> | number
    optionalInt?: IntNullableFilter<"ManyRequired"> | number | null
    float?: FloatFilter<"ManyRequired"> | number
    optionalFloat?: FloatNullableFilter<"ManyRequired"> | number | null
    string?: StringFilter<"ManyRequired"> | string
    optionalString?: StringNullableFilter<"ManyRequired"> | string | null
    json?: JsonFilter<"ManyRequired">
    optionalJson?: JsonNullableFilter<"ManyRequired">
    enum?: EnumABeautifulEnumFilter<"ManyRequired"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"ManyRequired"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"ManyRequired"> | boolean
    optionalBoolean?: BoolNullableFilter<"ManyRequired"> | boolean | null
    one?: XOR<OneOptionalNullableRelationFilter, OneOptionalWhereInput> | null
  }, "id">

  export type ManyRequiredOrderByWithAggregationInput = {
    id?: SortOrder
    oneOptionalId?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    _count?: ManyRequiredCountOrderByAggregateInput
    _avg?: ManyRequiredAvgOrderByAggregateInput
    _max?: ManyRequiredMaxOrderByAggregateInput
    _min?: ManyRequiredMinOrderByAggregateInput
    _sum?: ManyRequiredSumOrderByAggregateInput
  }

  export type ManyRequiredScalarWhereWithAggregatesInput = {
    AND?: ManyRequiredScalarWhereWithAggregatesInput | ManyRequiredScalarWhereWithAggregatesInput[]
    OR?: ManyRequiredScalarWhereWithAggregatesInput[]
    NOT?: ManyRequiredScalarWhereWithAggregatesInput | ManyRequiredScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ManyRequired"> | string
    oneOptionalId?: StringNullableWithAggregatesFilter<"ManyRequired"> | string | null
    int?: IntWithAggregatesFilter<"ManyRequired"> | number
    optionalInt?: IntNullableWithAggregatesFilter<"ManyRequired"> | number | null
    float?: FloatWithAggregatesFilter<"ManyRequired"> | number
    optionalFloat?: FloatNullableWithAggregatesFilter<"ManyRequired"> | number | null
    string?: StringWithAggregatesFilter<"ManyRequired"> | string
    optionalString?: StringNullableWithAggregatesFilter<"ManyRequired"> | string | null
    json?: JsonWithAggregatesFilter<"ManyRequired">
    optionalJson?: JsonNullableWithAggregatesFilter<"ManyRequired">
    enum?: EnumABeautifulEnumWithAggregatesFilter<"ManyRequired"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableWithAggregatesFilter<"ManyRequired"> | $Enums.ABeautifulEnum | null
    boolean?: BoolWithAggregatesFilter<"ManyRequired"> | boolean
    optionalBoolean?: BoolNullableWithAggregatesFilter<"ManyRequired"> | boolean | null
  }

  export type OptionalSide1WhereInput = {
    AND?: OptionalSide1WhereInput | OptionalSide1WhereInput[]
    OR?: OptionalSide1WhereInput[]
    NOT?: OptionalSide1WhereInput | OptionalSide1WhereInput[]
    id?: StringFilter<"OptionalSide1"> | string
    optionalSide2Id?: StringNullableFilter<"OptionalSide1"> | string | null
    int?: IntFilter<"OptionalSide1"> | number
    optionalInt?: IntNullableFilter<"OptionalSide1"> | number | null
    float?: FloatFilter<"OptionalSide1"> | number
    optionalFloat?: FloatNullableFilter<"OptionalSide1"> | number | null
    string?: StringFilter<"OptionalSide1"> | string
    optionalString?: StringNullableFilter<"OptionalSide1"> | string | null
    json?: JsonFilter<"OptionalSide1">
    optionalJson?: JsonNullableFilter<"OptionalSide1">
    enum?: EnumABeautifulEnumFilter<"OptionalSide1"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"OptionalSide1"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"OptionalSide1"> | boolean
    optionalBoolean?: BoolNullableFilter<"OptionalSide1"> | boolean | null
    opti?: XOR<OptionalSide2NullableRelationFilter, OptionalSide2WhereInput> | null
  }

  export type OptionalSide1OrderByWithRelationInput = {
    id?: SortOrder
    optionalSide2Id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    opti?: OptionalSide2OrderByWithRelationInput
  }

  export type OptionalSide1WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    optionalSide2Id?: string
    AND?: OptionalSide1WhereInput | OptionalSide1WhereInput[]
    OR?: OptionalSide1WhereInput[]
    NOT?: OptionalSide1WhereInput | OptionalSide1WhereInput[]
    int?: IntFilter<"OptionalSide1"> | number
    optionalInt?: IntNullableFilter<"OptionalSide1"> | number | null
    float?: FloatFilter<"OptionalSide1"> | number
    optionalFloat?: FloatNullableFilter<"OptionalSide1"> | number | null
    string?: StringFilter<"OptionalSide1"> | string
    optionalString?: StringNullableFilter<"OptionalSide1"> | string | null
    json?: JsonFilter<"OptionalSide1">
    optionalJson?: JsonNullableFilter<"OptionalSide1">
    enum?: EnumABeautifulEnumFilter<"OptionalSide1"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"OptionalSide1"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"OptionalSide1"> | boolean
    optionalBoolean?: BoolNullableFilter<"OptionalSide1"> | boolean | null
    opti?: XOR<OptionalSide2NullableRelationFilter, OptionalSide2WhereInput> | null
  }, "id" | "optionalSide2Id">

  export type OptionalSide1OrderByWithAggregationInput = {
    id?: SortOrder
    optionalSide2Id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    _count?: OptionalSide1CountOrderByAggregateInput
    _avg?: OptionalSide1AvgOrderByAggregateInput
    _max?: OptionalSide1MaxOrderByAggregateInput
    _min?: OptionalSide1MinOrderByAggregateInput
    _sum?: OptionalSide1SumOrderByAggregateInput
  }

  export type OptionalSide1ScalarWhereWithAggregatesInput = {
    AND?: OptionalSide1ScalarWhereWithAggregatesInput | OptionalSide1ScalarWhereWithAggregatesInput[]
    OR?: OptionalSide1ScalarWhereWithAggregatesInput[]
    NOT?: OptionalSide1ScalarWhereWithAggregatesInput | OptionalSide1ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OptionalSide1"> | string
    optionalSide2Id?: StringNullableWithAggregatesFilter<"OptionalSide1"> | string | null
    int?: IntWithAggregatesFilter<"OptionalSide1"> | number
    optionalInt?: IntNullableWithAggregatesFilter<"OptionalSide1"> | number | null
    float?: FloatWithAggregatesFilter<"OptionalSide1"> | number
    optionalFloat?: FloatNullableWithAggregatesFilter<"OptionalSide1"> | number | null
    string?: StringWithAggregatesFilter<"OptionalSide1"> | string
    optionalString?: StringNullableWithAggregatesFilter<"OptionalSide1"> | string | null
    json?: JsonWithAggregatesFilter<"OptionalSide1">
    optionalJson?: JsonNullableWithAggregatesFilter<"OptionalSide1">
    enum?: EnumABeautifulEnumWithAggregatesFilter<"OptionalSide1"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableWithAggregatesFilter<"OptionalSide1"> | $Enums.ABeautifulEnum | null
    boolean?: BoolWithAggregatesFilter<"OptionalSide1"> | boolean
    optionalBoolean?: BoolNullableWithAggregatesFilter<"OptionalSide1"> | boolean | null
  }

  export type OptionalSide2WhereInput = {
    AND?: OptionalSide2WhereInput | OptionalSide2WhereInput[]
    OR?: OptionalSide2WhereInput[]
    NOT?: OptionalSide2WhereInput | OptionalSide2WhereInput[]
    id?: StringFilter<"OptionalSide2"> | string
    int?: IntFilter<"OptionalSide2"> | number
    optionalInt?: IntNullableFilter<"OptionalSide2"> | number | null
    float?: FloatFilter<"OptionalSide2"> | number
    optionalFloat?: FloatNullableFilter<"OptionalSide2"> | number | null
    string?: StringFilter<"OptionalSide2"> | string
    optionalString?: StringNullableFilter<"OptionalSide2"> | string | null
    json?: JsonFilter<"OptionalSide2">
    optionalJson?: JsonNullableFilter<"OptionalSide2">
    enum?: EnumABeautifulEnumFilter<"OptionalSide2"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"OptionalSide2"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"OptionalSide2"> | boolean
    optionalBoolean?: BoolNullableFilter<"OptionalSide2"> | boolean | null
    opti?: XOR<OptionalSide1NullableRelationFilter, OptionalSide1WhereInput> | null
  }

  export type OptionalSide2OrderByWithRelationInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    opti?: OptionalSide1OrderByWithRelationInput
  }

  export type OptionalSide2WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OptionalSide2WhereInput | OptionalSide2WhereInput[]
    OR?: OptionalSide2WhereInput[]
    NOT?: OptionalSide2WhereInput | OptionalSide2WhereInput[]
    int?: IntFilter<"OptionalSide2"> | number
    optionalInt?: IntNullableFilter<"OptionalSide2"> | number | null
    float?: FloatFilter<"OptionalSide2"> | number
    optionalFloat?: FloatNullableFilter<"OptionalSide2"> | number | null
    string?: StringFilter<"OptionalSide2"> | string
    optionalString?: StringNullableFilter<"OptionalSide2"> | string | null
    json?: JsonFilter<"OptionalSide2">
    optionalJson?: JsonNullableFilter<"OptionalSide2">
    enum?: EnumABeautifulEnumFilter<"OptionalSide2"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"OptionalSide2"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"OptionalSide2"> | boolean
    optionalBoolean?: BoolNullableFilter<"OptionalSide2"> | boolean | null
    opti?: XOR<OptionalSide1NullableRelationFilter, OptionalSide1WhereInput> | null
  }, "id">

  export type OptionalSide2OrderByWithAggregationInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    _count?: OptionalSide2CountOrderByAggregateInput
    _avg?: OptionalSide2AvgOrderByAggregateInput
    _max?: OptionalSide2MaxOrderByAggregateInput
    _min?: OptionalSide2MinOrderByAggregateInput
    _sum?: OptionalSide2SumOrderByAggregateInput
  }

  export type OptionalSide2ScalarWhereWithAggregatesInput = {
    AND?: OptionalSide2ScalarWhereWithAggregatesInput | OptionalSide2ScalarWhereWithAggregatesInput[]
    OR?: OptionalSide2ScalarWhereWithAggregatesInput[]
    NOT?: OptionalSide2ScalarWhereWithAggregatesInput | OptionalSide2ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OptionalSide2"> | string
    int?: IntWithAggregatesFilter<"OptionalSide2"> | number
    optionalInt?: IntNullableWithAggregatesFilter<"OptionalSide2"> | number | null
    float?: FloatWithAggregatesFilter<"OptionalSide2"> | number
    optionalFloat?: FloatNullableWithAggregatesFilter<"OptionalSide2"> | number | null
    string?: StringWithAggregatesFilter<"OptionalSide2"> | string
    optionalString?: StringNullableWithAggregatesFilter<"OptionalSide2"> | string | null
    json?: JsonWithAggregatesFilter<"OptionalSide2">
    optionalJson?: JsonNullableWithAggregatesFilter<"OptionalSide2">
    enum?: EnumABeautifulEnumWithAggregatesFilter<"OptionalSide2"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableWithAggregatesFilter<"OptionalSide2"> | $Enums.ABeautifulEnum | null
    boolean?: BoolWithAggregatesFilter<"OptionalSide2"> | boolean
    optionalBoolean?: BoolNullableWithAggregatesFilter<"OptionalSide2"> | boolean | null
  }

  export type AWhereInput = {
    AND?: AWhereInput | AWhereInput[]
    OR?: AWhereInput[]
    NOT?: AWhereInput | AWhereInput[]
    id?: StringFilter<"A"> | string
    email?: StringFilter<"A"> | string
    name?: StringNullableFilter<"A"> | string | null
    int?: IntFilter<"A"> | number
    sInt?: IntFilter<"A"> | number
    bInt?: BigIntFilter<"A"> | bigint | number
  }

  export type AOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    int?: SortOrder
    sInt?: SortOrder
    bInt?: SortOrder
  }

  export type AWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AWhereInput | AWhereInput[]
    OR?: AWhereInput[]
    NOT?: AWhereInput | AWhereInput[]
    name?: StringNullableFilter<"A"> | string | null
    int?: IntFilter<"A"> | number
    sInt?: IntFilter<"A"> | number
    bInt?: BigIntFilter<"A"> | bigint | number
  }, "id" | "email">

  export type AOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    int?: SortOrder
    sInt?: SortOrder
    bInt?: SortOrder
    _count?: ACountOrderByAggregateInput
    _avg?: AAvgOrderByAggregateInput
    _max?: AMaxOrderByAggregateInput
    _min?: AMinOrderByAggregateInput
    _sum?: ASumOrderByAggregateInput
  }

  export type AScalarWhereWithAggregatesInput = {
    AND?: AScalarWhereWithAggregatesInput | AScalarWhereWithAggregatesInput[]
    OR?: AScalarWhereWithAggregatesInput[]
    NOT?: AScalarWhereWithAggregatesInput | AScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"A"> | string
    email?: StringWithAggregatesFilter<"A"> | string
    name?: StringNullableWithAggregatesFilter<"A"> | string | null
    int?: IntWithAggregatesFilter<"A"> | number
    sInt?: IntWithAggregatesFilter<"A"> | number
    bInt?: BigIntWithAggregatesFilter<"A"> | bigint | number
  }

  export type BWhereInput = {
    AND?: BWhereInput | BWhereInput[]
    OR?: BWhereInput[]
    NOT?: BWhereInput | BWhereInput[]
    id?: StringFilter<"B"> | string
    float?: FloatFilter<"B"> | number
    dFloat?: FloatFilter<"B"> | number
  }

  export type BOrderByWithRelationInput = {
    id?: SortOrder
    float?: SortOrder
    dFloat?: SortOrder
  }

  export type BWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BWhereInput | BWhereInput[]
    OR?: BWhereInput[]
    NOT?: BWhereInput | BWhereInput[]
    float?: FloatFilter<"B"> | number
    dFloat?: FloatFilter<"B"> | number
  }, "id">

  export type BOrderByWithAggregationInput = {
    id?: SortOrder
    float?: SortOrder
    dFloat?: SortOrder
    _count?: BCountOrderByAggregateInput
    _avg?: BAvgOrderByAggregateInput
    _max?: BMaxOrderByAggregateInput
    _min?: BMinOrderByAggregateInput
    _sum?: BSumOrderByAggregateInput
  }

  export type BScalarWhereWithAggregatesInput = {
    AND?: BScalarWhereWithAggregatesInput | BScalarWhereWithAggregatesInput[]
    OR?: BScalarWhereWithAggregatesInput[]
    NOT?: BScalarWhereWithAggregatesInput | BScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"B"> | string
    float?: FloatWithAggregatesFilter<"B"> | number
    dFloat?: FloatWithAggregatesFilter<"B"> | number
  }

  export type CWhereInput = {
    AND?: CWhereInput | CWhereInput[]
    OR?: CWhereInput[]
    NOT?: CWhereInput | CWhereInput[]
    id?: StringFilter<"C"> | string
    char?: StringFilter<"C"> | string
    vChar?: StringFilter<"C"> | string
    text?: StringFilter<"C"> | string
    bit?: StringFilter<"C"> | string
    vBit?: StringFilter<"C"> | string
    uuid?: StringFilter<"C"> | string
  }

  export type COrderByWithRelationInput = {
    id?: SortOrder
    char?: SortOrder
    vChar?: SortOrder
    text?: SortOrder
    bit?: SortOrder
    vBit?: SortOrder
    uuid?: SortOrder
  }

  export type CWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CWhereInput | CWhereInput[]
    OR?: CWhereInput[]
    NOT?: CWhereInput | CWhereInput[]
    char?: StringFilter<"C"> | string
    vChar?: StringFilter<"C"> | string
    text?: StringFilter<"C"> | string
    bit?: StringFilter<"C"> | string
    vBit?: StringFilter<"C"> | string
    uuid?: StringFilter<"C"> | string
  }, "id">

  export type COrderByWithAggregationInput = {
    id?: SortOrder
    char?: SortOrder
    vChar?: SortOrder
    text?: SortOrder
    bit?: SortOrder
    vBit?: SortOrder
    uuid?: SortOrder
    _count?: CCountOrderByAggregateInput
    _max?: CMaxOrderByAggregateInput
    _min?: CMinOrderByAggregateInput
  }

  export type CScalarWhereWithAggregatesInput = {
    AND?: CScalarWhereWithAggregatesInput | CScalarWhereWithAggregatesInput[]
    OR?: CScalarWhereWithAggregatesInput[]
    NOT?: CScalarWhereWithAggregatesInput | CScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"C"> | string
    char?: StringWithAggregatesFilter<"C"> | string
    vChar?: StringWithAggregatesFilter<"C"> | string
    text?: StringWithAggregatesFilter<"C"> | string
    bit?: StringWithAggregatesFilter<"C"> | string
    vBit?: StringWithAggregatesFilter<"C"> | string
    uuid?: StringWithAggregatesFilter<"C"> | string
  }

  export type DWhereInput = {
    AND?: DWhereInput | DWhereInput[]
    OR?: DWhereInput[]
    NOT?: DWhereInput | DWhereInput[]
    id?: StringFilter<"D"> | string
    bool?: BoolFilter<"D"> | boolean
    byteA?: BytesFilter<"D"> | Buffer
    xml?: StringFilter<"D"> | string
    json?: JsonFilter<"D">
    jsonb?: JsonFilter<"D">
    list?: IntNullableListFilter<"D">
  }

  export type DOrderByWithRelationInput = {
    id?: SortOrder
    bool?: SortOrder
    byteA?: SortOrder
    xml?: SortOrder
    json?: SortOrder
    jsonb?: SortOrder
    list?: SortOrder
  }

  export type DWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DWhereInput | DWhereInput[]
    OR?: DWhereInput[]
    NOT?: DWhereInput | DWhereInput[]
    bool?: BoolFilter<"D"> | boolean
    byteA?: BytesFilter<"D"> | Buffer
    xml?: StringFilter<"D"> | string
    json?: JsonFilter<"D">
    jsonb?: JsonFilter<"D">
    list?: IntNullableListFilter<"D">
  }, "id">

  export type DOrderByWithAggregationInput = {
    id?: SortOrder
    bool?: SortOrder
    byteA?: SortOrder
    xml?: SortOrder
    json?: SortOrder
    jsonb?: SortOrder
    list?: SortOrder
    _count?: DCountOrderByAggregateInput
    _avg?: DAvgOrderByAggregateInput
    _max?: DMaxOrderByAggregateInput
    _min?: DMinOrderByAggregateInput
    _sum?: DSumOrderByAggregateInput
  }

  export type DScalarWhereWithAggregatesInput = {
    AND?: DScalarWhereWithAggregatesInput | DScalarWhereWithAggregatesInput[]
    OR?: DScalarWhereWithAggregatesInput[]
    NOT?: DScalarWhereWithAggregatesInput | DScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"D"> | string
    bool?: BoolWithAggregatesFilter<"D"> | boolean
    byteA?: BytesWithAggregatesFilter<"D"> | Buffer
    xml?: StringWithAggregatesFilter<"D"> | string
    json?: JsonWithAggregatesFilter<"D">
    jsonb?: JsonWithAggregatesFilter<"D">
    list?: IntNullableListFilter<"D">
  }

  export type EWhereInput = {
    AND?: EWhereInput | EWhereInput[]
    OR?: EWhereInput[]
    NOT?: EWhereInput | EWhereInput[]
    id?: StringFilter<"E"> | string
    date?: DateTimeFilter<"E"> | Date | string
    time?: DateTimeFilter<"E"> | Date | string
    ts?: DateTimeFilter<"E"> | Date | string
  }

  export type EOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    ts?: SortOrder
  }

  export type EWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EWhereInput | EWhereInput[]
    OR?: EWhereInput[]
    NOT?: EWhereInput | EWhereInput[]
    date?: DateTimeFilter<"E"> | Date | string
    time?: DateTimeFilter<"E"> | Date | string
    ts?: DateTimeFilter<"E"> | Date | string
  }, "id">

  export type EOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    ts?: SortOrder
    _count?: ECountOrderByAggregateInput
    _max?: EMaxOrderByAggregateInput
    _min?: EMinOrderByAggregateInput
  }

  export type EScalarWhereWithAggregatesInput = {
    AND?: EScalarWhereWithAggregatesInput | EScalarWhereWithAggregatesInput[]
    OR?: EScalarWhereWithAggregatesInput[]
    NOT?: EScalarWhereWithAggregatesInput | EScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"E"> | string
    date?: DateTimeWithAggregatesFilter<"E"> | Date | string
    time?: DateTimeWithAggregatesFilter<"E"> | Date | string
    ts?: DateTimeWithAggregatesFilter<"E"> | Date | string
  }

  export type PostCreateInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    published?: boolean
    author: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    published?: boolean
    authorId: string
  }

  export type PostUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateManyInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    published?: boolean
    authorId: string
  }

  export type PostUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    posts?: PostCreateNestedManyWithoutAuthorInput
    embedHolder: EmbedHolderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    embedHolderId: string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUpdateManyWithoutAuthorNestedInput
    embedHolder?: EmbedHolderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    embedHolderId?: StringFieldUpdateOperationsInput | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    embedHolderId: string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    embedHolderId?: StringFieldUpdateOperationsInput | string
  }

  export type EmbedHolderCreateInput = {
    id?: string
    time?: Date | string
    text: string
    boolean: boolean
    embedList?: XOR<EmbedListCreateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed: XOR<EmbedCreateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableCreateEnvelopeInput, EmbedCreateInput> | null
    User?: UserCreateNestedManyWithoutEmbedHolderInput
  }

  export type EmbedHolderUncheckedCreateInput = {
    id?: string
    time?: Date | string
    text: string
    boolean: boolean
    embedList?: XOR<EmbedListCreateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed: XOR<EmbedCreateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableCreateEnvelopeInput, EmbedCreateInput> | null
    User?: UserUncheckedCreateNestedManyWithoutEmbedHolderInput
  }

  export type EmbedHolderUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    boolean?: BoolFieldUpdateOperationsInput | boolean
    embedList?: XOR<EmbedListUpdateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed?: XOR<EmbedUpdateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableUpdateEnvelopeInput, EmbedCreateInput> | null
    User?: UserUpdateManyWithoutEmbedHolderNestedInput
  }

  export type EmbedHolderUncheckedUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    boolean?: BoolFieldUpdateOperationsInput | boolean
    embedList?: XOR<EmbedListUpdateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed?: XOR<EmbedUpdateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableUpdateEnvelopeInput, EmbedCreateInput> | null
    User?: UserUncheckedUpdateManyWithoutEmbedHolderNestedInput
  }

  export type EmbedHolderCreateManyInput = {
    id?: string
    time?: Date | string
    text: string
    boolean: boolean
    embedList?: XOR<EmbedListCreateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed: XOR<EmbedCreateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableCreateEnvelopeInput, EmbedCreateInput> | null
  }

  export type EmbedHolderUpdateManyMutationInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    boolean?: BoolFieldUpdateOperationsInput | boolean
    embedList?: XOR<EmbedListUpdateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed?: XOR<EmbedUpdateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableUpdateEnvelopeInput, EmbedCreateInput> | null
  }

  export type EmbedHolderUncheckedUpdateManyInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    boolean?: BoolFieldUpdateOperationsInput | boolean
    embedList?: XOR<EmbedListUpdateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed?: XOR<EmbedUpdateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableUpdateEnvelopeInput, EmbedCreateInput> | null
  }

  export type MCreateInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    n?: NCreateNestedManyWithoutMInput
  }

  export type MUncheckedCreateInput = {
    id?: string
    n_ids?: MCreaten_idsInput | string[]
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    n?: NUncheckedCreateNestedManyWithoutMInput
  }

  export type MUpdateInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    n?: NUpdateManyWithoutMNestedInput
  }

  export type MUncheckedUpdateInput = {
    n_ids?: MUpdaten_idsInput | string[]
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    n?: NUncheckedUpdateManyWithoutMNestedInput
  }

  export type MCreateManyInput = {
    id?: string
    n_ids?: MCreaten_idsInput | string[]
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type MUpdateManyMutationInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MUncheckedUpdateManyInput = {
    n_ids?: MUpdaten_idsInput | string[]
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type NCreateInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    m?: MCreateNestedManyWithoutNInput
  }

  export type NUncheckedCreateInput = {
    id?: string
    m_ids?: NCreatem_idsInput | string[]
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    m?: MUncheckedCreateNestedManyWithoutNInput
  }

  export type NUpdateInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m?: MUpdateManyWithoutNNestedInput
  }

  export type NUncheckedUpdateInput = {
    m_ids?: NUpdatem_idsInput | string[]
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m?: MUncheckedUpdateManyWithoutNNestedInput
  }

  export type NCreateManyInput = {
    id?: string
    m_ids?: NCreatem_idsInput | string[]
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type NUpdateManyMutationInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type NUncheckedUpdateManyInput = {
    m_ids?: NUpdatem_idsInput | string[]
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OneOptionalCreateInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    many?: ManyRequiredCreateNestedManyWithoutOneInput
  }

  export type OneOptionalUncheckedCreateInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    many?: ManyRequiredUncheckedCreateNestedManyWithoutOneInput
  }

  export type OneOptionalUpdateInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    many?: ManyRequiredUpdateManyWithoutOneNestedInput
  }

  export type OneOptionalUncheckedUpdateInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    many?: ManyRequiredUncheckedUpdateManyWithoutOneNestedInput
  }

  export type OneOptionalCreateManyInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OneOptionalUpdateManyMutationInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OneOptionalUncheckedUpdateManyInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ManyRequiredCreateInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    one?: OneOptionalCreateNestedOneWithoutManyInput
  }

  export type ManyRequiredUncheckedCreateInput = {
    id?: string
    oneOptionalId?: string | null
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type ManyRequiredUpdateInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    one?: OneOptionalUpdateOneWithoutManyNestedInput
  }

  export type ManyRequiredUncheckedUpdateInput = {
    oneOptionalId?: NullableStringFieldUpdateOperationsInput | string | null
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ManyRequiredCreateManyInput = {
    id?: string
    oneOptionalId?: string | null
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type ManyRequiredUpdateManyMutationInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ManyRequiredUncheckedUpdateManyInput = {
    oneOptionalId?: NullableStringFieldUpdateOperationsInput | string | null
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionalSide1CreateInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    opti?: OptionalSide2CreateNestedOneWithoutOptiInput
  }

  export type OptionalSide1UncheckedCreateInput = {
    id?: string
    optionalSide2Id?: string | null
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OptionalSide1UpdateInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    opti?: OptionalSide2UpdateOneWithoutOptiNestedInput
  }

  export type OptionalSide1UncheckedUpdateInput = {
    optionalSide2Id?: NullableStringFieldUpdateOperationsInput | string | null
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionalSide1CreateManyInput = {
    id?: string
    optionalSide2Id?: string | null
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OptionalSide1UpdateManyMutationInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionalSide1UncheckedUpdateManyInput = {
    optionalSide2Id?: NullableStringFieldUpdateOperationsInput | string | null
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionalSide2CreateInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    opti?: OptionalSide1CreateNestedOneWithoutOptiInput
  }

  export type OptionalSide2UncheckedCreateInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    opti?: OptionalSide1UncheckedCreateNestedOneWithoutOptiInput
  }

  export type OptionalSide2UpdateInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    opti?: OptionalSide1UpdateOneWithoutOptiNestedInput
  }

  export type OptionalSide2UncheckedUpdateInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    opti?: OptionalSide1UncheckedUpdateOneWithoutOptiNestedInput
  }

  export type OptionalSide2CreateManyInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OptionalSide2UpdateManyMutationInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionalSide2UncheckedUpdateManyInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ACreateInput = {
    id?: string
    email: string
    name?: string | null
    int: number
    sInt: number
    bInt: bigint | number
  }

  export type AUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    int: number
    sInt: number
    bInt: bigint | number
  }

  export type AUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    int?: IntFieldUpdateOperationsInput | number
    sInt?: IntFieldUpdateOperationsInput | number
    bInt?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    int?: IntFieldUpdateOperationsInput | number
    sInt?: IntFieldUpdateOperationsInput | number
    bInt?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ACreateManyInput = {
    id?: string
    email: string
    name?: string | null
    int: number
    sInt: number
    bInt: bigint | number
  }

  export type AUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    int?: IntFieldUpdateOperationsInput | number
    sInt?: IntFieldUpdateOperationsInput | number
    bInt?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    int?: IntFieldUpdateOperationsInput | number
    sInt?: IntFieldUpdateOperationsInput | number
    bInt?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type BCreateInput = {
    id?: string
    float: number
    dFloat: number
  }

  export type BUncheckedCreateInput = {
    id?: string
    float: number
    dFloat: number
  }

  export type BUpdateInput = {
    float?: FloatFieldUpdateOperationsInput | number
    dFloat?: FloatFieldUpdateOperationsInput | number
  }

  export type BUncheckedUpdateInput = {
    float?: FloatFieldUpdateOperationsInput | number
    dFloat?: FloatFieldUpdateOperationsInput | number
  }

  export type BCreateManyInput = {
    id?: string
    float: number
    dFloat: number
  }

  export type BUpdateManyMutationInput = {
    float?: FloatFieldUpdateOperationsInput | number
    dFloat?: FloatFieldUpdateOperationsInput | number
  }

  export type BUncheckedUpdateManyInput = {
    float?: FloatFieldUpdateOperationsInput | number
    dFloat?: FloatFieldUpdateOperationsInput | number
  }

  export type CCreateInput = {
    id?: string
    char: string
    vChar: string
    text: string
    bit: string
    vBit: string
    uuid: string
  }

  export type CUncheckedCreateInput = {
    id?: string
    char: string
    vChar: string
    text: string
    bit: string
    vBit: string
    uuid: string
  }

  export type CUpdateInput = {
    char?: StringFieldUpdateOperationsInput | string
    vChar?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    bit?: StringFieldUpdateOperationsInput | string
    vBit?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type CUncheckedUpdateInput = {
    char?: StringFieldUpdateOperationsInput | string
    vChar?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    bit?: StringFieldUpdateOperationsInput | string
    vBit?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type CCreateManyInput = {
    id?: string
    char: string
    vChar: string
    text: string
    bit: string
    vBit: string
    uuid: string
  }

  export type CUpdateManyMutationInput = {
    char?: StringFieldUpdateOperationsInput | string
    vChar?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    bit?: StringFieldUpdateOperationsInput | string
    vBit?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type CUncheckedUpdateManyInput = {
    char?: StringFieldUpdateOperationsInput | string
    vChar?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    bit?: StringFieldUpdateOperationsInput | string
    vBit?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
  }

  export type DCreateInput = {
    id?: string
    bool: boolean
    byteA: Buffer
    xml: string
    json: InputJsonValue
    jsonb: InputJsonValue
    list?: DCreatelistInput | number[]
  }

  export type DUncheckedCreateInput = {
    id?: string
    bool: boolean
    byteA: Buffer
    xml: string
    json: InputJsonValue
    jsonb: InputJsonValue
    list?: DCreatelistInput | number[]
  }

  export type DUpdateInput = {
    bool?: BoolFieldUpdateOperationsInput | boolean
    byteA?: BytesFieldUpdateOperationsInput | Buffer
    xml?: StringFieldUpdateOperationsInput | string
    json?: InputJsonValue | InputJsonValue
    jsonb?: InputJsonValue | InputJsonValue
    list?: DUpdatelistInput | number[]
  }

  export type DUncheckedUpdateInput = {
    bool?: BoolFieldUpdateOperationsInput | boolean
    byteA?: BytesFieldUpdateOperationsInput | Buffer
    xml?: StringFieldUpdateOperationsInput | string
    json?: InputJsonValue | InputJsonValue
    jsonb?: InputJsonValue | InputJsonValue
    list?: DUpdatelistInput | number[]
  }

  export type DCreateManyInput = {
    id?: string
    bool: boolean
    byteA: Buffer
    xml: string
    json: InputJsonValue
    jsonb: InputJsonValue
    list?: DCreatelistInput | number[]
  }

  export type DUpdateManyMutationInput = {
    bool?: BoolFieldUpdateOperationsInput | boolean
    byteA?: BytesFieldUpdateOperationsInput | Buffer
    xml?: StringFieldUpdateOperationsInput | string
    json?: InputJsonValue | InputJsonValue
    jsonb?: InputJsonValue | InputJsonValue
    list?: DUpdatelistInput | number[]
  }

  export type DUncheckedUpdateManyInput = {
    bool?: BoolFieldUpdateOperationsInput | boolean
    byteA?: BytesFieldUpdateOperationsInput | Buffer
    xml?: StringFieldUpdateOperationsInput | string
    json?: InputJsonValue | InputJsonValue
    jsonb?: InputJsonValue | InputJsonValue
    list?: DUpdatelistInput | number[]
  }

  export type ECreateInput = {
    id?: string
    date: Date | string
    time: Date | string
    ts: Date | string
  }

  export type EUncheckedCreateInput = {
    id?: string
    date: Date | string
    time: Date | string
    ts: Date | string
  }

  export type EUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EUncheckedUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ECreateManyInput = {
    id?: string
    date: Date | string
    time: Date | string
    ts: Date | string
  }

  export type EUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EUncheckedUpdateManyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type EnumABeautifulEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ABeautifulEnum | EnumABeautifulEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumABeautifulEnumFilter<$PrismaModel> | $Enums.ABeautifulEnum
  }

  export type EnumABeautifulEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ABeautifulEnum | EnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumABeautifulEnumNullableFilter<$PrismaModel> | $Enums.ABeautifulEnum | null
    isSet?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type EmbedHolderRelationFilter = {
    is?: EmbedHolderWhereInput
    isNot?: EmbedHolderWhereInput
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    embedHolderId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    embedHolderId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
    embedHolderId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumABeautifulEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ABeautifulEnum | EnumABeautifulEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumABeautifulEnumWithAggregatesFilter<$PrismaModel> | $Enums.ABeautifulEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumABeautifulEnumFilter<$PrismaModel>
    _max?: NestedEnumABeautifulEnumFilter<$PrismaModel>
  }

  export type EnumABeautifulEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ABeautifulEnum | EnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumABeautifulEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.ABeautifulEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumABeautifulEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumABeautifulEnumNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EmbedCompositeListFilter = {
    equals?: EmbedObjectEqualityInput[]
    every?: EmbedWhereInput
    some?: EmbedWhereInput
    none?: EmbedWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type EmbedObjectEqualityInput = {
    text: string
    boolean: boolean
    embedEmbedList?: EmbedEmbedObjectEqualityInput[]
    requiredEmbedEmbed: EmbedEmbedObjectEqualityInput
    optionalEmbedEmbed?: EmbedEmbedObjectEqualityInput | null
    scalarList?: number[]
  }

  export type EmbedCompositeFilter = {
    equals?: EmbedObjectEqualityInput
    is?: EmbedWhereInput
    isNot?: EmbedWhereInput
  }

  export type EmbedNullableCompositeFilter = {
    equals?: EmbedObjectEqualityInput | null
    is?: EmbedWhereInput | null
    isNot?: EmbedWhereInput | null
    isSet?: boolean
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type EmbedOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type EmbedOrderByInput = {
    text?: SortOrder
    boolean?: SortOrder
    embedEmbedList?: EmbedEmbedOrderByCompositeAggregateInput
    requiredEmbedEmbed?: EmbedEmbedOrderByInput
    optionalEmbedEmbed?: EmbedEmbedOrderByInput
    scalarList?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmbedHolderCountOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    boolean?: SortOrder
  }

  export type EmbedHolderMaxOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    boolean?: SortOrder
  }

  export type EmbedHolderMinOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    boolean?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type NListRelationFilter = {
    every?: NWhereInput
    some?: NWhereInput
    none?: NWhereInput
  }

  export type NOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MCountOrderByAggregateInput = {
    id?: SortOrder
    n_ids?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type MAvgOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type MMaxOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type MMinOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type MSumOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type MListRelationFilter = {
    every?: MWhereInput
    some?: MWhereInput
    none?: MWhereInput
  }

  export type MOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NCountOrderByAggregateInput = {
    id?: SortOrder
    m_ids?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type NAvgOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type NMaxOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type NMinOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type NSumOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type ManyRequiredListRelationFilter = {
    every?: ManyRequiredWhereInput
    some?: ManyRequiredWhereInput
    none?: ManyRequiredWhereInput
  }

  export type ManyRequiredOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OneOptionalCountOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type OneOptionalAvgOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type OneOptionalMaxOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type OneOptionalMinOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type OneOptionalSumOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type OneOptionalNullableRelationFilter = {
    is?: OneOptionalWhereInput | null
    isNot?: OneOptionalWhereInput | null
  }

  export type ManyRequiredCountOrderByAggregateInput = {
    id?: SortOrder
    oneOptionalId?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type ManyRequiredAvgOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type ManyRequiredMaxOrderByAggregateInput = {
    id?: SortOrder
    oneOptionalId?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type ManyRequiredMinOrderByAggregateInput = {
    id?: SortOrder
    oneOptionalId?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type ManyRequiredSumOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type OptionalSide2NullableRelationFilter = {
    is?: OptionalSide2WhereInput | null
    isNot?: OptionalSide2WhereInput | null
  }

  export type OptionalSide1CountOrderByAggregateInput = {
    id?: SortOrder
    optionalSide2Id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type OptionalSide1AvgOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type OptionalSide1MaxOrderByAggregateInput = {
    id?: SortOrder
    optionalSide2Id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type OptionalSide1MinOrderByAggregateInput = {
    id?: SortOrder
    optionalSide2Id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type OptionalSide1SumOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type OptionalSide1NullableRelationFilter = {
    is?: OptionalSide1WhereInput | null
    isNot?: OptionalSide1WhereInput | null
  }

  export type OptionalSide2CountOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    json?: SortOrder
    optionalJson?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type OptionalSide2AvgOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type OptionalSide2MaxOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type OptionalSide2MinOrderByAggregateInput = {
    id?: SortOrder
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
    string?: SortOrder
    optionalString?: SortOrder
    enum?: SortOrder
    optionalEnum?: SortOrder
    boolean?: SortOrder
    optionalBoolean?: SortOrder
  }

  export type OptionalSide2SumOrderByAggregateInput = {
    int?: SortOrder
    optionalInt?: SortOrder
    float?: SortOrder
    optionalFloat?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type ACountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    int?: SortOrder
    sInt?: SortOrder
    bInt?: SortOrder
  }

  export type AAvgOrderByAggregateInput = {
    int?: SortOrder
    sInt?: SortOrder
    bInt?: SortOrder
  }

  export type AMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    int?: SortOrder
    sInt?: SortOrder
    bInt?: SortOrder
  }

  export type AMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    int?: SortOrder
    sInt?: SortOrder
    bInt?: SortOrder
  }

  export type ASumOrderByAggregateInput = {
    int?: SortOrder
    sInt?: SortOrder
    bInt?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BCountOrderByAggregateInput = {
    id?: SortOrder
    float?: SortOrder
    dFloat?: SortOrder
  }

  export type BAvgOrderByAggregateInput = {
    float?: SortOrder
    dFloat?: SortOrder
  }

  export type BMaxOrderByAggregateInput = {
    id?: SortOrder
    float?: SortOrder
    dFloat?: SortOrder
  }

  export type BMinOrderByAggregateInput = {
    id?: SortOrder
    float?: SortOrder
    dFloat?: SortOrder
  }

  export type BSumOrderByAggregateInput = {
    float?: SortOrder
    dFloat?: SortOrder
  }

  export type CCountOrderByAggregateInput = {
    id?: SortOrder
    char?: SortOrder
    vChar?: SortOrder
    text?: SortOrder
    bit?: SortOrder
    vBit?: SortOrder
    uuid?: SortOrder
  }

  export type CMaxOrderByAggregateInput = {
    id?: SortOrder
    char?: SortOrder
    vChar?: SortOrder
    text?: SortOrder
    bit?: SortOrder
    vBit?: SortOrder
    uuid?: SortOrder
  }

  export type CMinOrderByAggregateInput = {
    id?: SortOrder
    char?: SortOrder
    vChar?: SortOrder
    text?: SortOrder
    bit?: SortOrder
    vBit?: SortOrder
    uuid?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DCountOrderByAggregateInput = {
    id?: SortOrder
    bool?: SortOrder
    byteA?: SortOrder
    xml?: SortOrder
    json?: SortOrder
    jsonb?: SortOrder
    list?: SortOrder
  }

  export type DAvgOrderByAggregateInput = {
    list?: SortOrder
  }

  export type DMaxOrderByAggregateInput = {
    id?: SortOrder
    bool?: SortOrder
    byteA?: SortOrder
    xml?: SortOrder
  }

  export type DMinOrderByAggregateInput = {
    id?: SortOrder
    bool?: SortOrder
    byteA?: SortOrder
    xml?: SortOrder
  }

  export type DSumOrderByAggregateInput = {
    list?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type ECountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    ts?: SortOrder
  }

  export type EMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    ts?: SortOrder
  }

  export type EMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    ts?: SortOrder
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type EmbedHolderCreateNestedOneWithoutUserInput = {
    create?: XOR<EmbedHolderCreateWithoutUserInput, EmbedHolderUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmbedHolderCreateOrConnectWithoutUserInput
    connect?: EmbedHolderWhereUniqueInput
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type EnumABeautifulEnumFieldUpdateOperationsInput = {
    set?: $Enums.ABeautifulEnum
  }

  export type NullableEnumABeautifulEnumFieldUpdateOperationsInput = {
    set?: $Enums.ABeautifulEnum | null
    unset?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type EmbedHolderUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<EmbedHolderCreateWithoutUserInput, EmbedHolderUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmbedHolderCreateOrConnectWithoutUserInput
    upsert?: EmbedHolderUpsertWithoutUserInput
    connect?: EmbedHolderWhereUniqueInput
    update?: XOR<XOR<EmbedHolderUpdateToOneWithWhereWithoutUserInput, EmbedHolderUpdateWithoutUserInput>, EmbedHolderUncheckedUpdateWithoutUserInput>
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type EmbedListCreateEnvelopeInput = {
    set?: EmbedCreateInput | EmbedCreateInput[]
  }

  export type EmbedCreateInput = {
    text: string
    boolean: boolean
    embedEmbedList?: EmbedEmbedCreateInput | EmbedEmbedCreateInput[]
    requiredEmbedEmbed: EmbedEmbedCreateInput
    optionalEmbedEmbed?: EmbedEmbedCreateInput | null
    scalarList?: EmbedCreatescalarListInput | number[]
  }

  export type EmbedCreateEnvelopeInput = {
    set?: EmbedCreateInput
  }

  export type EmbedNullableCreateEnvelopeInput = {
    set?: EmbedCreateInput | null
  }

  export type UserCreateNestedManyWithoutEmbedHolderInput = {
    create?: XOR<UserCreateWithoutEmbedHolderInput, UserUncheckedCreateWithoutEmbedHolderInput> | UserCreateWithoutEmbedHolderInput[] | UserUncheckedCreateWithoutEmbedHolderInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEmbedHolderInput | UserCreateOrConnectWithoutEmbedHolderInput[]
    createMany?: UserCreateManyEmbedHolderInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutEmbedHolderInput = {
    create?: XOR<UserCreateWithoutEmbedHolderInput, UserUncheckedCreateWithoutEmbedHolderInput> | UserCreateWithoutEmbedHolderInput[] | UserUncheckedCreateWithoutEmbedHolderInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEmbedHolderInput | UserCreateOrConnectWithoutEmbedHolderInput[]
    createMany?: UserCreateManyEmbedHolderInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EmbedListUpdateEnvelopeInput = {
    set?: EmbedCreateInput | EmbedCreateInput[]
    push?: EmbedCreateInput | EmbedCreateInput[]
    updateMany?: EmbedUpdateManyInput
    deleteMany?: EmbedDeleteManyInput
  }

  export type EmbedUpdateEnvelopeInput = {
    set?: EmbedCreateInput
    update?: EmbedUpdateInput
  }

  export type EmbedNullableUpdateEnvelopeInput = {
    set?: EmbedCreateInput | null
    upsert?: EmbedUpsertInput
    unset?: boolean
  }

  export type UserUpdateManyWithoutEmbedHolderNestedInput = {
    create?: XOR<UserCreateWithoutEmbedHolderInput, UserUncheckedCreateWithoutEmbedHolderInput> | UserCreateWithoutEmbedHolderInput[] | UserUncheckedCreateWithoutEmbedHolderInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEmbedHolderInput | UserCreateOrConnectWithoutEmbedHolderInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutEmbedHolderInput | UserUpsertWithWhereUniqueWithoutEmbedHolderInput[]
    createMany?: UserCreateManyEmbedHolderInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutEmbedHolderInput | UserUpdateWithWhereUniqueWithoutEmbedHolderInput[]
    updateMany?: UserUpdateManyWithWhereWithoutEmbedHolderInput | UserUpdateManyWithWhereWithoutEmbedHolderInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutEmbedHolderNestedInput = {
    create?: XOR<UserCreateWithoutEmbedHolderInput, UserUncheckedCreateWithoutEmbedHolderInput> | UserCreateWithoutEmbedHolderInput[] | UserUncheckedCreateWithoutEmbedHolderInput[]
    connectOrCreate?: UserCreateOrConnectWithoutEmbedHolderInput | UserCreateOrConnectWithoutEmbedHolderInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutEmbedHolderInput | UserUpsertWithWhereUniqueWithoutEmbedHolderInput[]
    createMany?: UserCreateManyEmbedHolderInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutEmbedHolderInput | UserUpdateWithWhereUniqueWithoutEmbedHolderInput[]
    updateMany?: UserUpdateManyWithWhereWithoutEmbedHolderInput | UserUpdateManyWithWhereWithoutEmbedHolderInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NCreateNestedManyWithoutMInput = {
    create?: XOR<NCreateWithoutMInput, NUncheckedCreateWithoutMInput> | NCreateWithoutMInput[] | NUncheckedCreateWithoutMInput[]
    connectOrCreate?: NCreateOrConnectWithoutMInput | NCreateOrConnectWithoutMInput[]
    connect?: NWhereUniqueInput | NWhereUniqueInput[]
  }

  export type MCreaten_idsInput = {
    set: string[]
  }

  export type NUncheckedCreateNestedManyWithoutMInput = {
    create?: XOR<NCreateWithoutMInput, NUncheckedCreateWithoutMInput> | NCreateWithoutMInput[] | NUncheckedCreateWithoutMInput[]
    connectOrCreate?: NCreateOrConnectWithoutMInput | NCreateOrConnectWithoutMInput[]
    connect?: NWhereUniqueInput | NWhereUniqueInput[]
  }

  export type NUpdateManyWithoutMNestedInput = {
    create?: XOR<NCreateWithoutMInput, NUncheckedCreateWithoutMInput> | NCreateWithoutMInput[] | NUncheckedCreateWithoutMInput[]
    connectOrCreate?: NCreateOrConnectWithoutMInput | NCreateOrConnectWithoutMInput[]
    upsert?: NUpsertWithWhereUniqueWithoutMInput | NUpsertWithWhereUniqueWithoutMInput[]
    set?: NWhereUniqueInput | NWhereUniqueInput[]
    disconnect?: NWhereUniqueInput | NWhereUniqueInput[]
    delete?: NWhereUniqueInput | NWhereUniqueInput[]
    connect?: NWhereUniqueInput | NWhereUniqueInput[]
    update?: NUpdateWithWhereUniqueWithoutMInput | NUpdateWithWhereUniqueWithoutMInput[]
    updateMany?: NUpdateManyWithWhereWithoutMInput | NUpdateManyWithWhereWithoutMInput[]
    deleteMany?: NScalarWhereInput | NScalarWhereInput[]
  }

  export type MUpdaten_idsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NUncheckedUpdateManyWithoutMNestedInput = {
    create?: XOR<NCreateWithoutMInput, NUncheckedCreateWithoutMInput> | NCreateWithoutMInput[] | NUncheckedCreateWithoutMInput[]
    connectOrCreate?: NCreateOrConnectWithoutMInput | NCreateOrConnectWithoutMInput[]
    upsert?: NUpsertWithWhereUniqueWithoutMInput | NUpsertWithWhereUniqueWithoutMInput[]
    set?: NWhereUniqueInput | NWhereUniqueInput[]
    disconnect?: NWhereUniqueInput | NWhereUniqueInput[]
    delete?: NWhereUniqueInput | NWhereUniqueInput[]
    connect?: NWhereUniqueInput | NWhereUniqueInput[]
    update?: NUpdateWithWhereUniqueWithoutMInput | NUpdateWithWhereUniqueWithoutMInput[]
    updateMany?: NUpdateManyWithWhereWithoutMInput | NUpdateManyWithWhereWithoutMInput[]
    deleteMany?: NScalarWhereInput | NScalarWhereInput[]
  }

  export type MCreateNestedManyWithoutNInput = {
    create?: XOR<MCreateWithoutNInput, MUncheckedCreateWithoutNInput> | MCreateWithoutNInput[] | MUncheckedCreateWithoutNInput[]
    connectOrCreate?: MCreateOrConnectWithoutNInput | MCreateOrConnectWithoutNInput[]
    connect?: MWhereUniqueInput | MWhereUniqueInput[]
  }

  export type NCreatem_idsInput = {
    set: string[]
  }

  export type MUncheckedCreateNestedManyWithoutNInput = {
    create?: XOR<MCreateWithoutNInput, MUncheckedCreateWithoutNInput> | MCreateWithoutNInput[] | MUncheckedCreateWithoutNInput[]
    connectOrCreate?: MCreateOrConnectWithoutNInput | MCreateOrConnectWithoutNInput[]
    connect?: MWhereUniqueInput | MWhereUniqueInput[]
  }

  export type MUpdateManyWithoutNNestedInput = {
    create?: XOR<MCreateWithoutNInput, MUncheckedCreateWithoutNInput> | MCreateWithoutNInput[] | MUncheckedCreateWithoutNInput[]
    connectOrCreate?: MCreateOrConnectWithoutNInput | MCreateOrConnectWithoutNInput[]
    upsert?: MUpsertWithWhereUniqueWithoutNInput | MUpsertWithWhereUniqueWithoutNInput[]
    set?: MWhereUniqueInput | MWhereUniqueInput[]
    disconnect?: MWhereUniqueInput | MWhereUniqueInput[]
    delete?: MWhereUniqueInput | MWhereUniqueInput[]
    connect?: MWhereUniqueInput | MWhereUniqueInput[]
    update?: MUpdateWithWhereUniqueWithoutNInput | MUpdateWithWhereUniqueWithoutNInput[]
    updateMany?: MUpdateManyWithWhereWithoutNInput | MUpdateManyWithWhereWithoutNInput[]
    deleteMany?: MScalarWhereInput | MScalarWhereInput[]
  }

  export type NUpdatem_idsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MUncheckedUpdateManyWithoutNNestedInput = {
    create?: XOR<MCreateWithoutNInput, MUncheckedCreateWithoutNInput> | MCreateWithoutNInput[] | MUncheckedCreateWithoutNInput[]
    connectOrCreate?: MCreateOrConnectWithoutNInput | MCreateOrConnectWithoutNInput[]
    upsert?: MUpsertWithWhereUniqueWithoutNInput | MUpsertWithWhereUniqueWithoutNInput[]
    set?: MWhereUniqueInput | MWhereUniqueInput[]
    disconnect?: MWhereUniqueInput | MWhereUniqueInput[]
    delete?: MWhereUniqueInput | MWhereUniqueInput[]
    connect?: MWhereUniqueInput | MWhereUniqueInput[]
    update?: MUpdateWithWhereUniqueWithoutNInput | MUpdateWithWhereUniqueWithoutNInput[]
    updateMany?: MUpdateManyWithWhereWithoutNInput | MUpdateManyWithWhereWithoutNInput[]
    deleteMany?: MScalarWhereInput | MScalarWhereInput[]
  }

  export type ManyRequiredCreateNestedManyWithoutOneInput = {
    create?: XOR<ManyRequiredCreateWithoutOneInput, ManyRequiredUncheckedCreateWithoutOneInput> | ManyRequiredCreateWithoutOneInput[] | ManyRequiredUncheckedCreateWithoutOneInput[]
    connectOrCreate?: ManyRequiredCreateOrConnectWithoutOneInput | ManyRequiredCreateOrConnectWithoutOneInput[]
    createMany?: ManyRequiredCreateManyOneInputEnvelope
    connect?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
  }

  export type ManyRequiredUncheckedCreateNestedManyWithoutOneInput = {
    create?: XOR<ManyRequiredCreateWithoutOneInput, ManyRequiredUncheckedCreateWithoutOneInput> | ManyRequiredCreateWithoutOneInput[] | ManyRequiredUncheckedCreateWithoutOneInput[]
    connectOrCreate?: ManyRequiredCreateOrConnectWithoutOneInput | ManyRequiredCreateOrConnectWithoutOneInput[]
    createMany?: ManyRequiredCreateManyOneInputEnvelope
    connect?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
  }

  export type ManyRequiredUpdateManyWithoutOneNestedInput = {
    create?: XOR<ManyRequiredCreateWithoutOneInput, ManyRequiredUncheckedCreateWithoutOneInput> | ManyRequiredCreateWithoutOneInput[] | ManyRequiredUncheckedCreateWithoutOneInput[]
    connectOrCreate?: ManyRequiredCreateOrConnectWithoutOneInput | ManyRequiredCreateOrConnectWithoutOneInput[]
    upsert?: ManyRequiredUpsertWithWhereUniqueWithoutOneInput | ManyRequiredUpsertWithWhereUniqueWithoutOneInput[]
    createMany?: ManyRequiredCreateManyOneInputEnvelope
    set?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
    disconnect?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
    delete?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
    connect?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
    update?: ManyRequiredUpdateWithWhereUniqueWithoutOneInput | ManyRequiredUpdateWithWhereUniqueWithoutOneInput[]
    updateMany?: ManyRequiredUpdateManyWithWhereWithoutOneInput | ManyRequiredUpdateManyWithWhereWithoutOneInput[]
    deleteMany?: ManyRequiredScalarWhereInput | ManyRequiredScalarWhereInput[]
  }

  export type ManyRequiredUncheckedUpdateManyWithoutOneNestedInput = {
    create?: XOR<ManyRequiredCreateWithoutOneInput, ManyRequiredUncheckedCreateWithoutOneInput> | ManyRequiredCreateWithoutOneInput[] | ManyRequiredUncheckedCreateWithoutOneInput[]
    connectOrCreate?: ManyRequiredCreateOrConnectWithoutOneInput | ManyRequiredCreateOrConnectWithoutOneInput[]
    upsert?: ManyRequiredUpsertWithWhereUniqueWithoutOneInput | ManyRequiredUpsertWithWhereUniqueWithoutOneInput[]
    createMany?: ManyRequiredCreateManyOneInputEnvelope
    set?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
    disconnect?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
    delete?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
    connect?: ManyRequiredWhereUniqueInput | ManyRequiredWhereUniqueInput[]
    update?: ManyRequiredUpdateWithWhereUniqueWithoutOneInput | ManyRequiredUpdateWithWhereUniqueWithoutOneInput[]
    updateMany?: ManyRequiredUpdateManyWithWhereWithoutOneInput | ManyRequiredUpdateManyWithWhereWithoutOneInput[]
    deleteMany?: ManyRequiredScalarWhereInput | ManyRequiredScalarWhereInput[]
  }

  export type OneOptionalCreateNestedOneWithoutManyInput = {
    create?: XOR<OneOptionalCreateWithoutManyInput, OneOptionalUncheckedCreateWithoutManyInput>
    connectOrCreate?: OneOptionalCreateOrConnectWithoutManyInput
    connect?: OneOptionalWhereUniqueInput
  }

  export type OneOptionalUpdateOneWithoutManyNestedInput = {
    create?: XOR<OneOptionalCreateWithoutManyInput, OneOptionalUncheckedCreateWithoutManyInput>
    connectOrCreate?: OneOptionalCreateOrConnectWithoutManyInput
    upsert?: OneOptionalUpsertWithoutManyInput
    disconnect?: boolean
    delete?: OneOptionalWhereInput | boolean
    connect?: OneOptionalWhereUniqueInput
    update?: XOR<XOR<OneOptionalUpdateToOneWithWhereWithoutManyInput, OneOptionalUpdateWithoutManyInput>, OneOptionalUncheckedUpdateWithoutManyInput>
  }

  export type OptionalSide2CreateNestedOneWithoutOptiInput = {
    create?: XOR<OptionalSide2CreateWithoutOptiInput, OptionalSide2UncheckedCreateWithoutOptiInput>
    connectOrCreate?: OptionalSide2CreateOrConnectWithoutOptiInput
    connect?: OptionalSide2WhereUniqueInput
  }

  export type OptionalSide2UpdateOneWithoutOptiNestedInput = {
    create?: XOR<OptionalSide2CreateWithoutOptiInput, OptionalSide2UncheckedCreateWithoutOptiInput>
    connectOrCreate?: OptionalSide2CreateOrConnectWithoutOptiInput
    upsert?: OptionalSide2UpsertWithoutOptiInput
    disconnect?: boolean
    delete?: OptionalSide2WhereInput | boolean
    connect?: OptionalSide2WhereUniqueInput
    update?: XOR<XOR<OptionalSide2UpdateToOneWithWhereWithoutOptiInput, OptionalSide2UpdateWithoutOptiInput>, OptionalSide2UncheckedUpdateWithoutOptiInput>
  }

  export type OptionalSide1CreateNestedOneWithoutOptiInput = {
    create?: XOR<OptionalSide1CreateWithoutOptiInput, OptionalSide1UncheckedCreateWithoutOptiInput>
    connectOrCreate?: OptionalSide1CreateOrConnectWithoutOptiInput
    connect?: OptionalSide1WhereUniqueInput
  }

  export type OptionalSide1UncheckedCreateNestedOneWithoutOptiInput = {
    create?: XOR<OptionalSide1CreateWithoutOptiInput, OptionalSide1UncheckedCreateWithoutOptiInput>
    connectOrCreate?: OptionalSide1CreateOrConnectWithoutOptiInput
    connect?: OptionalSide1WhereUniqueInput
  }

  export type OptionalSide1UpdateOneWithoutOptiNestedInput = {
    create?: XOR<OptionalSide1CreateWithoutOptiInput, OptionalSide1UncheckedCreateWithoutOptiInput>
    connectOrCreate?: OptionalSide1CreateOrConnectWithoutOptiInput
    upsert?: OptionalSide1UpsertWithoutOptiInput
    disconnect?: OptionalSide1WhereInput | boolean
    delete?: OptionalSide1WhereInput | boolean
    connect?: OptionalSide1WhereUniqueInput
    update?: XOR<XOR<OptionalSide1UpdateToOneWithWhereWithoutOptiInput, OptionalSide1UpdateWithoutOptiInput>, OptionalSide1UncheckedUpdateWithoutOptiInput>
  }

  export type OptionalSide1UncheckedUpdateOneWithoutOptiNestedInput = {
    create?: XOR<OptionalSide1CreateWithoutOptiInput, OptionalSide1UncheckedCreateWithoutOptiInput>
    connectOrCreate?: OptionalSide1CreateOrConnectWithoutOptiInput
    upsert?: OptionalSide1UpsertWithoutOptiInput
    disconnect?: OptionalSide1WhereInput | boolean
    delete?: OptionalSide1WhereInput | boolean
    connect?: OptionalSide1WhereUniqueInput
    update?: XOR<XOR<OptionalSide1UpdateToOneWithWhereWithoutOptiInput, OptionalSide1UpdateWithoutOptiInput>, OptionalSide1UncheckedUpdateWithoutOptiInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DCreatelistInput = {
    set: number[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type DUpdatelistInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumABeautifulEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ABeautifulEnum | EnumABeautifulEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumABeautifulEnumFilter<$PrismaModel> | $Enums.ABeautifulEnum
  }

  export type NestedEnumABeautifulEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ABeautifulEnum | EnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumABeautifulEnumNullableFilter<$PrismaModel> | $Enums.ABeautifulEnum | null
    isSet?: boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedEnumABeautifulEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ABeautifulEnum | EnumABeautifulEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumABeautifulEnumWithAggregatesFilter<$PrismaModel> | $Enums.ABeautifulEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumABeautifulEnumFilter<$PrismaModel>
    _max?: NestedEnumABeautifulEnumFilter<$PrismaModel>
  }

  export type NestedEnumABeautifulEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ABeautifulEnum | EnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ABeautifulEnum[] | ListEnumABeautifulEnumFieldRefInput<$PrismaModel> | null
    not?: NestedEnumABeautifulEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.ABeautifulEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumABeautifulEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumABeautifulEnumNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EmbedWhereInput = {
    AND?: EmbedWhereInput | EmbedWhereInput[]
    OR?: EmbedWhereInput[]
    NOT?: EmbedWhereInput | EmbedWhereInput[]
    text?: StringFilter<"Embed"> | string
    boolean?: BoolFilter<"Embed"> | boolean
    embedEmbedList?: EmbedEmbedCompositeListFilter | EmbedEmbedObjectEqualityInput[]
    requiredEmbedEmbed?: XOR<EmbedEmbedCompositeFilter, EmbedEmbedObjectEqualityInput>
    optionalEmbedEmbed?: XOR<EmbedEmbedNullableCompositeFilter, EmbedEmbedObjectEqualityInput> | null
    scalarList?: IntNullableListFilter<"Embed">
  }

  export type EmbedEmbedObjectEqualityInput = {
    text: string
    boolean: boolean
  }

  export type EmbedEmbedOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type EmbedEmbedOrderByInput = {
    text?: SortOrder
    boolean?: SortOrder
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    email: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    embedHolder: EmbedHolderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    email: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    embedHolderId: string
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    embedHolder?: EmbedHolderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    embedHolderId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    published?: boolean
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    published?: boolean
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
  }

  export type EmbedHolderCreateWithoutUserInput = {
    id?: string
    time?: Date | string
    text: string
    boolean: boolean
    embedList?: XOR<EmbedListCreateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed: XOR<EmbedCreateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableCreateEnvelopeInput, EmbedCreateInput> | null
  }

  export type EmbedHolderUncheckedCreateWithoutUserInput = {
    id?: string
    time?: Date | string
    text: string
    boolean: boolean
    embedList?: XOR<EmbedListCreateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed: XOR<EmbedCreateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableCreateEnvelopeInput, EmbedCreateInput> | null
  }

  export type EmbedHolderCreateOrConnectWithoutUserInput = {
    where: EmbedHolderWhereUniqueInput
    create: XOR<EmbedHolderCreateWithoutUserInput, EmbedHolderUncheckedCreateWithoutUserInput>
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    title?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    published?: BoolFilter<"Post"> | boolean
    authorId?: StringFilter<"Post"> | string
  }

  export type EmbedHolderUpsertWithoutUserInput = {
    update: XOR<EmbedHolderUpdateWithoutUserInput, EmbedHolderUncheckedUpdateWithoutUserInput>
    create: XOR<EmbedHolderCreateWithoutUserInput, EmbedHolderUncheckedCreateWithoutUserInput>
    where?: EmbedHolderWhereInput
  }

  export type EmbedHolderUpdateToOneWithWhereWithoutUserInput = {
    where?: EmbedHolderWhereInput
    data: XOR<EmbedHolderUpdateWithoutUserInput, EmbedHolderUncheckedUpdateWithoutUserInput>
  }

  export type EmbedHolderUpdateWithoutUserInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    boolean?: BoolFieldUpdateOperationsInput | boolean
    embedList?: XOR<EmbedListUpdateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed?: XOR<EmbedUpdateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableUpdateEnvelopeInput, EmbedCreateInput> | null
  }

  export type EmbedHolderUncheckedUpdateWithoutUserInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
    boolean?: BoolFieldUpdateOperationsInput | boolean
    embedList?: XOR<EmbedListUpdateEnvelopeInput, EmbedCreateInput> | EmbedCreateInput[]
    requiredEmbed?: XOR<EmbedUpdateEnvelopeInput, EmbedCreateInput>
    optionalEmbed?: XOR<EmbedNullableUpdateEnvelopeInput, EmbedCreateInput> | null
  }

  export type EmbedEmbedCreateInput = {
    text: string
    boolean: boolean
  }

  export type EmbedCreatescalarListInput = {
    set: number[]
  }

  export type UserCreateWithoutEmbedHolderInput = {
    id?: string
    email: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    posts?: PostCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutEmbedHolderInput = {
    id?: string
    email: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutEmbedHolderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmbedHolderInput, UserUncheckedCreateWithoutEmbedHolderInput>
  }

  export type UserCreateManyEmbedHolderInputEnvelope = {
    data: UserCreateManyEmbedHolderInput | UserCreateManyEmbedHolderInput[]
  }

  export type EmbedUpdateManyInput = {
    where: EmbedWhereInput
    data: EmbedUpdateInput
  }

  export type EmbedDeleteManyInput = {
    where: EmbedWhereInput
  }

  export type EmbedUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    boolean?: BoolFieldUpdateOperationsInput | boolean
    embedEmbedList?: XOR<EmbedEmbedListUpdateEnvelopeInput, EmbedEmbedCreateInput> | EmbedEmbedCreateInput[]
    requiredEmbedEmbed?: XOR<EmbedEmbedUpdateEnvelopeInput, EmbedEmbedCreateInput>
    optionalEmbedEmbed?: XOR<EmbedEmbedNullableUpdateEnvelopeInput, EmbedEmbedCreateInput> | null
    scalarList?: EmbedUpdatescalarListInput | number[]
  }

  export type EmbedUpsertInput = {
    set: EmbedCreateInput | null
    update: EmbedUpdateInput
  }

  export type UserUpsertWithWhereUniqueWithoutEmbedHolderInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutEmbedHolderInput, UserUncheckedUpdateWithoutEmbedHolderInput>
    create: XOR<UserCreateWithoutEmbedHolderInput, UserUncheckedCreateWithoutEmbedHolderInput>
  }

  export type UserUpdateWithWhereUniqueWithoutEmbedHolderInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutEmbedHolderInput, UserUncheckedUpdateWithoutEmbedHolderInput>
  }

  export type UserUpdateManyWithWhereWithoutEmbedHolderInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutEmbedHolderInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    int?: IntFilter<"User"> | number
    optionalInt?: IntNullableFilter<"User"> | number | null
    float?: FloatFilter<"User"> | number
    optionalFloat?: FloatNullableFilter<"User"> | number | null
    string?: StringFilter<"User"> | string
    optionalString?: StringNullableFilter<"User"> | string | null
    json?: JsonFilter<"User">
    optionalJson?: JsonNullableFilter<"User">
    enum?: EnumABeautifulEnumFilter<"User"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"User"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"User"> | boolean
    optionalBoolean?: BoolNullableFilter<"User"> | boolean | null
    embedHolderId?: StringFilter<"User"> | string
  }

  export type NCreateWithoutMInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type NUncheckedCreateWithoutMInput = {
    id?: string
    m_ids?: NCreatem_idsInput | string[]
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type NCreateOrConnectWithoutMInput = {
    where: NWhereUniqueInput
    create: XOR<NCreateWithoutMInput, NUncheckedCreateWithoutMInput>
  }

  export type NUpsertWithWhereUniqueWithoutMInput = {
    where: NWhereUniqueInput
    update: XOR<NUpdateWithoutMInput, NUncheckedUpdateWithoutMInput>
    create: XOR<NCreateWithoutMInput, NUncheckedCreateWithoutMInput>
  }

  export type NUpdateWithWhereUniqueWithoutMInput = {
    where: NWhereUniqueInput
    data: XOR<NUpdateWithoutMInput, NUncheckedUpdateWithoutMInput>
  }

  export type NUpdateManyWithWhereWithoutMInput = {
    where: NScalarWhereInput
    data: XOR<NUpdateManyMutationInput, NUncheckedUpdateManyWithoutMInput>
  }

  export type NScalarWhereInput = {
    AND?: NScalarWhereInput | NScalarWhereInput[]
    OR?: NScalarWhereInput[]
    NOT?: NScalarWhereInput | NScalarWhereInput[]
    id?: StringFilter<"N"> | string
    m_ids?: StringNullableListFilter<"N">
    int?: IntFilter<"N"> | number
    optionalInt?: IntNullableFilter<"N"> | number | null
    float?: FloatFilter<"N"> | number
    optionalFloat?: FloatNullableFilter<"N"> | number | null
    string?: StringFilter<"N"> | string
    optionalString?: StringNullableFilter<"N"> | string | null
    json?: JsonFilter<"N">
    optionalJson?: JsonNullableFilter<"N">
    enum?: EnumABeautifulEnumFilter<"N"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"N"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"N"> | boolean
    optionalBoolean?: BoolNullableFilter<"N"> | boolean | null
  }

  export type MCreateWithoutNInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type MUncheckedCreateWithoutNInput = {
    id?: string
    n_ids?: MCreaten_idsInput | string[]
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type MCreateOrConnectWithoutNInput = {
    where: MWhereUniqueInput
    create: XOR<MCreateWithoutNInput, MUncheckedCreateWithoutNInput>
  }

  export type MUpsertWithWhereUniqueWithoutNInput = {
    where: MWhereUniqueInput
    update: XOR<MUpdateWithoutNInput, MUncheckedUpdateWithoutNInput>
    create: XOR<MCreateWithoutNInput, MUncheckedCreateWithoutNInput>
  }

  export type MUpdateWithWhereUniqueWithoutNInput = {
    where: MWhereUniqueInput
    data: XOR<MUpdateWithoutNInput, MUncheckedUpdateWithoutNInput>
  }

  export type MUpdateManyWithWhereWithoutNInput = {
    where: MScalarWhereInput
    data: XOR<MUpdateManyMutationInput, MUncheckedUpdateManyWithoutNInput>
  }

  export type MScalarWhereInput = {
    AND?: MScalarWhereInput | MScalarWhereInput[]
    OR?: MScalarWhereInput[]
    NOT?: MScalarWhereInput | MScalarWhereInput[]
    id?: StringFilter<"M"> | string
    n_ids?: StringNullableListFilter<"M">
    int?: IntFilter<"M"> | number
    optionalInt?: IntNullableFilter<"M"> | number | null
    float?: FloatFilter<"M"> | number
    optionalFloat?: FloatNullableFilter<"M"> | number | null
    string?: StringFilter<"M"> | string
    optionalString?: StringNullableFilter<"M"> | string | null
    json?: JsonFilter<"M">
    optionalJson?: JsonNullableFilter<"M">
    enum?: EnumABeautifulEnumFilter<"M"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"M"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"M"> | boolean
    optionalBoolean?: BoolNullableFilter<"M"> | boolean | null
  }

  export type ManyRequiredCreateWithoutOneInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type ManyRequiredUncheckedCreateWithoutOneInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type ManyRequiredCreateOrConnectWithoutOneInput = {
    where: ManyRequiredWhereUniqueInput
    create: XOR<ManyRequiredCreateWithoutOneInput, ManyRequiredUncheckedCreateWithoutOneInput>
  }

  export type ManyRequiredCreateManyOneInputEnvelope = {
    data: ManyRequiredCreateManyOneInput | ManyRequiredCreateManyOneInput[]
  }

  export type ManyRequiredUpsertWithWhereUniqueWithoutOneInput = {
    where: ManyRequiredWhereUniqueInput
    update: XOR<ManyRequiredUpdateWithoutOneInput, ManyRequiredUncheckedUpdateWithoutOneInput>
    create: XOR<ManyRequiredCreateWithoutOneInput, ManyRequiredUncheckedCreateWithoutOneInput>
  }

  export type ManyRequiredUpdateWithWhereUniqueWithoutOneInput = {
    where: ManyRequiredWhereUniqueInput
    data: XOR<ManyRequiredUpdateWithoutOneInput, ManyRequiredUncheckedUpdateWithoutOneInput>
  }

  export type ManyRequiredUpdateManyWithWhereWithoutOneInput = {
    where: ManyRequiredScalarWhereInput
    data: XOR<ManyRequiredUpdateManyMutationInput, ManyRequiredUncheckedUpdateManyWithoutOneInput>
  }

  export type ManyRequiredScalarWhereInput = {
    AND?: ManyRequiredScalarWhereInput | ManyRequiredScalarWhereInput[]
    OR?: ManyRequiredScalarWhereInput[]
    NOT?: ManyRequiredScalarWhereInput | ManyRequiredScalarWhereInput[]
    id?: StringFilter<"ManyRequired"> | string
    oneOptionalId?: StringNullableFilter<"ManyRequired"> | string | null
    int?: IntFilter<"ManyRequired"> | number
    optionalInt?: IntNullableFilter<"ManyRequired"> | number | null
    float?: FloatFilter<"ManyRequired"> | number
    optionalFloat?: FloatNullableFilter<"ManyRequired"> | number | null
    string?: StringFilter<"ManyRequired"> | string
    optionalString?: StringNullableFilter<"ManyRequired"> | string | null
    json?: JsonFilter<"ManyRequired">
    optionalJson?: JsonNullableFilter<"ManyRequired">
    enum?: EnumABeautifulEnumFilter<"ManyRequired"> | $Enums.ABeautifulEnum
    optionalEnum?: EnumABeautifulEnumNullableFilter<"ManyRequired"> | $Enums.ABeautifulEnum | null
    boolean?: BoolFilter<"ManyRequired"> | boolean
    optionalBoolean?: BoolNullableFilter<"ManyRequired"> | boolean | null
  }

  export type OneOptionalCreateWithoutManyInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OneOptionalUncheckedCreateWithoutManyInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OneOptionalCreateOrConnectWithoutManyInput = {
    where: OneOptionalWhereUniqueInput
    create: XOR<OneOptionalCreateWithoutManyInput, OneOptionalUncheckedCreateWithoutManyInput>
  }

  export type OneOptionalUpsertWithoutManyInput = {
    update: XOR<OneOptionalUpdateWithoutManyInput, OneOptionalUncheckedUpdateWithoutManyInput>
    create: XOR<OneOptionalCreateWithoutManyInput, OneOptionalUncheckedCreateWithoutManyInput>
    where?: OneOptionalWhereInput
  }

  export type OneOptionalUpdateToOneWithWhereWithoutManyInput = {
    where?: OneOptionalWhereInput
    data: XOR<OneOptionalUpdateWithoutManyInput, OneOptionalUncheckedUpdateWithoutManyInput>
  }

  export type OneOptionalUpdateWithoutManyInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OneOptionalUncheckedUpdateWithoutManyInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionalSide2CreateWithoutOptiInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OptionalSide2UncheckedCreateWithoutOptiInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OptionalSide2CreateOrConnectWithoutOptiInput = {
    where: OptionalSide2WhereUniqueInput
    create: XOR<OptionalSide2CreateWithoutOptiInput, OptionalSide2UncheckedCreateWithoutOptiInput>
  }

  export type OptionalSide2UpsertWithoutOptiInput = {
    update: XOR<OptionalSide2UpdateWithoutOptiInput, OptionalSide2UncheckedUpdateWithoutOptiInput>
    create: XOR<OptionalSide2CreateWithoutOptiInput, OptionalSide2UncheckedCreateWithoutOptiInput>
    where?: OptionalSide2WhereInput
  }

  export type OptionalSide2UpdateToOneWithWhereWithoutOptiInput = {
    where?: OptionalSide2WhereInput
    data: XOR<OptionalSide2UpdateWithoutOptiInput, OptionalSide2UncheckedUpdateWithoutOptiInput>
  }

  export type OptionalSide2UpdateWithoutOptiInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionalSide2UncheckedUpdateWithoutOptiInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionalSide1CreateWithoutOptiInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OptionalSide1UncheckedCreateWithoutOptiInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type OptionalSide1CreateOrConnectWithoutOptiInput = {
    where: OptionalSide1WhereUniqueInput
    create: XOR<OptionalSide1CreateWithoutOptiInput, OptionalSide1UncheckedCreateWithoutOptiInput>
  }

  export type OptionalSide1UpsertWithoutOptiInput = {
    update: XOR<OptionalSide1UpdateWithoutOptiInput, OptionalSide1UncheckedUpdateWithoutOptiInput>
    create: XOR<OptionalSide1CreateWithoutOptiInput, OptionalSide1UncheckedCreateWithoutOptiInput>
    where?: OptionalSide1WhereInput
  }

  export type OptionalSide1UpdateToOneWithWhereWithoutOptiInput = {
    where?: OptionalSide1WhereInput
    data: XOR<OptionalSide1UpdateWithoutOptiInput, OptionalSide1UncheckedUpdateWithoutOptiInput>
  }

  export type OptionalSide1UpdateWithoutOptiInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OptionalSide1UncheckedUpdateWithoutOptiInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type EmbedEmbedCompositeListFilter = {
    equals?: EmbedEmbedObjectEqualityInput[]
    every?: EmbedEmbedWhereInput
    some?: EmbedEmbedWhereInput
    none?: EmbedEmbedWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type EmbedEmbedCompositeFilter = {
    equals?: EmbedEmbedObjectEqualityInput
    is?: EmbedEmbedWhereInput
    isNot?: EmbedEmbedWhereInput
  }

  export type EmbedEmbedNullableCompositeFilter = {
    equals?: EmbedEmbedObjectEqualityInput | null
    is?: EmbedEmbedWhereInput | null
    isNot?: EmbedEmbedWhereInput | null
    isSet?: boolean
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    createdAt?: Date | string
    title: string
    content?: string | null
    published?: boolean
  }

  export type PostUpdateWithoutAuthorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateManyEmbedHolderInput = {
    id?: string
    email: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type EmbedEmbedListUpdateEnvelopeInput = {
    set?: EmbedEmbedCreateInput | EmbedEmbedCreateInput[]
    push?: EmbedEmbedCreateInput | EmbedEmbedCreateInput[]
    updateMany?: EmbedEmbedUpdateManyInput
    deleteMany?: EmbedEmbedDeleteManyInput
  }

  export type EmbedEmbedUpdateEnvelopeInput = {
    set?: EmbedEmbedCreateInput
    update?: EmbedEmbedUpdateInput
  }

  export type EmbedEmbedNullableUpdateEnvelopeInput = {
    set?: EmbedEmbedCreateInput | null
    upsert?: EmbedEmbedUpsertInput
    unset?: boolean
  }

  export type EmbedUpdatescalarListInput = {
    set?: number[]
    push?: number | number[]
  }

  export type UserUpdateWithoutEmbedHolderInput = {
    email?: StringFieldUpdateOperationsInput | string
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutEmbedHolderInput = {
    email?: StringFieldUpdateOperationsInput | string
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutEmbedHolderInput = {
    email?: StringFieldUpdateOperationsInput | string
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type NUpdateWithoutMInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type NUncheckedUpdateWithoutMInput = {
    m_ids?: NUpdatem_idsInput | string[]
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type NUncheckedUpdateManyWithoutMInput = {
    m_ids?: NUpdatem_idsInput | string[]
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MUpdateWithoutNInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MUncheckedUpdateWithoutNInput = {
    n_ids?: MUpdaten_idsInput | string[]
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MUncheckedUpdateManyWithoutNInput = {
    n_ids?: MUpdaten_idsInput | string[]
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ManyRequiredCreateManyOneInput = {
    id?: string
    int: number
    optionalInt?: number | null
    float: number
    optionalFloat?: number | null
    string: string
    optionalString?: string | null
    json: InputJsonValue
    optionalJson?: InputJsonValue | null
    enum: $Enums.ABeautifulEnum
    optionalEnum?: $Enums.ABeautifulEnum | null
    boolean: boolean
    optionalBoolean?: boolean | null
  }

  export type ManyRequiredUpdateWithoutOneInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ManyRequiredUncheckedUpdateWithoutOneInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ManyRequiredUncheckedUpdateManyWithoutOneInput = {
    int?: IntFieldUpdateOperationsInput | number
    optionalInt?: NullableIntFieldUpdateOperationsInput | number | null
    float?: FloatFieldUpdateOperationsInput | number
    optionalFloat?: NullableFloatFieldUpdateOperationsInput | number | null
    string?: StringFieldUpdateOperationsInput | string
    optionalString?: NullableStringFieldUpdateOperationsInput | string | null
    json?: InputJsonValue | InputJsonValue
    optionalJson?: InputJsonValue | InputJsonValue | null
    enum?: EnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum
    optionalEnum?: NullableEnumABeautifulEnumFieldUpdateOperationsInput | $Enums.ABeautifulEnum | null
    boolean?: BoolFieldUpdateOperationsInput | boolean
    optionalBoolean?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type EmbedEmbedWhereInput = {
    AND?: EmbedEmbedWhereInput | EmbedEmbedWhereInput[]
    OR?: EmbedEmbedWhereInput[]
    NOT?: EmbedEmbedWhereInput | EmbedEmbedWhereInput[]
    text?: StringFilter<"EmbedEmbed"> | string
    boolean?: BoolFilter<"EmbedEmbed"> | boolean
  }

  export type EmbedEmbedUpdateManyInput = {
    where: EmbedEmbedWhereInput
    data: EmbedEmbedUpdateInput
  }

  export type EmbedEmbedDeleteManyInput = {
    where: EmbedEmbedWhereInput
  }

  export type EmbedEmbedUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    boolean?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmbedEmbedUpsertInput = {
    set: EmbedEmbedCreateInput | null
    update: EmbedEmbedUpdateInput
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmbedHolderCountOutputTypeDefaultArgs instead
     */
    export type EmbedHolderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmbedHolderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MCountOutputTypeDefaultArgs instead
     */
    export type MCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NCountOutputTypeDefaultArgs instead
     */
    export type NCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OneOptionalCountOutputTypeDefaultArgs instead
     */
    export type OneOptionalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OneOptionalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmbedDefaultArgs instead
     */
    export type EmbedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmbedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmbedEmbedDefaultArgs instead
     */
    export type EmbedEmbedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmbedEmbedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmbedHolderDefaultArgs instead
     */
    export type EmbedHolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmbedHolderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MDefaultArgs instead
     */
    export type MArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NDefaultArgs instead
     */
    export type NArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OneOptionalDefaultArgs instead
     */
    export type OneOptionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OneOptionalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManyRequiredDefaultArgs instead
     */
    export type ManyRequiredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ManyRequiredDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OptionalSide1DefaultArgs instead
     */
    export type OptionalSide1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OptionalSide1DefaultArgs<ExtArgs>
    /**
     * @deprecated Use OptionalSide2DefaultArgs instead
     */
    export type OptionalSide2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OptionalSide2DefaultArgs<ExtArgs>
    /**
     * @deprecated Use ADefaultArgs instead
     */
    export type AArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ADefaultArgs<ExtArgs>
    /**
     * @deprecated Use BDefaultArgs instead
     */
    export type BArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CDefaultArgs instead
     */
    export type CArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DDefaultArgs instead
     */
    export type DArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EDefaultArgs instead
     */
    export type EArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}"
`;
