import fs from 'node:fs/promises'
import path from 'node:path'

import { ClientGenerator, TypeGenerator } from '@refract/client'
import { findSchemaFile, getDefaultOutputDir } from '@refract/config'
import { parseSchema } from '@refract/schema-parser'
import ora from 'ora'

import type { CommandResult, GenerateOptions } from '../types.js'
import { BaseCommand } from '../utils/command.js'
import { cliLoadRefractConfig } from '../utils/config-error-handler.js'
import { logger } from '../utils/logger.js'

/**
 * Client generation command that integrates with existing TypeGenerator and schema parser
 */
export class GenerateCommand extends BaseCommand {
  async execute(options: GenerateOptions = {}): Promise<CommandResult> {
    const spinner = ora('Generating Refract client...').start()

    try {
      // Load configuration using enhanced error handling
      const { config, configDir, configPath } = await cliLoadRefractConfig()

      // Find and read schema file
      const schemaPath = findSchemaFile(config, configDir)
      const schemaContent = await fs.readFile(schemaPath, 'utf-8')

      spinner.text = 'Parsing schema...'

      // Parse schema using schema parser
      const parseResult = parseSchema(schemaContent)

      if (parseResult.errors.length > 0) {
        spinner.fail('Schema parsing failed')
        const errorMessages = parseResult.errors.map((e) => e.message).join(', ')
        logger.error(`Schema parsing errors: ${errorMessages}`)
        return {
          success: false,
          message: `Schema parsing failed: ${errorMessages}`,
        }
      }

      const schemaAST = parseResult.ast

      spinner.text = 'Generating TypeScript types...'

      // Generate types using TypeGenerator
      const typeGenerator = new TypeGenerator(schemaAST)

      // Generate different type files
      const databaseSchema = typeGenerator.generateDatabaseSchema()
      const modelInterfaces = typeGenerator.generateModelInterfaces()
      const operationTypes = typeGenerator.generateModelOperationsTypes()

      spinner.text = 'Writing client files...'

      // Determine output directory with smart defaults based on config location
      const outputDir = options.output || config.generator?.output || getDefaultOutputDir(configPath)
      const resolvedOutputDir = path.resolve(configDir, outputDir)

      // Ensure output directory exists
      await fs.mkdir(resolvedOutputDir, { recursive: true })

      // Write type definition files
      const typeFiles = await this.writeTypeFiles(resolvedOutputDir, {
        databaseSchema,
        modelInterfaces,
        operationTypes,
        schemaAST,
        typeGenerator,
      })

      // Write enhanced client file with pre-compiled operations
      const clientFile = await this.writeGeneratedClientFile(resolvedOutputDir, schemaAST, config)

      spinner.succeed('Client generation completed successfully!')

      logger.success('‚úÖ Generated Refract client:')
      logger.info(`   Output directory: ${resolvedOutputDir}`)
      logger.info(`   Generated files: ${[...typeFiles, clientFile].length}`)
      typeFiles.concat(clientFile).forEach((file) => {
        logger.info(`   - ${path.relative(process.cwd(), file)}`)
      })
      logger.info('')
      logger.info('üí° Import your client:')
      logger.info(`   import { createClient } from '${path.relative(process.cwd(), resolvedOutputDir)}'`)

      return {
        success: true,
        message: 'Client generated successfully',
      }
    } catch (error) {
      spinner.fail('Client generation failed')
      const errorMessage = error instanceof Error ? error.message : String(error)
      logger.error(`Generation failed: ${errorMessage}`)

      if (process.env.DEBUG) {
        console.error(error)
      }

      return {
        success: false,
        message: `Generation failed: ${errorMessage}`,
        error: error instanceof Error ? error : new Error(String(error)),
      }
    }
  }

  /**
   * Write TypeScript type definition files
   */
  private async writeTypeFiles(
    outputDir: string,
    generation: {
      databaseSchema: string
      modelInterfaces: string
      operationTypes: string
      schemaAST: any
      typeGenerator: TypeGenerator
    },
  ): Promise<string[]> {
    const files: string[] = []

    // Write database schema types
    const schemaTypesPath = path.join(outputDir, 'schema.d.ts')
    const schemaContent = `/**
 * Generated database schema types for Kysely
 * Do not edit this file manually - regenerate with \`refract generate\`
 */

import type { Generated, Insertable, Selectable, Updateable } from 'kysely'

${generation.databaseSchema}

// Export utility types for each table
${generation.schemaAST.models
  .map((model: any) => {
    const tableName = model.name.toLowerCase()
    return `export type ${model.name}Select = Selectable<DatabaseSchema['${tableName}']>
export type ${model.name}Insert = Insertable<DatabaseSchema['${tableName}']>
export type ${model.name}Update = Updateable<DatabaseSchema['${tableName}']>`
  })
  .join('\n\n')}
`

    await fs.writeFile(schemaTypesPath, schemaContent, 'utf-8')
    files.push(schemaTypesPath)

    // Write model interfaces
    const modelsTypesPath = path.join(outputDir, 'models.d.ts')
    const modelsContent = `/**
 * Generated model interfaces
 * Do not edit this file manually - regenerate with \`refract generate\`
 */

${generation.modelInterfaces}

${generation.operationTypes}
`

    await fs.writeFile(modelsTypesPath, modelsContent, 'utf-8')
    files.push(modelsTypesPath)

    // Write enum types if any exist
    if (generation.schemaAST.enums && generation.schemaAST.enums.length > 0) {
      const enumsTypesPath = path.join(outputDir, 'enums.d.ts')
      const enumsContent = `/**
 * Generated enum types
 * Do not edit this file manually - regenerate with \`refract generate\`
 */

${generation.schemaAST.enums
  .map(
    (enumDef: any) => `export enum ${enumDef.name} {
${enumDef.values.map((value: any) => `  ${value.name} = '${value.name}'`).join(',\n')}
}`,
  )
  .join('\n\n')}
`

      await fs.writeFile(enumsTypesPath, enumsContent, 'utf-8')
      files.push(enumsTypesPath)
    }

    return files
  }

  /**
   * Write generated client file with embedded operations
   */
  private async writeGeneratedClientFile(outputDir: string, schemaAST: any, config?: any): Promise<string> {
    const clientPath = path.join(outputDir, 'index.ts')

    try {
      console.log('üîß Generating client module with embedded operations')

      // Extract datasource provider from schema AST for dialect detection
      const datasource = schemaAST.datasources?.[0]
      const refractConfig = datasource ? {
        database: {
          provider: datasource.provider?.toLowerCase(),
          url: datasource.url
        }
      } : undefined

      // Generate client module with field translations
      const clientGenerator = new ClientGenerator(schemaAST, {
        includeTypes: true,
        includeJSDoc: true,
        esModules: true,
        config: refractConfig
      })
      
      const clientContent = clientGenerator.generateClientModule()
      console.log('‚úì Client module generated, length:', clientContent.length)
      
      await fs.writeFile(clientPath, clientContent, 'utf-8')
      console.log('‚úì Client module written to:', clientPath)
      
      return clientPath
    } catch (error) {
      console.error('‚ùå Client generation failed, falling back to legacy:', error)
      
      // Fallback to legacy generation
      return this.writeClientFile(outputDir, new TypeGenerator(schemaAST), {})
    }
  }

  /**
   * Write main client file (legacy approach - kept for reference)
   */
  private async writeClientFile(outputDir: string, typeGenerator: TypeGenerator, config: any): Promise<string> {
    const clientPath = path.join(outputDir, 'index.ts')

    // Generate concrete schema for runtime use
    const concreteSchema = typeGenerator.generateConcreteSchema()
    const models = typeGenerator.getGeneratedModels()

    const clientContent = `/**
 * Generated Refract client
 * Do not edit this file manually - regenerate with \`refract generate\`
 */

import { createRefractClientFromConfig } from '@refract/client'
import type { DatabaseSchema } from './schema'
import type { ${models.map((m) => m.name).join(', ')} } from './models'
${
  config.schemaAST?.enums?.length > 0
    ? `import type { ${config.schemaAST.enums.map((e: any) => e.name).join(', ')} } from './enums'`
    : ''
}

// Re-export types for convenience
export type { DatabaseSchema } from './schema'
export type { ${models.map((m) => m.name).join(', ')} } from './models'
${
  config.schemaAST?.enums?.length > 0
    ? `export type { ${config.schemaAST.enums.map((e: any) => e.name).join(', ')} } from './enums'`
    : ''
}

// Runtime schema information
export const SCHEMA_INFO = ${JSON.stringify(concreteSchema, null, 2)} as const

// Model names for runtime introspection
export const MODEL_NAMES = ${JSON.stringify(models.map((m) => m.name))} as const

// Table names for runtime introspection  
export const TABLE_NAMES = ${JSON.stringify(
      models.reduce((acc: any, m) => {
        acc[m.name] = m.tableName
        return acc
      }, {}),
    )} as const

/**
 * Create a configured Refract client instance
 * Uses configuration from refract.config.ts or .config/refract.ts by default
 */
export async function createClient() {
  return createRefractClientFromConfig<DatabaseSchema>()
}

/**
 * Create a Refract client with explicit configuration
 */
export function createClientWithConfig(config: any) {
  return createRefractClientFromConfig<DatabaseSchema>({ config })
}

// Default export for convenience
export default createClient
`

    await fs.writeFile(clientPath, clientContent, 'utf-8')
    return clientPath
  }
}

/**
 * Register generate command
 */
export function registerGenerateCommand(program: any) {
  const generateCmd = program
    .command('generate')
    .description('Generate Refract client from schema')
    .option('-o, --output <path>', 'Output directory for generated client')
    .option('-w, --watch', 'Watch for schema changes and regenerate automatically')
    .action(async (options: GenerateOptions) => {
      const command = new GenerateCommand()

      if (options.watch) {
        logger.info('üîÑ Watch mode enabled - watching for schema changes...')

        // Import dynamic watch functionality
        const { watch } = await import('node:fs')

        // Initial generation
        await command.run(options)

        try {
          const { config, configDir } = await cliLoadRefractConfig()
          const schemaPath = findSchemaFile(config, configDir)

          // Watch schema file for changes
          watch(schemaPath, async (eventType) => {
            if (eventType === 'change') {
              logger.info('üìù Schema file changed - regenerating client...')
              await command.run(options)
            }
          })

          // Keep process alive in watch mode
          logger.info('üëÄ Watching for changes... Press Ctrl+C to stop')
          process.stdin.resume()
        } catch (error) {
          logger.error(`Failed to set up watch mode: ${error}`)
          process.exit(1)
        }
      } else {
        // Single generation
        await command.run(options)
      }
    })
}

/**
 * Standalone generation function for programmatic use
 */
export async function generateClient(options: GenerateOptions = {}): Promise<CommandResult> {
  const command = new GenerateCommand()
  return command.execute(options)
}
