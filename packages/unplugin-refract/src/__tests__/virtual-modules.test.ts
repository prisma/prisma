import { beforeEach, describe, expect, it } from 'vitest'

import { VirtualModuleManager, VirtualModuleResolver, VirtualTypeGenerator } from '../virtual-modules.js'

describe('VirtualModuleManager', () => {
  let manager: VirtualModuleManager

  beforeEach(() => {
    manager = new VirtualModuleManager(false)
  })

  it('should register and retrieve virtual modules', () => {
    manager.setModule('test', 'export const test = true')

    const module = manager.getModule('test')
    expect(module).toBeDefined()
    expect(module?.content).toBe('export const test = true')
    expect(module?.id).toBe('test')
  })

  it('should check module existence', () => {
    expect(manager.hasModule('test')).toBe(false)

    manager.setModule('test', 'content')
    expect(manager.hasModule('test')).toBe(true)
  })

  it('should update multiple modules atomically', () => {
    const updates = {
      types: 'export interface User {}',
      index: 'export * from "./types"',
    }

    manager.updateModules(updates)

    expect(manager.hasModule('types')).toBe(true)
    expect(manager.hasModule('index')).toBe(true)
    expect(manager.getModule('types')?.content).toBe(updates.types)
  })
})

describe('VirtualModuleResolver', () => {
  let resolver: VirtualModuleResolver

  beforeEach(() => {
    resolver = new VirtualModuleResolver()
  })

  it('should identify virtual modules', () => {
    expect(resolver.isVirtualModule('.refract/types')).toBe(true)
    expect(resolver.isVirtualModule('virtual:refract/types')).toBe(true)
    expect(resolver.isVirtualModule('regular-module')).toBe(false)
  })

  it('should resolve virtual IDs correctly', () => {
    expect(resolver.resolveVirtualId('.refract/types')).toBe('virtual:refract/types')
    expect(resolver.resolveVirtualId('virtual:refract/types')).toBe('virtual:refract/types')
    expect(resolver.resolveVirtualId('regular-module')).toBeNull()
  })

  it('should extract module keys', () => {
    expect(resolver.getModuleKey('virtual:refract/types')).toBe('types')
    expect(resolver.getModuleKey('virtual:refract/index')).toBe('index')
  })
})

describe('VirtualTypeGenerator', () => {
  let generator: VirtualTypeGenerator

  beforeEach(() => {
    generator = new VirtualTypeGenerator(false)
  })

  it('should generate types module', () => {
    const generatedTypes = {
      interfaces: 'export interface User { id: number }',
      schema: 'export interface DatabaseSchema { user: User }',
      augmentation: 'declare module "@refract/client" { interface RefractGeneratedSchema extends DatabaseSchema {} }',
    }

    const result = generator.generateTypesModule(generatedTypes)

    expect(result).toContain('Generated by unplugin-refract')
    expect(result).toContain(generatedTypes.interfaces)
    expect(result).toContain(generatedTypes.schema)
    expect(result).toContain(generatedTypes.augmentation)
  })

  it('should generate fallback module', () => {
    const result = generator.generateFallbackModule()

    expect(result).toContain('No schema.prisma found')
    expect(result).toContain('export interface DatabaseSchema')
    expect(result).toContain('declare module')
  })

  it('should generate error module', () => {
    const result = generator.generateErrorModule('Test error')

    expect(result).toContain('Schema parsing error')
    expect(result).toContain('Test error')
    expect(result).toContain('throw new Error')
  })
})
