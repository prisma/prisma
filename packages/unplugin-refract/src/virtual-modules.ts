/**
 * Virtual module system for unplugin-refract
 * Provides clean .refract/types imports like Next.js patterns
 */

import type { GeneratedTypes, VirtualModule, EnhancedClientCode } from './types.js'

export class VirtualModuleManager {
  private modules = new Map<string, VirtualModule>()
  private debug: boolean

  constructor(debug = false) {
    this.debug = debug
  }

  private log(message: string) {
    if (this.debug) {
      console.log(`[unplugin-refract:virtual] ${message}`)
    }
  }

  /**
   * Register a virtual module
   */
  setModule(id: string, content: string): void {
    const module: VirtualModule = {
      id,
      content,
      lastModified: Date.now(),
    }

    this.modules.set(id, module)
    this.log(`Registered virtual module: ${id} (${content.length} chars)`)
  }

  /**
   * Get a virtual module by ID
   */
  getModule(id: string): VirtualModule | undefined {
    return this.modules.get(id)
  }

  /**
   * Check if a virtual module exists
   */
  hasModule(id: string): boolean {
    return this.modules.has(id)
  }

  /**
   * Remove a virtual module
   */
  removeModule(id: string): boolean {
    const removed = this.modules.delete(id)
    if (removed) {
      this.log(`Removed virtual module: ${id}`)
    }
    return removed
  }

  /**
   * Clear all virtual modules
   */
  clear(): void {
    const count = this.modules.size
    this.modules.clear()
    this.log(`Cleared ${count} virtual modules`)
  }

  /**
   * Get all virtual module IDs
   */
  getModuleIds(): string[] {
    return Array.from(this.modules.keys())
  }

  /**
   * Update multiple modules atomically
   */
  updateModules(updates: Record<string, string>): void {
    const timestamp = Date.now()

    for (const [id, content] of Object.entries(updates)) {
      this.modules.set(id, {
        id,
        content,
        lastModified: timestamp,
      })
    }

    this.log(`Updated ${Object.keys(updates).length} virtual modules`)
  }
}

/**
 * Virtual module path resolver
 * Handles different import patterns and normalizes them
 */
export class VirtualModuleResolver {
  private readonly VIRTUAL_PREFIX = 'virtual:refract/'
  private readonly REFRACT_PREFIX = '.refract/'

  /**
   * Check if an import ID should be handled as a virtual module
   */
  isVirtualModule(id: string): boolean {
    return id.startsWith(this.REFRACT_PREFIX) || id.startsWith(this.VIRTUAL_PREFIX)
  }

  /**
   * Convert a .refract import to virtual module ID
   */
  resolveVirtualId(id: string): string | null {
    if (id.startsWith(this.REFRACT_PREFIX)) {
      // Convert .refract/types -> virtual:refract/types
      const relativePath = id.replace(this.REFRACT_PREFIX, '')
      return `${this.VIRTUAL_PREFIX}${relativePath}`
    }

    if (id.startsWith(this.VIRTUAL_PREFIX)) {
      // Already a virtual ID
      return id
    }

    return null
  }

  /**
   * Get the module key for storage (without virtual: prefix)
   */
  getModuleKey(virtualId: string): string {
    return virtualId.replace(this.VIRTUAL_PREFIX, '')
  }

  /**
   * Get all supported import patterns for a module
   */
  getImportPatterns(moduleKey: string): string[] {
    return [`${this.REFRACT_PREFIX}${moduleKey}`, `${this.VIRTUAL_PREFIX}${moduleKey}`]
  }
}

/**
 * Enhanced type generator for virtual modules
 */
export class VirtualTypeGenerator {
  private debug: boolean

  constructor(debug = false) {
    this.debug = debug
  }

  private log(message: string) {
    if (this.debug) {
      console.log(`[unplugin-refract:types] ${message}`)
    }
  }

  /**
   * Generate comprehensive types module content
   */
  generateTypesModule(generatedTypes: GeneratedTypes): string {
    this.log('Generating comprehensive types module')

    return `// Generated by unplugin-refract - do not edit manually
// This file provides clean .refract/types imports for the Refract blessed path

${generatedTypes.interfaces}

${generatedTypes.schema}

${generatedTypes.augmentation}

// Re-export core types for convenience
export type { RefractClient, RefractClientOptions } from '@refract/client'

// Export generated types
export type * from './generated'
`
  }

  /**
   * Generate index module for the .refract directory
   */
  generateIndexModule(generatedTypes: GeneratedTypes, hasEnhancedClient = false): string {
    const modelNames = this.extractModelNames(generatedTypes.interfaces)

    const baseExports = `// Generated index for .refract directory
export * from './types'
export type { DatabaseSchema } from './types'

// Model type exports
${modelNames.map((name) => `export type { ${name} } from './types'`).join('\n')}`

    if (hasEnhancedClient) {
      return `${baseExports}

// Enhanced client exports (runtime + types)
export * from './client'
export type * from './client-types'
`
    }

    return baseExports
  }

  /**
   * Generate dedicated generated types file
   */
  generateGeneratedTypesModule(generatedTypes: GeneratedTypes): string {
    return `// Generated types from schema.prisma
${generatedTypes.interfaces}
`
  }

  /**
   * Extract model names from generated interfaces
   */
  private extractModelNames(interfaces: string): string[] {
    const modelRegex = /export interface (\w+) \{/g
    const names: string[] = []
    let match

    while ((match = modelRegex.exec(interfaces)) !== null) {
      names.push(match[1])
    }

    return names
  }

  /**
   * Generate development-friendly error module
   */
  generateErrorModule(error: string): string {
    return `// Schema parsing error - fix your schema.prisma file
throw new Error(${JSON.stringify(`Refract schema error: ${error}`)})

export {}
`
  }

  /**
   * Generate empty fallback module
   */
  generateFallbackModule(): string {
    return `// No schema.prisma found - using fallback types

export interface DatabaseSchema {
  [tableName: string]: any
}

declare module '@refract/client' {
  interface RefractGeneratedSchema extends DatabaseSchema {}
}

export type { RefractClient, RefractClientOptions } from '@refract/client'
`
  }

  /**
   * Generate enhanced client module with full client code
   */
  generateEnhancedClientModule(enhancedClientCode: EnhancedClientCode): string {
    this.log(`Generating enhanced client module for ${enhancedClientCode.dialect} dialect`)

    return `// Generated Enhanced Refract Client - do not edit manually
// This file provides the complete, pre-compiled Refract client
// Database dialect: ${enhancedClientCode.dialect}

${enhancedClientCode.clientCode}
`
  }

  /**
   * Generate client types module (TypeScript declarations only)
   */
  generateClientTypesModule(enhancedClientCode: EnhancedClientCode): string {
    this.log('Generating client types module')

    return `// Generated Refract Client Types - do not edit manually
// TypeScript declarations for the enhanced client

${enhancedClientCode.declarations}

// Export types for external usage
export type { RefractClient, RefractClientOptions } from '@refract/client'
`
  }

  /**
   * Generate fallback client module when enhanced generation fails
   */
  generateFallbackClientModule(): string {
    this.log('Generating fallback client module')

    return `// Fallback Refract Client - enhanced client generation failed
// Use manual setup: import { RefractClient } from '@refract/client'

import { RefractClient } from '@refract/client'

// Re-export client class for compatibility
export { RefractClient }
export type { RefractClientOptions } from '@refract/client'

// Create a note about manual setup needed
export const __REFRACT_FALLBACK__ = true
export const __REFRACT_SETUP_REQUIRED__ = 'Enhanced client generation failed. Use manual setup with RefractClient class.'
`
  }

  /**
   * Generate fallback client types module
   */
  generateFallbackClientTypesModule(): string {
    this.log('Generating fallback client types module')

    return `// Fallback Refract Client Types
// Enhanced client generation failed - using basic types

export interface DatabaseSchema {
  [tableName: string]: any
}

export type { RefractClient, RefractClientOptions } from '@refract/client'

// Fallback indicator
export const __REFRACT_FALLBACK__ = true
`
  }
}
