/**
 * Generated Refract Client
 * 
 * Do not edit this file manually. Regenerate with `refract generate`
 * 
 * Generated at: 2025-11-05T19:00:06.171Z
 */

import { RefractClientBase } from '@refract/client'
import { createKyselyDialect, loadRefractConfig } from '@refract/config'
import { Kysely } from 'kysely'
import type { Dialect, ExpressionBuilder, SelectQueryBuilder, UpdateQueryBuilder, DeleteQueryBuilder, Expression, SqlBool, ReferenceExpression } from 'kysely'

export interface User {
  id: number
  email: string
  name?: string
  createdAt: Date
  updatedAt: Date
  posts: Post[]
  profile?: Profile
}

export interface Profile {
  id: number
  bio?: string
  userId: number
  user: User
}

export interface Post {
  id: number
  title: string
  content?: string
  published: boolean
  authorId: number
  author: User
  createdAt: Date
  updatedAt: Date
}

export interface DatabaseSchema {
  User: User
  Profile: Profile
  Post: Post
  [modelName: string]: Record<string, any>
}

/**
 * Base filter type for all field types
 */
export type BaseFilter<T> = {
  equals?: T
  in?: T[]
  notIn?: T[]
  not?: BaseFilter<T> | T
}

/**
 * Filter for numeric fields (Int, Float, BigInt)
 */
export type NumericFilter<T extends number | bigint = number> = BaseFilter<T> & {
  lt?: T
  lte?: T
  gt?: T
  gte?: T
}

/**
 * Filter for string fields
 * Generic parameter allows string | null for nullable fields
 */
export type StringFilter<T extends string | null = string> = BaseFilter<T> & {
  contains?: string
  startsWith?: string
  endsWith?: string
  // mode?: 'default' | 'insensitive' // Deferred: case-insensitive search
}

/**
 * Filter for boolean fields
 */
export type BooleanFilter = BaseFilter<boolean>

/**
 * Filter for DateTime fields
 * Accepts Date objects or ISO string representations
 */
export type DateTimeFilter<T extends Date | string | null = Date | string> = BaseFilter<T> & {
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
}

/**
 * Filter for Json fields
 */
export type JsonFilter = BaseFilter<any>

/**
 * Sort order for orderBy clauses
 */
export type SortOrder = 'asc' | 'desc'

/**
 * Filter for one-to-many relation to Post
 * Note: Runtime implementation deferred to Phase 2+
 */
export type PostListRelationFilter = {
  every?: PostWhereInput
  some?: PostWhereInput
  none?: PostWhereInput
}

/**
 * Filter for one-to-one relation to Post
 * Note: Runtime implementation deferred to Phase 2+
 */
export type PostRelationFilter = {
  is?: PostWhereInput | null
  isNot?: PostWhereInput | null
}

/**
 * Filter for one-to-many relation to Profile
 * Note: Runtime implementation deferred to Phase 2+
 */
export type ProfileListRelationFilter = {
  every?: ProfileWhereInput
  some?: ProfileWhereInput
  none?: ProfileWhereInput
}

/**
 * Filter for one-to-one relation to Profile
 * Note: Runtime implementation deferred to Phase 2+
 */
export type ProfileRelationFilter = {
  is?: ProfileWhereInput | null
  isNot?: ProfileWhereInput | null
}

/**
 * Filter for one-to-many relation to User
 * Note: Runtime implementation deferred to Phase 2+
 */
export type UserListRelationFilter = {
  every?: UserWhereInput
  some?: UserWhereInput
  none?: UserWhereInput
}

/**
 * Filter for one-to-one relation to User
 * Note: Runtime implementation deferred to Phase 2+
 */
export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}

export type UserWhereInput = {
  id?: NumericFilter<number> | number
  email?: StringFilter<string> | string
  name?: StringFilter<string | null> | string | null
  createdAt?: DateTimeFilter<Date | string> | Date
  updatedAt?: DateTimeFilter<Date | string> | Date
  posts?: PostListRelationFilter
  profile?: ProfileRelationFilter | null
  AND?: UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput[]
}

export type UserOrderByWithRelationInput = {
  id?: SortOrder
  email?: SortOrder
  name?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
}

export type UserCreateInput = {
  email: string
  name?: string | null
  createdAt?: Date
}

export type UserUpdateInput = {
  email?: string
  name?: string | null
  createdAt?: Date
}

// Args types for User
export type UserFindManyArgs = {
  where?: UserWhereInput
  orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
  take?: number
  skip?: number
  include?: UserInclude
}

export type UserFindUniqueArgs = {
  where: UserWhereInput
  include?: UserInclude
}

export type UserFindFirstArgs = {
  where?: UserWhereInput
  orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
  include?: UserInclude
}

export type UserCreateArgs = {
  data: UserCreateInput
}

export type UserCreateManyArgs = {
  data: UserCreateInput[]
}

export type UserUpdateArgs = {
  where: UserWhereInput
  data: UserUpdateInput
}

export type UserUpdateManyArgs = {
  where?: UserWhereInput
  data: UserUpdateInput
}

export type UserUpsertArgs = {
  where: UserWhereInput
  create: UserCreateInput
  update: UserUpdateInput
}

export type UserDeleteArgs = {
  where: UserWhereInput
}

export type UserDeleteManyArgs = {
  where?: UserWhereInput
}

export type UserCountArgs = {
  where?: UserWhereInput
}

export type ProfileWhereInput = {
  id?: NumericFilter<number> | number
  bio?: StringFilter<string | null> | string | null
  userId?: NumericFilter<number> | number
  user?: UserRelationFilter | null
  AND?: ProfileWhereInput[]
  OR?: ProfileWhereInput[]
  NOT?: ProfileWhereInput[]
}

export type ProfileOrderByWithRelationInput = {
  id?: SortOrder
  bio?: SortOrder
  userId?: SortOrder
}

export type ProfileCreateInput = {
  bio?: string | null
  userId: number
}

export type ProfileUpdateInput = {
  bio?: string | null
  userId?: number
}

// Args types for Profile
export type ProfileFindManyArgs = {
  where?: ProfileWhereInput
  orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
  take?: number
  skip?: number
  include?: ProfileInclude
}

export type ProfileFindUniqueArgs = {
  where: ProfileWhereInput
  include?: ProfileInclude
}

export type ProfileFindFirstArgs = {
  where?: ProfileWhereInput
  orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
  include?: ProfileInclude
}

export type ProfileCreateArgs = {
  data: ProfileCreateInput
}

export type ProfileCreateManyArgs = {
  data: ProfileCreateInput[]
}

export type ProfileUpdateArgs = {
  where: ProfileWhereInput
  data: ProfileUpdateInput
}

export type ProfileUpdateManyArgs = {
  where?: ProfileWhereInput
  data: ProfileUpdateInput
}

export type ProfileUpsertArgs = {
  where: ProfileWhereInput
  create: ProfileCreateInput
  update: ProfileUpdateInput
}

export type ProfileDeleteArgs = {
  where: ProfileWhereInput
}

export type ProfileDeleteManyArgs = {
  where?: ProfileWhereInput
}

export type ProfileCountArgs = {
  where?: ProfileWhereInput
}

export type PostWhereInput = {
  id?: NumericFilter<number> | number
  title?: StringFilter<string> | string
  content?: StringFilter<string | null> | string | null
  published?: BooleanFilter | boolean
  authorId?: NumericFilter<number> | number
  createdAt?: DateTimeFilter<Date | string> | Date
  updatedAt?: DateTimeFilter<Date | string> | Date
  author?: UserRelationFilter | null
  AND?: PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput[]
}

export type PostOrderByWithRelationInput = {
  id?: SortOrder
  title?: SortOrder
  content?: SortOrder
  published?: SortOrder
  authorId?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
}

export type PostCreateInput = {
  title: string
  content?: string | null
  published?: boolean
  authorId: number
  createdAt?: Date
}

export type PostUpdateInput = {
  title?: string
  content?: string | null
  published?: boolean
  authorId?: number
  createdAt?: Date
}

// Args types for Post
export type PostFindManyArgs = {
  where?: PostWhereInput
  orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
  take?: number
  skip?: number
  include?: PostInclude
}

export type PostFindUniqueArgs = {
  where: PostWhereInput
  include?: PostInclude
}

export type PostFindFirstArgs = {
  where?: PostWhereInput
  orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
  include?: PostInclude
}

export type PostCreateArgs = {
  data: PostCreateInput
}

export type PostCreateManyArgs = {
  data: PostCreateInput[]
}

export type PostUpdateArgs = {
  where: PostWhereInput
  data: PostUpdateInput
}

export type PostUpdateManyArgs = {
  where?: PostWhereInput
  data: PostUpdateInput
}

export type PostUpsertArgs = {
  where: PostWhereInput
  create: PostCreateInput
  update: PostUpdateInput
}

export type PostDeleteArgs = {
  where: PostWhereInput
}

export type PostDeleteManyArgs = {
  where?: PostWhereInput
}

export type PostCountArgs = {
  where?: PostWhereInput
}

export interface UserInclude {
  posts?: boolean
  profile?: boolean
}

export interface ProfileInclude {
  user?: boolean
}

export interface PostInclude {
  author?: boolean
}

export interface ModelCRUDOperations<T, TInclude = any> {
  findMany(args?: { where?: Partial<T>; orderBy?: any; take?: number; skip?: number; include?: TInclude }): Promise<T[]>
  findUnique(args: { where: Partial<T>; include?: TInclude }): Promise<T | undefined>
  findFirst(args?: { where?: Partial<T>; orderBy?: any; include?: TInclude }): Promise<T | null>
  create(args: { data: any }): Promise<T>
  createMany(args: { data: any[] }): Promise<{ count: number }>
  update(args: { where: Partial<T>; data: any }): Promise<T>
  updateMany(args: { where?: Partial<T>; data: any }): Promise<{ count: number }>
  upsert(args: { where: Partial<T>; create: any; update: any }): Promise<T>
  delete(args: { where: Partial<T> }): Promise<T>
  deleteMany(args?: { where?: Partial<T> }): Promise<{ count: number }>
  count(args?: { where?: Partial<T> }): Promise<number>
}

/**
 * Generated operations for User model
 */
class UserOperations {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  async findMany(args?: UserFindManyArgs): Promise<User[]> {
    let query = this.kysely.selectFrom('User')

    // Apply includes (joins) if specified
    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations(results, includesApplied.relations)
      return results.map(row => this.transformSelectResultWithIncludes(row, includesApplied.relations, relatedData))
    }

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique(args: UserFindUniqueArgs): Promise<User | undefined> {
    let query = this.kysely.selectFrom('User')

    const includesApplied = args.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const results = await query.execute()

    if (results.length === 0) return undefined

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async findFirst(args?: UserFindFirstArgs): Promise<User | null> {
    let query = this.kysely.selectFrom('User')

    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async create(args: UserCreateArgs): Promise<User> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('User')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: UserCreateManyArgs): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('User')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: UserUpdateArgs): Promise<User> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('User').set(prepared as any)
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: UserUpdateManyArgs): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('User').set(prepared as any)
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: UserUpsertArgs): Promise<User> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('User')
      .values(createData as any)
      .onConflict(oc => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: UserDeleteArgs): Promise<User> {
    let query = this.kysely.deleteFrom('User')
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: UserDeleteManyArgs): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('User')
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: UserCountArgs): Promise<number> {
    let query = this.kysely
      .selectFrom('User')
      .select(eb => eb.fn.count('id').as('count'))
      
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private buildWhereExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'User'>,
    where: UserWhereInput
  ) {
    const expressions: Expression<SqlBool>[] = []

    for (const [field, value] of Object.entries(where)) {
      if (field === 'AND') {
        expressions.push(eb.and((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'OR') {
        expressions.push(eb.or((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'NOT') {
        // `eb.not` doesn't accept a list, so need to negate each condition instead.
        for (const cond of value as UserWhereInput[]) {
          expressions.push(eb.not(this.buildWhereExpression(eb, cond)))
        }
      } else {
        // Regular field condition
        expressions.push(this.buildFieldExpression(eb, field, value))
      }
    }
    
    return eb.and(expressions)
  }

  private buildFieldExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'User'>,
    field: string,
    value: unknown
  ) {
    const qualifiedField = `User.${field}` as ReferenceExpression<DatabaseSchema, 'User'>

    if (value === null) {
      return eb(qualifiedField, 'is', null)
    }

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      const conditions: Expression<SqlBool>[] = []

      for (const [operator, operatorValue] of Object.entries(value)) {
        switch (operator) {
          case 'equals':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is', null))
            } else {
              conditions.push(eb(qualifiedField, '=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'gt':
            conditions.push(eb(qualifiedField, '>', this.transformWhereValue(field, operatorValue)))
            break
          case 'gte':
            conditions.push(eb(qualifiedField, '>=', this.transformWhereValue(field, operatorValue)))
            break
          case 'lt':
            conditions.push(eb(qualifiedField, '<', this.transformWhereValue(field, operatorValue)))
            break
          case 'lte':
            conditions.push(eb(qualifiedField, '<=', this.transformWhereValue(field, operatorValue)))
            break
          case 'not':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is not', null))
            } else {
              conditions.push(eb(qualifiedField, '!=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'in':
            conditions.push(
              eb(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'notIn':
            conditions.push(
              eb(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'contains':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}%`))
            break
          case 'startsWith':
            conditions.push(eb(qualifiedField, 'like', `${operatorValue}%`))
            break
          case 'endsWith':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}`))
            break
        }
      }

      return eb.and(conditions)
    }

    return eb(qualifiedField, '=', this.transformWhereValue(field, value))
  }

  private transformWhereValue(fieldName: keyof UserWhereInput, value: unknown): unknown {
    if (fieldName === 'id') {
      return Number(value)
    }
    
    if (fieldName === 'email') {
      return String(value)
    }
    
    if (fieldName === 'name') {
      return value !== null ? String(value) : null
    }
    
    if (fieldName === 'createdAt') {
      return new Date(value)
    }
    
    if (fieldName === 'updatedAt') {
      return new Date(value)
    }
    
    return value // No transformation needed for this field
  }

  private prepareCreateData(data: UserCreateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.email !== undefined) {
      prepared.email = String(data.email)
    }
    
    if (data.name !== undefined) {
      prepared.name = data.name !== null ? String(data.name) : null
    }
    
    prepared.createdAt = data.createdAt ? new Date(data.createdAt) : new Date().toISOString()
    prepared.updatedAt = new Date().toISOString()
    
    return prepared
  }

  private prepareUpdateData(data: UserUpdateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.email !== undefined) {
      prepared.email = String(data.email)
    }
    
    if (data.name !== undefined) {
      prepared.name = data.name !== null ? String(data.name) : null
    }
    
    prepared.updatedAt = new Date().toISOString()
    
    return prepared
  }

  private transformSelectResult(row: any): User {
    const result: any = {}

    result.id = row.id
    
    result.email = row.email
    
    result.name = row.name
    
    result.createdAt = row.createdAt
    
    result.updatedAt = row.updatedAt

    return result
  }

  private applyIncludes(query: any, include: UserInclude): { query: any; relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> } | null {
    if (!include || Object.keys(include).length === 0) return null

    const relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> = []
    let currentQuery = query

    if (include.posts) {
      relations.push({ field: 'posts', relatedModel: 'Post', prefix: 'posts_', type: 'many' })
    }
    
    if (include.profile) {
      currentQuery = currentQuery
        .leftJoin('Profile', 'User.id', 'Profile.userId')
        .selectAll('User')
        .select([
          'Profile.id as profile_id', 'Profile.bio as profile_bio', 'Profile.userId as profile_userId'
        ])
      relations.push({ field: 'profile', relatedModel: 'Profile', prefix: 'profile_', type: 'one' })
    }

    return { query: currentQuery, relations }
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // Fetch posts relation
    const postsRelation = manyRelations.find(r => r.field === 'posts')
    if (postsRelation) {
      const parentIds = results.map(r => r.id)
      const postsResults = await this.kysely
        .selectFrom('Post')
        .selectAll()
        .where('authorId', 'in', parentIds)
        .execute()
    
      relatedData['posts'] = postsResults.map((row: any) => ({
        id: Number(row.id),
        title: String(row.title),
        content: String(row.content),
        published: row.published,
        authorId: Number(row.authorId),
        createdAt: new Date(row.createdAt),
        updatedAt: new Date(row.updatedAt)
      }))
    }

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): User {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    const postsRelation = relations.find(r => r.field === 'posts' && r.type === 'many')
    if (postsRelation && relatedData['posts']) {
      result.posts = relatedData['posts'].filter((r: any) => r['authorId'] === result.id) || []
    }
    
    const profileRelation = relations.find(r => r.field === 'profile' && r.type === 'one')
    if (profileRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${profileRelation.prefix}id`] !== null
      result.profile = hasData ? {
      id: Number(row.profile_id),
      bio: String(row.profile_bio),
      userId: Number(row.profile_userId)
      } : null
    }

    return result
  }
}

/**
 * Generated operations for Profile model
 */
class ProfileOperations {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  async findMany(args?: ProfileFindManyArgs): Promise<Profile[]> {
    let query = this.kysely.selectFrom('Profile')

    // Apply includes (joins) if specified
    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations(results, includesApplied.relations)
      return results.map(row => this.transformSelectResultWithIncludes(row, includesApplied.relations, relatedData))
    }

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique(args: ProfileFindUniqueArgs): Promise<Profile | undefined> {
    let query = this.kysely.selectFrom('Profile')

    const includesApplied = args.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const results = await query.execute()

    if (results.length === 0) return undefined

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async findFirst(args?: ProfileFindFirstArgs): Promise<Profile | null> {
    let query = this.kysely.selectFrom('Profile')

    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async create(args: ProfileCreateArgs): Promise<Profile> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('Profile')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: ProfileCreateManyArgs): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('Profile')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: ProfileUpdateArgs): Promise<Profile> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Profile').set(prepared as any)
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: ProfileUpdateManyArgs): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Profile').set(prepared as any)
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: ProfileUpsertArgs): Promise<Profile> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('Profile')
      .values(createData as any)
      .onConflict(oc => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: ProfileDeleteArgs): Promise<Profile> {
    let query = this.kysely.deleteFrom('Profile')
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: ProfileDeleteManyArgs): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('Profile')
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: ProfileCountArgs): Promise<number> {
    let query = this.kysely
      .selectFrom('Profile')
      .select(eb => eb.fn.count('id').as('count'))
      
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private buildWhereExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'Profile'>,
    where: ProfileWhereInput
  ) {
    const expressions: Expression<SqlBool>[] = []

    for (const [field, value] of Object.entries(where)) {
      if (field === 'AND') {
        expressions.push(eb.and((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'OR') {
        expressions.push(eb.or((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'NOT') {
        // `eb.not` doesn't accept a list, so need to negate each condition instead.
        for (const cond of value as UserWhereInput[]) {
          expressions.push(eb.not(this.buildWhereExpression(eb, cond)))
        }
      } else {
        // Regular field condition
        expressions.push(this.buildFieldExpression(eb, field, value))
      }
    }
    
    return eb.and(expressions)
  }

  private buildFieldExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'Profile'>,
    field: string,
    value: unknown
  ) {
    const qualifiedField = `Profile.${field}` as ReferenceExpression<DatabaseSchema, 'Profile'>

    if (value === null) {
      return eb(qualifiedField, 'is', null)
    }

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      const conditions: Expression<SqlBool>[] = []

      for (const [operator, operatorValue] of Object.entries(value)) {
        switch (operator) {
          case 'equals':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is', null))
            } else {
              conditions.push(eb(qualifiedField, '=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'gt':
            conditions.push(eb(qualifiedField, '>', this.transformWhereValue(field, operatorValue)))
            break
          case 'gte':
            conditions.push(eb(qualifiedField, '>=', this.transformWhereValue(field, operatorValue)))
            break
          case 'lt':
            conditions.push(eb(qualifiedField, '<', this.transformWhereValue(field, operatorValue)))
            break
          case 'lte':
            conditions.push(eb(qualifiedField, '<=', this.transformWhereValue(field, operatorValue)))
            break
          case 'not':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is not', null))
            } else {
              conditions.push(eb(qualifiedField, '!=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'in':
            conditions.push(
              eb(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'notIn':
            conditions.push(
              eb(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'contains':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}%`))
            break
          case 'startsWith':
            conditions.push(eb(qualifiedField, 'like', `${operatorValue}%`))
            break
          case 'endsWith':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}`))
            break
        }
      }

      return eb.and(conditions)
    }

    return eb(qualifiedField, '=', this.transformWhereValue(field, value))
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
    if (fieldName === 'id') {
      return Number(value)
    }
    
    if (fieldName === 'bio') {
      return value !== null ? String(value) : null
    }
    
    if (fieldName === 'userId') {
      return Number(value)
    }
    
    return value // No transformation needed for this field
  }

  private prepareCreateData(data: ProfileCreateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.bio !== undefined) {
      prepared.bio = data.bio !== null ? String(data.bio) : null
    }
    
    if (data.userId !== undefined) {
      prepared.userId = Number(data.userId)
    }
    
    
    
    return prepared
  }

  private prepareUpdateData(data: ProfileUpdateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.bio !== undefined) {
      prepared.bio = data.bio !== null ? String(data.bio) : null
    }
    
    if (data.userId !== undefined) {
      prepared.userId = Number(data.userId)
    }
    
    
    
    return prepared
  }

  private transformSelectResult(row: any): Profile {
    const result: any = {}

    result.id = row.id
    
    result.bio = row.bio
    
    result.userId = row.userId

    return result
  }

  private applyIncludes(query: any, include: ProfileInclude): { query: any; relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> } | null {
    if (!include || Object.keys(include).length === 0) return null

    const relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> = []
    let currentQuery = query

    if (include.user) {
      currentQuery = currentQuery
        .leftJoin('User', 'Profile.userId', 'User.id')
        .selectAll('Profile')
        .select([
          'User.id as user_id', 'User.email as user_email', 'User.name as user_name', 'User.createdAt as user_createdAt', 'User.updatedAt as user_updatedAt'
        ])
      relations.push({ field: 'user', relatedModel: 'User', prefix: 'user_', type: 'one' })
    }

    return { query: currentQuery, relations }
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // No one-to-many relations

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): Profile {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    const userRelation = relations.find(r => r.field === 'user' && r.type === 'one')
    if (userRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${userRelation.prefix}id`] !== null
      result.user = hasData ? {
      id: Number(row.user_id),
      email: String(row.user_email),
      name: String(row.user_name),
      createdAt: new Date(row.user_createdAt),
      updatedAt: new Date(row.user_updatedAt)
      } : null
    }

    return result
  }
}

/**
 * Generated operations for Post model
 */
class PostOperations {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  async findMany(args?: PostFindManyArgs): Promise<Post[]> {
    let query = this.kysely.selectFrom('Post')

    // Apply includes (joins) if specified
    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations(results, includesApplied.relations)
      return results.map(row => this.transformSelectResultWithIncludes(row, includesApplied.relations, relatedData))
    }

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique(args: PostFindUniqueArgs): Promise<Post | undefined> {
    let query = this.kysely.selectFrom('Post')

    const includesApplied = args.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const results = await query.execute()

    if (results.length === 0) return undefined

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async findFirst(args?: PostFindFirstArgs): Promise<Post | null> {
    let query = this.kysely.selectFrom('Post')

    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async create(args: PostCreateArgs): Promise<Post> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('Post')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: PostCreateManyArgs): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('Post')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: PostUpdateArgs): Promise<Post> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Post').set(prepared as any)
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: PostUpdateManyArgs): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Post').set(prepared as any)
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: PostUpsertArgs): Promise<Post> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('Post')
      .values(createData as any)
      .onConflict(oc => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: PostDeleteArgs): Promise<Post> {
    let query = this.kysely.deleteFrom('Post')
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: PostDeleteManyArgs): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('Post')
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: PostCountArgs): Promise<number> {
    let query = this.kysely
      .selectFrom('Post')
      .select(eb => eb.fn.count('id').as('count'))
      
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private buildWhereExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'Post'>,
    where: PostWhereInput
  ) {
    const expressions: Expression<SqlBool>[] = []

    for (const [field, value] of Object.entries(where)) {
      if (field === 'AND') {
        expressions.push(eb.and((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'OR') {
        expressions.push(eb.or((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'NOT') {
        // `eb.not` doesn't accept a list, so need to negate each condition instead.
        for (const cond of value as UserWhereInput[]) {
          expressions.push(eb.not(this.buildWhereExpression(eb, cond)))
        }
      } else {
        // Regular field condition
        expressions.push(this.buildFieldExpression(eb, field, value))
      }
    }
    
    return eb.and(expressions)
  }

  private buildFieldExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'Post'>,
    field: string,
    value: unknown
  ) {
    const qualifiedField = `Post.${field}` as ReferenceExpression<DatabaseSchema, 'Post'>

    if (value === null) {
      return eb(qualifiedField, 'is', null)
    }

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      const conditions: Expression<SqlBool>[] = []

      for (const [operator, operatorValue] of Object.entries(value)) {
        switch (operator) {
          case 'equals':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is', null))
            } else {
              conditions.push(eb(qualifiedField, '=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'gt':
            conditions.push(eb(qualifiedField, '>', this.transformWhereValue(field, operatorValue)))
            break
          case 'gte':
            conditions.push(eb(qualifiedField, '>=', this.transformWhereValue(field, operatorValue)))
            break
          case 'lt':
            conditions.push(eb(qualifiedField, '<', this.transformWhereValue(field, operatorValue)))
            break
          case 'lte':
            conditions.push(eb(qualifiedField, '<=', this.transformWhereValue(field, operatorValue)))
            break
          case 'not':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is not', null))
            } else {
              conditions.push(eb(qualifiedField, '!=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'in':
            conditions.push(
              eb(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'notIn':
            conditions.push(
              eb(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'contains':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}%`))
            break
          case 'startsWith':
            conditions.push(eb(qualifiedField, 'like', `${operatorValue}%`))
            break
          case 'endsWith':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}`))
            break
        }
      }

      return eb.and(conditions)
    }

    return eb(qualifiedField, '=', this.transformWhereValue(field, value))
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
    if (fieldName === 'id') {
      return Number(value)
    }
    
    if (fieldName === 'title') {
      return String(value)
    }
    
    if (fieldName === 'content') {
      return value !== null ? String(value) : null
    }
    
    if (fieldName === 'published') {
      return value
    }
    
    if (fieldName === 'authorId') {
      return Number(value)
    }
    
    if (fieldName === 'createdAt') {
      return new Date(value)
    }
    
    if (fieldName === 'updatedAt') {
      return new Date(value)
    }
    
    return value // No transformation needed for this field
  }

  private prepareCreateData(data: PostCreateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.title !== undefined) {
      prepared.title = String(data.title)
    }
    
    if (data.content !== undefined) {
      prepared.content = data.content !== null ? String(data.content) : null
    }
    
    if (data.published !== undefined) {
      prepared.published = data.published
    }
    
    if (data.authorId !== undefined) {
      prepared.authorId = Number(data.authorId)
    }
    
    prepared.createdAt = data.createdAt ? new Date(data.createdAt) : new Date().toISOString()
    prepared.updatedAt = new Date().toISOString()
    
    return prepared
  }

  private prepareUpdateData(data: PostUpdateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.title !== undefined) {
      prepared.title = String(data.title)
    }
    
    if (data.content !== undefined) {
      prepared.content = data.content !== null ? String(data.content) : null
    }
    
    if (data.published !== undefined) {
      prepared.published = data.published
    }
    
    if (data.authorId !== undefined) {
      prepared.authorId = Number(data.authorId)
    }
    
    prepared.updatedAt = new Date().toISOString()
    
    return prepared
  }

  private transformSelectResult(row: any): Post {
    const result: any = {}

    result.id = row.id
    
    result.title = row.title
    
    result.content = row.content
    
    result.published = row.published
    
    result.authorId = row.authorId
    
    result.createdAt = row.createdAt
    
    result.updatedAt = row.updatedAt

    return result
  }

  private applyIncludes(query: any, include: PostInclude): { query: any; relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> } | null {
    if (!include || Object.keys(include).length === 0) return null

    const relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> = []
    let currentQuery = query

    if (include.author) {
      currentQuery = currentQuery
        .leftJoin('User', 'Post.authorId', 'User.id')
        .selectAll('Post')
        .select([
          'User.id as author_id', 'User.email as author_email', 'User.name as author_name', 'User.createdAt as author_createdAt', 'User.updatedAt as author_updatedAt'
        ])
      relations.push({ field: 'author', relatedModel: 'User', prefix: 'author_', type: 'one' })
    }

    return { query: currentQuery, relations }
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // No one-to-many relations

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): Post {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    const authorRelation = relations.find(r => r.field === 'author' && r.type === 'one')
    if (authorRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${authorRelation.prefix}id`] !== null
      result.author = hasData ? {
      id: Number(row.author_id),
      email: String(row.author_email),
      name: String(row.author_name),
      createdAt: new Date(row.author_createdAt),
      updatedAt: new Date(row.author_updatedAt)
      } : null
    }

    return result
  }
}

const createModelOperations = (kysely: Kysely<DatabaseSchema>) => ({
  user: new UserOperations(kysely),
  profile: new ProfileOperations(kysely),
  post: new PostOperations(kysely)
})

/**
 * Refract Client with pre-compiled operations
 * Database dialect: postgresql
 * No runtime schema parsing - all model operations are embedded at generation time
 */
export class RefractClient extends RefractClientBase<DatabaseSchema> {
  declare readonly user: UserOperations
  declare readonly profile: ProfileOperations
  declare readonly post: PostOperations
  constructor(dialect: Dialect) {
    super(dialect, { modelFactory: createModelOperations })
  }
}

/**
 * Factory function for creating RefractClient instances
 */
export function createRefractClient(dialect: Dialect): RefractClient {
  return new RefractClient(dialect)
}

/**
 * Convenience factory function that automatically loads configuration
 * This is the main entry point used by the generated client
 */
export async function createClient(): Promise<RefractClient> {
  const { config } = await loadRefractConfig()
  const dialect = await createKyselyDialect(config)
  return new RefractClient(dialect)
}