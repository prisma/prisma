/**
 * Generated Refract Client Module
 * 
 * Database dialect: postgresql
 * Generated transformations with zero runtime overhead
 * 
 * Do not edit this file manually - regenerate with `refract generate`
 * Generated at: 2025-10-17T17:00:14.561Z
 */

import { RefractClientBase } from '@refract/client'
import { createKyselyDialect, loadRefractConfig } from '@refract/config'
import { Kysely } from 'kysely'
import type { Dialect } from 'kysely'
import type { User, Profile, Post } from './models'

// Model types imported from models.d.ts

export interface DatabaseSchema {
  User: User
  Profile: Profile
  Post: Post
  [modelName: string]: Record<string, any>
}

// CRUD Operation Interfaces
export interface UserInclude {
  posts?: boolean
  profile?: boolean
}

export interface ProfileInclude {
  user?: boolean
}

export interface PostInclude {
  author?: boolean
}

export interface ModelCRUDOperations<T, TInclude = any> {
  findMany(args?: { where?: Partial<T>; orderBy?: any; take?: number; skip?: number; include?: TInclude }): Promise<T[]>
  findUnique(args: { where: Partial<T>; include?: TInclude }): Promise<T | undefined>
  findFirst(args?: { where?: Partial<T>; orderBy?: any; include?: TInclude }): Promise<T | null>
  create(args: { data: any }): Promise<T>
  createMany(args: { data: any[] }): Promise<{ count: number }>
  update(args: { where: Partial<T>; data: any }): Promise<T>
  updateMany(args: { where?: Partial<T>; data: any }): Promise<{ count: number }>
  upsert(args: { where: Partial<T>; create: any; update: any }): Promise<T>
  delete(args: { where: Partial<T> }): Promise<T>
  deleteMany(args?: { where?: Partial<T> }): Promise<{ count: number }>
  count(args?: { where?: Partial<T> }): Promise<number>
}

/**
 * Generated operations for User model
 * All field transformations are embedded at generation time for postgresql
 */
class UserOperations implements ModelCRUDOperations<User, UserInclude> {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  async findMany(args?: { where?: Partial<User>; orderBy?: any; take?: number; skip?: number; include?: UserInclude }): Promise<User[]> {
    let query = this.kysely.selectFrom('User')

    // Apply includes (joins) if specified
    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }

    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations(results, includesApplied.relations)
      return results.map(row => this.transformSelectResultWithIncludes(row, includesApplied.relations, relatedData))
    }

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique(args: { where: Partial<User>; include?: UserInclude }): Promise<User | undefined> {
    let query = this.kysely.selectFrom('User')

    const includesApplied = args.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = this.applyWhereConditions(query, args.where)
    const results = await query.execute()

    if (results.length === 0) return undefined

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async findFirst(args?: { where?: Partial<User>; orderBy?: any; include?: UserInclude }): Promise<User | null> {
    let query = this.kysely.selectFrom('User')

    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }

    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async create(args: { data: any }): Promise<User> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('User')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: { data: any[] }): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('User')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: { where: Partial<User>; data: any }): Promise<User> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('User').set(prepared as any)
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: { where?: Partial<User>; data: any }): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('User').set(prepared as any)
    
    if (args.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: { where: Partial<User>; create: any; update: any }): Promise<User> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('User')
      .values(createData as any)
      .onConflict(oc => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: { where: Partial<User> }): Promise<User> {
    let query = this.kysely.deleteFrom('User')
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: { where?: Partial<User> }): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('User')
    
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: { where?: Partial<User> }): Promise<number> {
    let query = this.kysely
      .selectFrom('User')
      .select(eb => eb.fn.count('id').as('count'))
      
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private applyWhereConditions(query: any, where: Record<string, unknown>): any {
    let currentQuery = query

    for (const [field, value] of Object.entries(where)) {
      const qualifiedField = 'User.' + field
      if (value === null) {
        currentQuery = currentQuery.where(qualifiedField, 'is', null)
      } else if (typeof value === 'object' && value !== null) {
        // Handle complex where conditions
        for (const [operator, operatorValue] of Object.entries(value)) {
          switch (operator) {
            case 'gt':
              currentQuery = currentQuery.where(qualifiedField, '>', this.transformWhereValue(field, operatorValue))
              break
            case 'gte':
              currentQuery = currentQuery.where(qualifiedField, '>=', this.transformWhereValue(field, operatorValue))
              break
            case 'lt':
              currentQuery = currentQuery.where(qualifiedField, '<', this.transformWhereValue(field, operatorValue))
              break
            case 'lte':
              currentQuery = currentQuery.where(qualifiedField, '<=', this.transformWhereValue(field, operatorValue))
              break
            case 'not':
              currentQuery = currentQuery.where(qualifiedField, '!=', this.transformWhereValue(field, operatorValue))
              break
            case 'in':
              currentQuery = currentQuery.where(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'notIn':
              currentQuery = currentQuery.where(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'contains':
              currentQuery = currentQuery.where(qualifiedField, 'like', `%${operatorValue}%`)
              break
            case 'startsWith':
              currentQuery = currentQuery.where(qualifiedField, 'like', `${operatorValue}%`)
              break
            case 'endsWith':
              currentQuery = currentQuery.where(qualifiedField, 'like', `%${operatorValue}`)
              break
          }
        }
      } else {
        currentQuery = currentQuery.where(qualifiedField, '=', this.transformWhereValue(field, value))
      }
    }

    return currentQuery
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
        if (fieldName === 'id') {
      return Number(value)
    }
    
    if (fieldName === 'email') {
      return String(value)
    }
    
    if (fieldName === 'name') {
      return value !== null ? String(value) : null
    }
    
    if (fieldName === 'createdAt') {
      return value instanceof Date ? value : new Date(value)
    }
    
    if (fieldName === 'updatedAt') {
      return value instanceof Date ? value : new Date(value)
    }
    
    return value // No transformation needed for this field
  }

  private prepareCreateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
        if (data.id !== undefined) {
      prepared.id = Number(data.id)
    }
    
    if (data.email !== undefined) {
      prepared.email = String(data.email)
    }
    
    if (data.name !== undefined) {
      prepared.name = data.name !== null ? String(data.name) : null
    }
    
    if (data.createdAt !== undefined) {
      prepared.createdAt = data.createdAt instanceof Date ? data.createdAt : new Date(data.createdAt)
    }
    
    if (data.updatedAt !== undefined) {
      prepared.updatedAt = data.updatedAt instanceof Date ? data.updatedAt : new Date(data.updatedAt)
    }
    
    // Auto-generated createdAt timestamp
    prepared.createdAt = new Date().toISOString()
    // Auto-generated updatedAt timestamp
    prepared.updatedAt = new Date().toISOString()

    
    return prepared
  }

  private prepareUpdateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
        if (data.email !== undefined) {
      prepared.email = String(data.email)
    }
    
    if (data.name !== undefined) {
      prepared.name = data.name !== null ? String(data.name) : null
    }
    
    if (data.updatedAt !== undefined) {
      prepared.updatedAt = data.updatedAt instanceof Date ? data.updatedAt : new Date(data.updatedAt)
    }
    
    // Auto-generated updatedAt timestamp
    prepared.updatedAt = new Date().toISOString()

    
    return prepared
  }

  private transformSelectResult(row: any): User {
    const result: any = {}

        result.id = row.id
    
    result.email = row.email
    
    result.name = row.name
    
    result.createdAt = row.createdAt
    
    result.updatedAt = row.updatedAt

    return result
  }

  private applyIncludes(query: any, include: UserInclude): { query: any; relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> } | null {
    if (!include || Object.keys(include).length === 0) return null

    const relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> = []
    let currentQuery = query

        if (include.posts) {
      relations.push({ field: 'posts', relatedModel: 'Post', prefix: 'posts_', type: 'many' })
    }

    if (include.profile) {
      currentQuery = currentQuery
        .leftJoin('Profile', 'User.id', 'Profile.userId')
        .selectAll('User')
        .select([
          'Profile.id as profile_id', 'Profile.bio as profile_bio', 'Profile.userId as profile_userId'
        ])
      relations.push({ field: 'profile', relatedModel: 'Profile', prefix: 'profile_', type: 'one' })
    }

    return { query: currentQuery, relations }
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

        // Fetch posts relation
    const postsRelation = manyRelations.find(r => r.field === 'posts')
    if (postsRelation) {
      const parentIds = results.map(r => r.id)
      const postsResults = await this.kysely
        .selectFrom('Post')
        .selectAll()
        .where('authorId', 'in', parentIds)
        .execute()

      relatedData['posts'] = postsResults.map((row: any) => ({
      id: Number(row.id),
      title: String(row.title),
      content: String(row.content),
      published: row.published,
      authorId: Number(row.authorId),
      createdAt: new Date(row.createdAt as any),
      updatedAt: new Date(row.updatedAt as any)
      }))
    }

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): User {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
        const postsRelation = relations.find(r => r.field === 'posts' && r.type === 'many')
    if (postsRelation && relatedData['posts']) {
      result.posts = relatedData['posts'].filter((r: any) => r['authorId'] === result.id) || []
    }

    const profileRelation = relations.find(r => r.field === 'profile' && r.type === 'one')
    if (profileRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${profileRelation.prefix}id`] !== null
      result.profile = hasData ? {
      id: Number(row.profile_id),
      bio: String(row.profile_bio),
      userId: Number(row.profile_userId)
      } : null
    }

    return result
  }
}

/**
 * Generated operations for Profile model
 * All field transformations are embedded at generation time for postgresql
 */
class ProfileOperations implements ModelCRUDOperations<Profile, ProfileInclude> {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  async findMany(args?: { where?: Partial<Profile>; orderBy?: any; take?: number; skip?: number; include?: ProfileInclude }): Promise<Profile[]> {
    let query = this.kysely.selectFrom('Profile')

    // Apply includes (joins) if specified
    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }

    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations(results, includesApplied.relations)
      return results.map(row => this.transformSelectResultWithIncludes(row, includesApplied.relations, relatedData))
    }

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique(args: { where: Partial<Profile>; include?: ProfileInclude }): Promise<Profile | undefined> {
    let query = this.kysely.selectFrom('Profile')

    const includesApplied = args.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = this.applyWhereConditions(query, args.where)
    const results = await query.execute()

    if (results.length === 0) return undefined

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async findFirst(args?: { where?: Partial<Profile>; orderBy?: any; include?: ProfileInclude }): Promise<Profile | null> {
    let query = this.kysely.selectFrom('Profile')

    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }

    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async create(args: { data: any }): Promise<Profile> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('Profile')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: { data: any[] }): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('Profile')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: { where: Partial<Profile>; data: any }): Promise<Profile> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Profile').set(prepared as any)
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: { where?: Partial<Profile>; data: any }): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Profile').set(prepared as any)
    
    if (args.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: { where: Partial<Profile>; create: any; update: any }): Promise<Profile> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('Profile')
      .values(createData as any)
      .onConflict(oc => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: { where: Partial<Profile> }): Promise<Profile> {
    let query = this.kysely.deleteFrom('Profile')
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: { where?: Partial<Profile> }): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('Profile')
    
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: { where?: Partial<Profile> }): Promise<number> {
    let query = this.kysely
      .selectFrom('Profile')
      .select(eb => eb.fn.count('id').as('count'))
      
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private applyWhereConditions(query: any, where: Record<string, unknown>): any {
    let currentQuery = query

    for (const [field, value] of Object.entries(where)) {
      const qualifiedField = 'Profile.' + field
      if (value === null) {
        currentQuery = currentQuery.where(qualifiedField, 'is', null)
      } else if (typeof value === 'object' && value !== null) {
        // Handle complex where conditions
        for (const [operator, operatorValue] of Object.entries(value)) {
          switch (operator) {
            case 'gt':
              currentQuery = currentQuery.where(qualifiedField, '>', this.transformWhereValue(field, operatorValue))
              break
            case 'gte':
              currentQuery = currentQuery.where(qualifiedField, '>=', this.transformWhereValue(field, operatorValue))
              break
            case 'lt':
              currentQuery = currentQuery.where(qualifiedField, '<', this.transformWhereValue(field, operatorValue))
              break
            case 'lte':
              currentQuery = currentQuery.where(qualifiedField, '<=', this.transformWhereValue(field, operatorValue))
              break
            case 'not':
              currentQuery = currentQuery.where(qualifiedField, '!=', this.transformWhereValue(field, operatorValue))
              break
            case 'in':
              currentQuery = currentQuery.where(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'notIn':
              currentQuery = currentQuery.where(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'contains':
              currentQuery = currentQuery.where(qualifiedField, 'like', `%${operatorValue}%`)
              break
            case 'startsWith':
              currentQuery = currentQuery.where(qualifiedField, 'like', `${operatorValue}%`)
              break
            case 'endsWith':
              currentQuery = currentQuery.where(qualifiedField, 'like', `%${operatorValue}`)
              break
          }
        }
      } else {
        currentQuery = currentQuery.where(qualifiedField, '=', this.transformWhereValue(field, value))
      }
    }

    return currentQuery
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
        if (fieldName === 'id') {
      return Number(value)
    }
    
    if (fieldName === 'bio') {
      return value !== null ? String(value) : null
    }
    
    if (fieldName === 'userId') {
      return Number(value)
    }
    
    return value // No transformation needed for this field
  }

  private prepareCreateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
        if (data.id !== undefined) {
      prepared.id = Number(data.id)
    }
    
    if (data.bio !== undefined) {
      prepared.bio = data.bio !== null ? String(data.bio) : null
    }
    
    if (data.userId !== undefined) {
      prepared.userId = Number(data.userId)
    }
    

    
    return prepared
  }

  private prepareUpdateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
        if (data.bio !== undefined) {
      prepared.bio = data.bio !== null ? String(data.bio) : null
    }
    
    if (data.userId !== undefined) {
      prepared.userId = Number(data.userId)
    }
    

    
    return prepared
  }

  private transformSelectResult(row: any): Profile {
    const result: any = {}

        result.id = row.id
    
    result.bio = row.bio
    
    result.userId = row.userId

    return result
  }

  private applyIncludes(query: any, include: ProfileInclude): { query: any; relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> } | null {
    if (!include || Object.keys(include).length === 0) return null

    const relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> = []
    let currentQuery = query

        if (include.user) {
      currentQuery = currentQuery
        .leftJoin('User', 'Profile.userId', 'User.id')
        .selectAll('Profile')
        .select([
          'User.id as user_id', 'User.email as user_email', 'User.name as user_name', 'User.createdAt as user_createdAt', 'User.updatedAt as user_updatedAt'
        ])
      relations.push({ field: 'user', relatedModel: 'User', prefix: 'user_', type: 'one' })
    }

    return { query: currentQuery, relations }
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // No one-to-many relations

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): Profile {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
        const userRelation = relations.find(r => r.field === 'user' && r.type === 'one')
    if (userRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${userRelation.prefix}id`] !== null
      result.user = hasData ? {
      id: Number(row.user_id),
      email: String(row.user_email),
      name: String(row.user_name),
      createdAt: new Date(row.user_createdAt as any),
      updatedAt: new Date(row.user_updatedAt as any)
      } : null
    }

    return result
  }
}

/**
 * Generated operations for Post model
 * All field transformations are embedded at generation time for postgresql
 */
class PostOperations implements ModelCRUDOperations<Post, PostInclude> {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  async findMany(args?: { where?: Partial<Post>; orderBy?: any; take?: number; skip?: number; include?: PostInclude }): Promise<Post[]> {
    let query = this.kysely.selectFrom('Post')

    // Apply includes (joins) if specified
    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }

    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations(results, includesApplied.relations)
      return results.map(row => this.transformSelectResultWithIncludes(row, includesApplied.relations, relatedData))
    }

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique(args: { where: Partial<Post>; include?: PostInclude }): Promise<Post | undefined> {
    let query = this.kysely.selectFrom('Post')

    const includesApplied = args.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    query = this.applyWhereConditions(query, args.where)
    const results = await query.execute()

    if (results.length === 0) return undefined

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async findFirst(args?: { where?: Partial<Post>; orderBy?: any; include?: PostInclude }): Promise<Post | null> {
    let query = this.kysely.selectFrom('Post')

    const includesApplied = args?.include ? this.applyIncludes(query, args.include) : null
    if (includesApplied) {
      query = includesApplied.query
    } else {
      query = query.selectAll()
    }

    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }

    if (args?.orderBy) {
      Object.entries(args.orderBy).forEach(([field, direction]) => {
        query = query.orderBy(field as any, direction as 'asc' | 'desc')
      })
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    // Fetch one-to-many relations if needed
    if (includesApplied) {
      const relatedData = await this.fetchManyRelations([results[0]], includesApplied.relations)
      return this.transformSelectResultWithIncludes(results[0], includesApplied.relations, relatedData)
    }

    return this.transformSelectResult(results[0])
  }

  async create(args: { data: any }): Promise<Post> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('Post')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: { data: any[] }): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('Post')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: { where: Partial<Post>; data: any }): Promise<Post> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Post').set(prepared as any)
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: { where?: Partial<Post>; data: any }): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Post').set(prepared as any)
    
    if (args.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: { where: Partial<Post>; create: any; update: any }): Promise<Post> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('Post')
      .values(createData as any)
      .onConflict(oc => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: { where: Partial<Post> }): Promise<Post> {
    let query = this.kysely.deleteFrom('Post')
    query = this.applyWhereConditions(query, args.where)
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: { where?: Partial<Post> }): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('Post')
    
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: { where?: Partial<Post> }): Promise<number> {
    let query = this.kysely
      .selectFrom('Post')
      .select(eb => eb.fn.count('id').as('count'))
      
    if (args?.where) {
      query = this.applyWhereConditions(query, args.where)
    }
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private applyWhereConditions(query: any, where: Record<string, unknown>): any {
    let currentQuery = query

    for (const [field, value] of Object.entries(where)) {
      const qualifiedField = 'Post.' + field
      if (value === null) {
        currentQuery = currentQuery.where(qualifiedField, 'is', null)
      } else if (typeof value === 'object' && value !== null) {
        // Handle complex where conditions
        for (const [operator, operatorValue] of Object.entries(value)) {
          switch (operator) {
            case 'gt':
              currentQuery = currentQuery.where(qualifiedField, '>', this.transformWhereValue(field, operatorValue))
              break
            case 'gte':
              currentQuery = currentQuery.where(qualifiedField, '>=', this.transformWhereValue(field, operatorValue))
              break
            case 'lt':
              currentQuery = currentQuery.where(qualifiedField, '<', this.transformWhereValue(field, operatorValue))
              break
            case 'lte':
              currentQuery = currentQuery.where(qualifiedField, '<=', this.transformWhereValue(field, operatorValue))
              break
            case 'not':
              currentQuery = currentQuery.where(qualifiedField, '!=', this.transformWhereValue(field, operatorValue))
              break
            case 'in':
              currentQuery = currentQuery.where(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'notIn':
              currentQuery = currentQuery.where(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
              break
            case 'contains':
              currentQuery = currentQuery.where(qualifiedField, 'like', `%${operatorValue}%`)
              break
            case 'startsWith':
              currentQuery = currentQuery.where(qualifiedField, 'like', `${operatorValue}%`)
              break
            case 'endsWith':
              currentQuery = currentQuery.where(qualifiedField, 'like', `%${operatorValue}`)
              break
          }
        }
      } else {
        currentQuery = currentQuery.where(qualifiedField, '=', this.transformWhereValue(field, value))
      }
    }

    return currentQuery
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
        if (fieldName === 'id') {
      return Number(value)
    }
    
    if (fieldName === 'title') {
      return String(value)
    }
    
    if (fieldName === 'content') {
      return value !== null ? String(value) : null
    }
    
    if (fieldName === 'published') {
      return value
    }
    
    if (fieldName === 'authorId') {
      return Number(value)
    }
    
    if (fieldName === 'createdAt') {
      return value instanceof Date ? value : new Date(value)
    }
    
    if (fieldName === 'updatedAt') {
      return value instanceof Date ? value : new Date(value)
    }
    
    return value // No transformation needed for this field
  }

  private prepareCreateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
        if (data.id !== undefined) {
      prepared.id = Number(data.id)
    }
    
    if (data.title !== undefined) {
      prepared.title = String(data.title)
    }
    
    if (data.content !== undefined) {
      prepared.content = data.content !== null ? String(data.content) : null
    }
    
    if (data.published !== undefined) {
      prepared.published = data.published
    }
    
    if (data.authorId !== undefined) {
      prepared.authorId = Number(data.authorId)
    }
    
    if (data.createdAt !== undefined) {
      prepared.createdAt = data.createdAt instanceof Date ? data.createdAt : new Date(data.createdAt)
    }
    
    if (data.updatedAt !== undefined) {
      prepared.updatedAt = data.updatedAt instanceof Date ? data.updatedAt : new Date(data.updatedAt)
    }
    
    // Auto-generated createdAt timestamp
    prepared.createdAt = new Date().toISOString()
    // Auto-generated updatedAt timestamp
    prepared.updatedAt = new Date().toISOString()

    
    return prepared
  }

  private prepareUpdateData(data: Record<string, unknown>): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
        if (data.title !== undefined) {
      prepared.title = String(data.title)
    }
    
    if (data.content !== undefined) {
      prepared.content = data.content !== null ? String(data.content) : null
    }
    
    if (data.published !== undefined) {
      prepared.published = data.published
    }
    
    if (data.authorId !== undefined) {
      prepared.authorId = Number(data.authorId)
    }
    
    if (data.updatedAt !== undefined) {
      prepared.updatedAt = data.updatedAt instanceof Date ? data.updatedAt : new Date(data.updatedAt)
    }
    
    // Auto-generated updatedAt timestamp
    prepared.updatedAt = new Date().toISOString()

    
    return prepared
  }

  private transformSelectResult(row: any): Post {
    const result: any = {}

        result.id = row.id
    
    result.title = row.title
    
    result.content = row.content
    
    result.published = row.published
    
    result.authorId = row.authorId
    
    result.createdAt = row.createdAt
    
    result.updatedAt = row.updatedAt

    return result
  }

  private applyIncludes(query: any, include: PostInclude): { query: any; relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> } | null {
    if (!include || Object.keys(include).length === 0) return null

    const relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }> = []
    let currentQuery = query

        if (include.author) {
      currentQuery = currentQuery
        .leftJoin('User', 'Post.authorId', 'User.id')
        .selectAll('Post')
        .select([
          'User.id as author_id', 'User.email as author_email', 'User.name as author_name', 'User.createdAt as author_createdAt', 'User.updatedAt as author_updatedAt'
        ])
      relations.push({ field: 'author', relatedModel: 'User', prefix: 'author_', type: 'one' })
    }

    return { query: currentQuery, relations }
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // No one-to-many relations

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): Post {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
        const authorRelation = relations.find(r => r.field === 'author' && r.type === 'one')
    if (authorRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${authorRelation.prefix}id`] !== null
      result.author = hasData ? {
      id: Number(row.author_id),
      email: String(row.author_email),
      name: String(row.author_name),
      createdAt: new Date(row.author_createdAt as any),
      updatedAt: new Date(row.author_updatedAt as any)
      } : null
    }

    return result
  }
}

const createModelOperations = (kysely: Kysely<DatabaseSchema>) => ({
  user: new UserOperations(kysely),
  profile: new ProfileOperations(kysely),
  post: new PostOperations(kysely)
})

/**
 * Refract Client with pre-compiled operations
 * Database dialect: postgresql
 * No runtime schema parsing - all model operations are embedded at generation time
 */
export class RefractClient extends RefractClientBase<DatabaseSchema> {
  declare readonly user: UserOperations
  declare readonly profile: ProfileOperations
  declare readonly post: PostOperations
  constructor(dialect: Dialect) {
    super(dialect, { modelFactory: createModelOperations })
  }
}

/**
 * Factory function for creating RefractClient instances
 */
export function createRefractClient(dialect: Dialect): RefractClient {
  return new RefractClient(dialect)
}

/**
 * Convenience factory function that automatically loads configuration
 * This is the main entry point used by the generated client
 */
export async function createClient(): Promise<RefractClient> {
  const { config } = await loadRefractConfig()
  const dialect = await createKyselyDialect(config)
  return new RefractClient(dialect)
}