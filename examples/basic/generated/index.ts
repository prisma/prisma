/**
 * Generated Refract Client
 * 
 * Do not edit this file manually. Regenerate with `refract generate`
 * 
 * Generated at: 2025-12-23T02:33:01.882Z
 */

import { RefractClientBase } from '@refract/client'
import { createKyselyDialect, loadRefractConfig } from '@refract/config'
import { Kysely } from 'kysely'
import type { Dialect, ExpressionBuilder, SelectQueryBuilder, UpdateQueryBuilder, DeleteQueryBuilder, Expression, SqlBool, ReferenceExpression } from 'kysely'

import { jsonArrayFrom, jsonObjectFrom } from 'kysely/helpers/postgres'

/**
 * Prettify<T> - Flattens intersection types for cleaner IDE tooltips
 * @see https://www.totaltypescript.com/concepts/the-prettify-helper
 */
export type Prettify<T> = { [K in keyof T]: T[K] } & {}

/**
 * User scalar fields (no relations)
 */
export type UserScalars = {
  id: number
email: string
name?: string
createdAt: Date
updatedAt: Date
}

/**
 * User relation payloads when included
 */
export type UserRelations = {
  posts: Post[]
profile: Profile | null
}

/**
 * Get the return type for User based on include options
 * @example
 * type WithPosts = UserGetPayload<{ include: { posts: true } }>
 */
export type UserGetPayload<T extends { include?: UserInclude } | undefined | null = undefined> = Prettify<
  UserScalars & (
    T extends { include: infer I extends UserInclude }
      ? { [K in keyof I as I[K] extends true ? K : never]: K extends keyof UserRelations ? UserRelations[K] : never }
      : {}
  )
>

/**
 * Full User type with optional relations
 * For precise typing based on include, use UserGetPayload<T>
 */
export interface User extends UserScalars {
  posts?: Post[]
profile?: Profile
}

/**
 * Profile scalar fields (no relations)
 */
export type ProfileScalars = {
  id: number
bio?: string
userId: number
}

/**
 * Profile relation payloads when included
 */
export type ProfileRelations = {
  user: User | null
}

/**
 * Get the return type for Profile based on include options
 * @example
 * type WithPosts = ProfileGetPayload<{ include: { posts: true } }>
 */
export type ProfileGetPayload<T extends { include?: ProfileInclude } | undefined | null = undefined> = Prettify<
  ProfileScalars & (
    T extends { include: infer I extends ProfileInclude }
      ? { [K in keyof I as I[K] extends true ? K : never]: K extends keyof ProfileRelations ? ProfileRelations[K] : never }
      : {}
  )
>

/**
 * Full Profile type with optional relations
 * For precise typing based on include, use ProfileGetPayload<T>
 */
export interface Profile extends ProfileScalars {
  user?: User
}

/**
 * Post scalar fields (no relations)
 */
export type PostScalars = {
  id: number
title: string
content?: string
published: boolean
authorId: number
createdAt: Date
updatedAt: Date
}

/**
 * Post relation payloads when included
 */
export type PostRelations = {
  author: User | null
}

/**
 * Get the return type for Post based on include options
 * @example
 * type WithPosts = PostGetPayload<{ include: { posts: true } }>
 */
export type PostGetPayload<T extends { include?: PostInclude } | undefined | null = undefined> = Prettify<
  PostScalars & (
    T extends { include: infer I extends PostInclude }
      ? { [K in keyof I as I[K] extends true ? K : never]: K extends keyof PostRelations ? PostRelations[K] : never }
      : {}
  )
>

/**
 * Full Post type with optional relations
 * For precise typing based on include, use PostGetPayload<T>
 */
export interface Post extends PostScalars {
  author?: User
}
export interface DatabaseSchema {
  User: User
  Profile: Profile
  Post: Post
  [modelName: string]: Record<string, any>
}

/**
 * Base filter type for all field types
 */
export type BaseFilter<T> = {
  equals?: T
  in?: T[]
  notIn?: T[]
  not?: BaseFilter<T> | T
}

/**
 * Filter for numeric fields (Int, Float, BigInt)
 */
export type NumericFilter<T extends number | bigint = number> = BaseFilter<T> & {
  lt?: T
  lte?: T
  gt?: T
  gte?: T
}

/**
 * Filter for string fields
 * Generic parameter allows string | null for nullable fields
 */
export type StringFilter<T extends string | null = string> = BaseFilter<T> & {
  contains?: string
  startsWith?: string
  endsWith?: string
  // mode?: 'default' | 'insensitive' // Deferred: case-insensitive search
}

/**
 * Filter for boolean fields
 */
export type BooleanFilter = BaseFilter<boolean>

/**
 * Filter for DateTime fields
 * Accepts Date objects or ISO string representations
 */
export type DateTimeFilter<T extends Date | string | null = Date | string> = BaseFilter<T> & {
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
}

/**
 * Filter for Json fields
 */
export type JsonFilter = BaseFilter<any>

/**
 * Sort order for orderBy clauses
 */
export type SortOrder = 'asc' | 'desc'

/**
 * Filter for one-to-many relation to Post
 * Note: Runtime implementation deferred to Phase 2+
 */
export type PostListRelationFilter = {
  every?: PostWhereInput
  some?: PostWhereInput
  none?: PostWhereInput
}

/**
 * Filter for one-to-one relation to Post
 * Note: Runtime implementation deferred to Phase 2+
 */
export type PostRelationFilter = {
  is?: PostWhereInput | null
  isNot?: PostWhereInput | null
}

/**
 * Filter for one-to-many relation to Profile
 * Note: Runtime implementation deferred to Phase 2+
 */
export type ProfileListRelationFilter = {
  every?: ProfileWhereInput
  some?: ProfileWhereInput
  none?: ProfileWhereInput
}

/**
 * Filter for one-to-one relation to Profile
 * Note: Runtime implementation deferred to Phase 2+
 */
export type ProfileRelationFilter = {
  is?: ProfileWhereInput | null
  isNot?: ProfileWhereInput | null
}

/**
 * Filter for one-to-many relation to User
 * Note: Runtime implementation deferred to Phase 2+
 */
export type UserListRelationFilter = {
  every?: UserWhereInput
  some?: UserWhereInput
  none?: UserWhereInput
}

/**
 * Filter for one-to-one relation to User
 * Note: Runtime implementation deferred to Phase 2+
 */
export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}

export type UserWhereInput = {
  id?: NumericFilter<number> | number
  email?: StringFilter<string> | string
  name?: StringFilter<string | null> | string | null
  createdAt?: DateTimeFilter<Date | string> | Date
  updatedAt?: DateTimeFilter<Date | string> | Date
  posts?: PostListRelationFilter
  profile?: ProfileRelationFilter | null
  AND?: UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput[]
}

export type UserOrderByWithRelationInput = {
  id?: SortOrder
  email?: SortOrder
  name?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
}

export type UserCreateInput = {
  email: string
  name?: string | null
  createdAt?: Date
}

export type UserUpdateInput = {
  email?: string
  name?: string | null
  createdAt?: Date
}

// Args types for User
export type UserFindManyArgs = {
  where?: UserWhereInput
  orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
  take?: number
  skip?: number
  include?: UserInclude
}

export type UserFindUniqueArgs = {
  where: UserWhereInput
  include?: UserInclude
}

export type UserFindFirstArgs = {
  where?: UserWhereInput
  orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
  include?: UserInclude
}

export type UserCreateArgs = {
  data: UserCreateInput
}

export type UserCreateManyArgs = {
  data: UserCreateInput[]
}

export type UserUpdateArgs = {
  where: UserWhereInput
  data: UserUpdateInput
}

export type UserUpdateManyArgs = {
  where?: UserWhereInput
  data: UserUpdateInput
}

export type UserUpsertArgs = {
  where: UserWhereInput
  create: UserCreateInput
  update: UserUpdateInput
}

export type UserDeleteArgs = {
  where: UserWhereInput
}

export type UserDeleteManyArgs = {
  where?: UserWhereInput
}

export type UserCountArgs = {
  where?: UserWhereInput
}

export type ProfileWhereInput = {
  id?: NumericFilter<number> | number
  bio?: StringFilter<string | null> | string | null
  userId?: NumericFilter<number> | number
  user?: UserRelationFilter | null
  AND?: ProfileWhereInput[]
  OR?: ProfileWhereInput[]
  NOT?: ProfileWhereInput[]
}

export type ProfileOrderByWithRelationInput = {
  id?: SortOrder
  bio?: SortOrder
  userId?: SortOrder
}

export type ProfileCreateInput = {
  bio?: string | null
  userId: number
}

export type ProfileUpdateInput = {
  bio?: string | null
  userId?: number
}

// Args types for Profile
export type ProfileFindManyArgs = {
  where?: ProfileWhereInput
  orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
  take?: number
  skip?: number
  include?: ProfileInclude
}

export type ProfileFindUniqueArgs = {
  where: ProfileWhereInput
  include?: ProfileInclude
}

export type ProfileFindFirstArgs = {
  where?: ProfileWhereInput
  orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
  include?: ProfileInclude
}

export type ProfileCreateArgs = {
  data: ProfileCreateInput
}

export type ProfileCreateManyArgs = {
  data: ProfileCreateInput[]
}

export type ProfileUpdateArgs = {
  where: ProfileWhereInput
  data: ProfileUpdateInput
}

export type ProfileUpdateManyArgs = {
  where?: ProfileWhereInput
  data: ProfileUpdateInput
}

export type ProfileUpsertArgs = {
  where: ProfileWhereInput
  create: ProfileCreateInput
  update: ProfileUpdateInput
}

export type ProfileDeleteArgs = {
  where: ProfileWhereInput
}

export type ProfileDeleteManyArgs = {
  where?: ProfileWhereInput
}

export type ProfileCountArgs = {
  where?: ProfileWhereInput
}

export type PostWhereInput = {
  id?: NumericFilter<number> | number
  title?: StringFilter<string> | string
  content?: StringFilter<string | null> | string | null
  published?: BooleanFilter | boolean
  authorId?: NumericFilter<number> | number
  createdAt?: DateTimeFilter<Date | string> | Date
  updatedAt?: DateTimeFilter<Date | string> | Date
  author?: UserRelationFilter | null
  AND?: PostWhereInput[]
  OR?: PostWhereInput[]
  NOT?: PostWhereInput[]
}

export type PostOrderByWithRelationInput = {
  id?: SortOrder
  title?: SortOrder
  content?: SortOrder
  published?: SortOrder
  authorId?: SortOrder
  createdAt?: SortOrder
  updatedAt?: SortOrder
}

export type PostCreateInput = {
  title: string
  content?: string | null
  published?: boolean
  authorId: number
  createdAt?: Date
}

export type PostUpdateInput = {
  title?: string
  content?: string | null
  published?: boolean
  authorId?: number
  createdAt?: Date
}

// Args types for Post
export type PostFindManyArgs = {
  where?: PostWhereInput
  orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
  take?: number
  skip?: number
  include?: PostInclude
}

export type PostFindUniqueArgs = {
  where: PostWhereInput
  include?: PostInclude
}

export type PostFindFirstArgs = {
  where?: PostWhereInput
  orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
  include?: PostInclude
}

export type PostCreateArgs = {
  data: PostCreateInput
}

export type PostCreateManyArgs = {
  data: PostCreateInput[]
}

export type PostUpdateArgs = {
  where: PostWhereInput
  data: PostUpdateInput
}

export type PostUpdateManyArgs = {
  where?: PostWhereInput
  data: PostUpdateInput
}

export type PostUpsertArgs = {
  where: PostWhereInput
  create: PostCreateInput
  update: PostUpdateInput
}

export type PostDeleteArgs = {
  where: PostWhereInput
}

export type PostDeleteManyArgs = {
  where?: PostWhereInput
}

export type PostCountArgs = {
  where?: PostWhereInput
}

export interface UserInclude {
  posts?: boolean
  profile?: boolean
}

export interface ProfileInclude {
  user?: boolean
}

export interface PostInclude {
  author?: boolean
}

export interface ModelCRUDOperations<T, TInclude = any> {
  findMany(args?: { where?: Partial<T>; orderBy?: any; take?: number; skip?: number; include?: TInclude }): Promise<T[]>
  findUnique(args: { where: Partial<T>; include?: TInclude }): Promise<T | null>
  findFirst(args?: { where?: Partial<T>; orderBy?: any; include?: TInclude }): Promise<T | null>
  create(args: { data: any }): Promise<T>
  createMany(args: { data: any[] }): Promise<{ count: number }>
  update(args: { where: Partial<T>; data: any }): Promise<T>
  updateMany(args: { where?: Partial<T>; data: any }): Promise<{ count: number }>
  upsert(args: { where: Partial<T>; create: any; update: any }): Promise<T>
  delete(args: { where: Partial<T> }): Promise<T>
  deleteMany(args?: { where?: Partial<T> }): Promise<{ count: number }>
  count(args?: { where?: Partial<T> }): Promise<number>
}

/**
 * Generated operations for User model
 */
class UserOperations {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  private _posts(id: Expression<number>) {
    return jsonArrayFrom(
      this.kysely.selectFrom('Post')
        .selectAll()
        .whereRef('Post.authorId', '=', id)
        .orderBy('Post.id'))
  }
  
  private _profile(id: Expression<number>) {
    return jsonObjectFrom(
      this.kysely.selectFrom('Profile')
        .selectAll()
        .whereRef('Profile.userId', '=', id)
    )
  }

  async findMany<T extends UserFindManyArgs = {}>(args?: T): Promise<UserGetPayload<T>[]> {
    let query = this.kysely
      .selectFrom('User')
      .selectAll()
      .$if(!!args?.include?.posts, (qb) => qb.select(
        (eb) => this._posts(eb.ref('User.id')).as('posts')
      ))
      .$if(!!args?.include?.profile, (qb) => qb.select(
        (eb) => this._profile(eb.ref('User.id')).as('profile')
      ))

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique<T extends UserFindUniqueArgs>(args: T): Promise<UserGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('User')
      .selectAll()
      .$if(!!args?.include?.posts, (qb) => qb.select(
        (eb) => this._posts(eb.ref('User.id')).as('posts')
      ))
      .$if(!!args?.include?.profile, (qb) => qb.select(
        (eb) => this._profile(eb.ref('User.id')).as('profile')
      ))

    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const results = await query.execute()

    if (results.length === 0) return null

    return results[0]
  }

  async findFirst<T extends UserFindFirstArgs = {}>(args?: T): Promise<UserGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('User')
      .selectAll()
      .$if(!!args?.include?.posts, (qb) => qb.select(
        (eb) => this._posts(eb.ref('User.id')).as('posts')
      ))
      .$if(!!args?.include?.profile, (qb) => qb.select(
        (eb) => this._profile(eb.ref('User.id')).as('profile')
      ))

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    return results[0]
  }

  async create(args: UserCreateArgs): Promise<User> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('User')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: UserCreateManyArgs): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('User')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: UserUpdateArgs): Promise<User> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('User').set(prepared as any)
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: UserUpdateManyArgs): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('User').set(prepared as any)
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: UserUpsertArgs): Promise<User> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('User')
      .values(createData as any)
      .onConflict(oc => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: UserDeleteArgs): Promise<User> {
    let query = this.kysely.deleteFrom('User')
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: UserDeleteManyArgs): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('User')
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: UserCountArgs): Promise<number> {
    let query = this.kysely
      .selectFrom('User')
      .select(eb => eb.fn.count('id').as('count'))
      
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private buildWhereExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'User'>,
    where: UserWhereInput
  ) {
    const expressions: Expression<SqlBool>[] = []

    for (const [field, value] of Object.entries(where)) {
      if (field === 'AND') {
        expressions.push(eb.and((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'OR') {
        expressions.push(eb.or((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'NOT') {
        // `eb.not` doesn't accept a list, so need to negate each condition instead.
        for (const cond of value as UserWhereInput[]) {
          expressions.push(eb.not(this.buildWhereExpression(eb, cond)))
        }
      } else {
        // Regular field condition
        expressions.push(this.buildFieldExpression(eb, field, value))
      }
    }
    
    return eb.and(expressions)
  }

  private buildFieldExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'User'>,
    field: string,
    value: unknown
  ) {
    const qualifiedField = `User.${field}` as ReferenceExpression<DatabaseSchema, 'User'>

    if (value === null) {
      return eb(qualifiedField, 'is', null)
    }

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      const conditions: Expression<SqlBool>[] = []

      for (const [operator, operatorValue] of Object.entries(value)) {
        switch (operator) {
          case 'equals':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is', null))
            } else {
              conditions.push(eb(qualifiedField, '=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'gt':
            conditions.push(eb(qualifiedField, '>', this.transformWhereValue(field, operatorValue)))
            break
          case 'gte':
            conditions.push(eb(qualifiedField, '>=', this.transformWhereValue(field, operatorValue)))
            break
          case 'lt':
            conditions.push(eb(qualifiedField, '<', this.transformWhereValue(field, operatorValue)))
            break
          case 'lte':
            conditions.push(eb(qualifiedField, '<=', this.transformWhereValue(field, operatorValue)))
            break
          case 'not':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is not', null))
            } else {
              conditions.push(eb(qualifiedField, '!=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'in':
            conditions.push(
              eb(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'notIn':
            conditions.push(
              eb(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'contains':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}%`))
            break
          case 'startsWith':
            conditions.push(eb(qualifiedField, 'like', `${operatorValue}%`))
            break
          case 'endsWith':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}`))
            break
        }
      }

      return eb.and(conditions)
    }

    return eb(qualifiedField, '=', this.transformWhereValue(field, value))
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
    if (fieldName === 'id') {
      return Number(value)
    }
    
    if (fieldName === 'email') {
      return String(value)
    }
    
    if (fieldName === 'name') {
      return value !== null ? String(value) : null
    }
    
    if (fieldName === 'createdAt') {
      return new Date(value as string | number | Date)
    }
    
    if (fieldName === 'updatedAt') {
      return new Date(value as string | number | Date)
    }
    
    return value // No transformation needed for this field
  }

  private prepareCreateData(data: UserCreateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.email !== undefined) {
      prepared.email = String(data.email)
    }
    
    if (data.name !== undefined) {
      prepared.name = data.name !== null ? String(data.name) : null
    }
    
    prepared.createdAt = data.createdAt ? new Date(data.createdAt) : new Date().toISOString()
    prepared.updatedAt = new Date().toISOString()
    
    return prepared
  }

  private prepareUpdateData(data: UserUpdateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.email !== undefined) {
      prepared.email = String(data.email)
    }
    
    if (data.name !== undefined) {
      prepared.name = data.name !== null ? String(data.name) : null
    }
    
    prepared.updatedAt = new Date().toISOString()
    
    return prepared
  }

  private transformSelectResult(row: any): User {
    const result: any = {}

    result.id = row.id
    
    result.email = row.email
    
    result.name = row.name
    
    result.createdAt = row.createdAt
    
    result.updatedAt = row.updatedAt

    return result
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // Fetch posts relation
    const postsRelation = manyRelations.find(r => r.field === 'posts')
    if (postsRelation) {
      const parentIds = results.map(r => r.id)
      const postsResults = await this.kysely
        .selectFrom('Post')
        .selectAll()
        .where('authorId', 'in', parentIds)
        .execute()
    
      relatedData['posts'] = postsResults.map((row: any) => ({
        id: Number(row.id),
        title: String(row.title),
        content: String(row.content),
        published: row.published,
        authorId: Number(row.authorId),
        createdAt: new Date(row.createdAt as string | number | Date),
        updatedAt: new Date(row.updatedAt as string | number | Date)
      }))
    }

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): User {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    const postsRelation = relations.find(r => r.field === 'posts' && r.type === 'many')
    if (postsRelation && relatedData['posts']) {
      result.posts = relatedData['posts'].filter((r: any) => r['authorId'] === result.id) || []
    }
    
    const profileRelation = relations.find(r => r.field === 'profile' && r.type === 'one')
    if (profileRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${profileRelation.prefix}id`] !== null
      result.profile = hasData ? {
      id: Number(row.profile_id),
      bio: String(row.profile_bio),
      userId: Number(row.profile_userId)
      } : null
    }

    return result
  }
}

/**
 * Generated operations for Profile model
 */
class ProfileOperations {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  private _user(userId: Expression<number>) {
    return jsonObjectFrom(
      this.kysely.selectFrom('User')
        .selectAll()
        .whereRef('User.id', '=', userId)
    )
  }

  async findMany<T extends ProfileFindManyArgs = {}>(args?: T): Promise<ProfileGetPayload<T>[]> {
    let query = this.kysely
      .selectFrom('Profile')
      .selectAll()
      .$if(!!args?.include?.user, (qb) => qb.select(
        (eb) => this._user(eb.ref('Profile.userId')).as('user')
      ))

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique<T extends ProfileFindUniqueArgs>(args: T): Promise<ProfileGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('Profile')
      .selectAll()
      .$if(!!args?.include?.user, (qb) => qb.select(
        (eb) => this._user(eb.ref('Profile.userId')).as('user')
      ))

    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const results = await query.execute()

    if (results.length === 0) return null

    return results[0]
  }

  async findFirst<T extends ProfileFindFirstArgs = {}>(args?: T): Promise<ProfileGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('Profile')
      .selectAll()
      .$if(!!args?.include?.user, (qb) => qb.select(
        (eb) => this._user(eb.ref('Profile.userId')).as('user')
      ))

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    return results[0]
  }

  async create(args: ProfileCreateArgs): Promise<Profile> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('Profile')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: ProfileCreateManyArgs): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('Profile')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: ProfileUpdateArgs): Promise<Profile> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Profile').set(prepared as any)
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: ProfileUpdateManyArgs): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Profile').set(prepared as any)
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: ProfileUpsertArgs): Promise<Profile> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('Profile')
      .values(createData as any)
      .onConflict(oc => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: ProfileDeleteArgs): Promise<Profile> {
    let query = this.kysely.deleteFrom('Profile')
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: ProfileDeleteManyArgs): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('Profile')
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: ProfileCountArgs): Promise<number> {
    let query = this.kysely
      .selectFrom('Profile')
      .select(eb => eb.fn.count('id').as('count'))
      
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private buildWhereExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'Profile'>,
    where: ProfileWhereInput
  ) {
    const expressions: Expression<SqlBool>[] = []

    for (const [field, value] of Object.entries(where)) {
      if (field === 'AND') {
        expressions.push(eb.and((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'OR') {
        expressions.push(eb.or((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'NOT') {
        // `eb.not` doesn't accept a list, so need to negate each condition instead.
        for (const cond of value as UserWhereInput[]) {
          expressions.push(eb.not(this.buildWhereExpression(eb, cond)))
        }
      } else {
        // Regular field condition
        expressions.push(this.buildFieldExpression(eb, field, value))
      }
    }
    
    return eb.and(expressions)
  }

  private buildFieldExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'Profile'>,
    field: string,
    value: unknown
  ) {
    const qualifiedField = `Profile.${field}` as ReferenceExpression<DatabaseSchema, 'Profile'>

    if (value === null) {
      return eb(qualifiedField, 'is', null)
    }

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      const conditions: Expression<SqlBool>[] = []

      for (const [operator, operatorValue] of Object.entries(value)) {
        switch (operator) {
          case 'equals':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is', null))
            } else {
              conditions.push(eb(qualifiedField, '=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'gt':
            conditions.push(eb(qualifiedField, '>', this.transformWhereValue(field, operatorValue)))
            break
          case 'gte':
            conditions.push(eb(qualifiedField, '>=', this.transformWhereValue(field, operatorValue)))
            break
          case 'lt':
            conditions.push(eb(qualifiedField, '<', this.transformWhereValue(field, operatorValue)))
            break
          case 'lte':
            conditions.push(eb(qualifiedField, '<=', this.transformWhereValue(field, operatorValue)))
            break
          case 'not':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is not', null))
            } else {
              conditions.push(eb(qualifiedField, '!=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'in':
            conditions.push(
              eb(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'notIn':
            conditions.push(
              eb(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'contains':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}%`))
            break
          case 'startsWith':
            conditions.push(eb(qualifiedField, 'like', `${operatorValue}%`))
            break
          case 'endsWith':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}`))
            break
        }
      }

      return eb.and(conditions)
    }

    return eb(qualifiedField, '=', this.transformWhereValue(field, value))
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
    if (fieldName === 'id') {
      return Number(value)
    }
    
    if (fieldName === 'bio') {
      return value !== null ? String(value) : null
    }
    
    if (fieldName === 'userId') {
      return Number(value)
    }
    
    return value // No transformation needed for this field
  }

  private prepareCreateData(data: ProfileCreateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.bio !== undefined) {
      prepared.bio = data.bio !== null ? String(data.bio) : null
    }
    
    if (data.userId !== undefined) {
      prepared.userId = Number(data.userId)
    }
    
    
    
    return prepared
  }

  private prepareUpdateData(data: ProfileUpdateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.bio !== undefined) {
      prepared.bio = data.bio !== null ? String(data.bio) : null
    }
    
    if (data.userId !== undefined) {
      prepared.userId = Number(data.userId)
    }
    
    
    
    return prepared
  }

  private transformSelectResult(row: any): Profile {
    const result: any = {}

    result.id = row.id
    
    result.bio = row.bio
    
    result.userId = row.userId

    return result
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // No one-to-many relations

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): Profile {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    const userRelation = relations.find(r => r.field === 'user' && r.type === 'one')
    if (userRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${userRelation.prefix}id`] !== null
      result.user = hasData ? {
      id: Number(row.user_id),
      email: String(row.user_email),
      name: String(row.user_name),
      createdAt: new Date(row.user_createdAt as string | number | Date),
      updatedAt: new Date(row.user_updatedAt as string | number | Date)
      } : null
    }

    return result
  }
}

/**
 * Generated operations for Post model
 */
class PostOperations {
  constructor(private kysely: Kysely<DatabaseSchema>) {}

  private _author(authorId: Expression<number>) {
    return jsonObjectFrom(
      this.kysely.selectFrom('User')
        .selectAll()
        .whereRef('User.id', '=', authorId)
    )
  }

  async findMany<T extends PostFindManyArgs = {}>(args?: T): Promise<PostGetPayload<T>[]> {
    let query = this.kysely
      .selectFrom('Post')
      .selectAll()
      .$if(!!args?.include?.author, (qb) => qb.select(
        (eb) => this._author(eb.ref('Post.authorId')).as('author')
      ))

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    if (args?.skip) {
      query = query.offset(args.skip)
    }

    if (args?.take) {
      query = query.limit(args.take)
    }

    const results = await query.execute()

    return results.map(row => this.transformSelectResult(row))
  }

  async findUnique<T extends PostFindUniqueArgs>(args: T): Promise<PostGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('Post')
      .selectAll()
      .$if(!!args?.include?.author, (qb) => qb.select(
        (eb) => this._author(eb.ref('Post.authorId')).as('author')
      ))

    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const results = await query.execute()

    if (results.length === 0) return null

    return results[0]
  }

  async findFirst<T extends PostFindFirstArgs = {}>(args?: T): Promise<PostGetPayload<T> | null> {
    let query = this.kysely
      .selectFrom('Post')
      .selectAll()
      .$if(!!args?.include?.author, (qb) => qb.select(
        (eb) => this._author(eb.ref('Post.authorId')).as('author')
      ))

    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))

    if (args?.orderBy) {
      const orderByArray = Array.isArray(args.orderBy) ? args.orderBy : [args.orderBy]
      for (const orderByObj of orderByArray) {
        Object.entries(orderByObj).forEach(([field, direction]) => {
          query = query.orderBy(field as any, direction as 'asc' | 'desc')
        })
      }
    }

    query = query.limit(1)
    const results = await query.execute()

    if (results.length === 0) return null

    return results[0]
  }

  async create(args: PostCreateArgs): Promise<Post> {
    const prepared = this.prepareCreateData(args.data)
    const result = await this.kysely
      .insertInto('Post')
      .values(prepared as any)
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async createMany(args: PostCreateManyArgs): Promise<{ count: number }> {
    const dataArray = args.data.map(item => this.prepareCreateData(item))
    await this.kysely
      .insertInto('Post')
      .values(dataArray as any)
      .execute()
    return { count: dataArray.length }
  }

  async update(args: PostUpdateArgs): Promise<Post> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Post').set(prepared as any)
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async updateMany(args: PostUpdateManyArgs): Promise<{ count: number }> {
    const prepared = this.prepareUpdateData(args.data)
    let query = this.kysely.updateTable('Post').set(prepared as any)
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numUpdatedRows || 0) }
  }

  async upsert(args: PostUpsertArgs): Promise<Post> {
    const createData = this.prepareCreateData(args.create)
    const updateData = this.prepareUpdateData(args.update)
    
    const result = await this.kysely
      .insertInto('Post')
      .values(createData as any)
      .onConflict(oc => oc.column('id').doUpdateSet(updateData))
      .returningAll()
      .executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async delete(args: PostDeleteArgs): Promise<Post> {
    let query = this.kysely.deleteFrom('Post')
    query = query.where(eb => this.buildWhereExpression(eb, args.where))
    const result = await query.returningAll().executeTakeFirstOrThrow()
    return this.transformSelectResult(result)
  }

  async deleteMany(args?: PostDeleteManyArgs): Promise<{ count: number }> {
    let query = this.kysely.deleteFrom('Post')
    
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.execute()
    return { count: Array.isArray(result) ? result.length : Number((result as any).numDeletedRows || 0) }
  }

  async count(args?: PostCountArgs): Promise<number> {
    let query = this.kysely
      .selectFrom('Post')
      .select(eb => eb.fn.count('id').as('count'))
      
    query = query.where(eb => this.buildWhereExpression(eb, args?.where ?? {}))
    
    const result = await query.executeTakeFirst() as { count: string | number | bigint } | undefined
    return Number(result?.count || 0)
  }

  private buildWhereExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'Post'>,
    where: PostWhereInput
  ) {
    const expressions: Expression<SqlBool>[] = []

    for (const [field, value] of Object.entries(where)) {
      if (field === 'AND') {
        expressions.push(eb.and((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'OR') {
        expressions.push(eb.or((value as UserWhereInput[]).map(cond => this.buildWhereExpression(eb, cond))))
      } else if (field === 'NOT') {
        // `eb.not` doesn't accept a list, so need to negate each condition instead.
        for (const cond of value as UserWhereInput[]) {
          expressions.push(eb.not(this.buildWhereExpression(eb, cond)))
        }
      } else {
        // Regular field condition
        expressions.push(this.buildFieldExpression(eb, field, value))
      }
    }
    
    return eb.and(expressions)
  }

  private buildFieldExpression(
    eb: ExpressionBuilder<DatabaseSchema, 'Post'>,
    field: string,
    value: unknown
  ) {
    const qualifiedField = `Post.${field}` as ReferenceExpression<DatabaseSchema, 'Post'>

    if (value === null) {
      return eb(qualifiedField, 'is', null)
    }

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      const conditions: Expression<SqlBool>[] = []

      for (const [operator, operatorValue] of Object.entries(value)) {
        switch (operator) {
          case 'equals':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is', null))
            } else {
              conditions.push(eb(qualifiedField, '=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'gt':
            conditions.push(eb(qualifiedField, '>', this.transformWhereValue(field, operatorValue)))
            break
          case 'gte':
            conditions.push(eb(qualifiedField, '>=', this.transformWhereValue(field, operatorValue)))
            break
          case 'lt':
            conditions.push(eb(qualifiedField, '<', this.transformWhereValue(field, operatorValue)))
            break
          case 'lte':
            conditions.push(eb(qualifiedField, '<=', this.transformWhereValue(field, operatorValue)))
            break
          case 'not':
            if (operatorValue === null) {
              conditions.push(eb(qualifiedField, 'is not', null))
            } else {
              conditions.push(eb(qualifiedField, '!=', this.transformWhereValue(field, operatorValue)))
            }
            break
          case 'in':
            conditions.push(
              eb(qualifiedField, 'in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'notIn':
            conditions.push(
              eb(qualifiedField, 'not in', (operatorValue as unknown[]).map(v => this.transformWhereValue(field, v)))
            )
            break
          case 'contains':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}%`))
            break
          case 'startsWith':
            conditions.push(eb(qualifiedField, 'like', `${operatorValue}%`))
            break
          case 'endsWith':
            conditions.push(eb(qualifiedField, 'like', `%${operatorValue}`))
            break
        }
      }

      return eb.and(conditions)
    }

    return eb(qualifiedField, '=', this.transformWhereValue(field, value))
  }

  private transformWhereValue(fieldName: string, value: unknown): unknown {
    if (fieldName === 'id') {
      return Number(value)
    }
    
    if (fieldName === 'title') {
      return String(value)
    }
    
    if (fieldName === 'content') {
      return value !== null ? String(value) : null
    }
    
    if (fieldName === 'published') {
      return value
    }
    
    if (fieldName === 'authorId') {
      return Number(value)
    }
    
    if (fieldName === 'createdAt') {
      return new Date(value as string | number | Date)
    }
    
    if (fieldName === 'updatedAt') {
      return new Date(value as string | number | Date)
    }
    
    return value // No transformation needed for this field
  }

  private prepareCreateData(data: PostCreateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.title !== undefined) {
      prepared.title = String(data.title)
    }
    
    if (data.content !== undefined) {
      prepared.content = data.content !== null ? String(data.content) : null
    }
    
    if (data.published !== undefined) {
      prepared.published = data.published
    }
    
    if (data.authorId !== undefined) {
      prepared.authorId = Number(data.authorId)
    }
    
    prepared.createdAt = data.createdAt ? new Date(data.createdAt) : new Date().toISOString()
    prepared.updatedAt = new Date().toISOString()
    
    return prepared
  }

  private prepareUpdateData(data: PostUpdateInput): Record<string, unknown> {
    const prepared: Record<string, unknown> = {}
    
    if (data.title !== undefined) {
      prepared.title = String(data.title)
    }
    
    if (data.content !== undefined) {
      prepared.content = data.content !== null ? String(data.content) : null
    }
    
    if (data.published !== undefined) {
      prepared.published = data.published
    }
    
    if (data.authorId !== undefined) {
      prepared.authorId = Number(data.authorId)
    }
    
    prepared.updatedAt = new Date().toISOString()
    
    return prepared
  }

  private transformSelectResult(row: any): Post {
    const result: any = {}

    result.id = row.id
    
    result.title = row.title
    
    result.content = row.content
    
    result.published = row.published
    
    result.authorId = row.authorId
    
    result.createdAt = row.createdAt
    
    result.updatedAt = row.updatedAt

    return result
  }

  private async fetchManyRelations(results: any[], relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>): Promise<Record<string, any[]>> {
    const relatedData: Record<string, any[]> = {}

    // Only fetch relations that are marked as 'many' type
    const manyRelations = relations.filter(r => r.type === 'many')
    if (manyRelations.length === 0 || results.length === 0) {
      return relatedData
    }

    // No one-to-many relations

    return relatedData
  }

  private transformSelectResultWithIncludes(row: any, relations: Array<{ field: string; relatedModel: string; prefix: string; type?: string }>, relatedData: Record<string, any[]>): Post {
    // First transform the base model
    const result: any = this.transformSelectResult(row)

    // Then add included relations
    const authorRelation = relations.find(r => r.field === 'author' && r.type === 'one')
    if (authorRelation) {
      // Check if the relation has data (not all fields are null)
      const hasData = row[`${authorRelation.prefix}id`] !== null
      result.author = hasData ? {
      id: Number(row.author_id),
      email: String(row.author_email),
      name: String(row.author_name),
      createdAt: new Date(row.author_createdAt as string | number | Date),
      updatedAt: new Date(row.author_updatedAt as string | number | Date)
      } : null
    }

    return result
  }
}

const createModelOperations = (kysely: Kysely<DatabaseSchema>) => ({
  user: new UserOperations(kysely),
  profile: new ProfileOperations(kysely),
  post: new PostOperations(kysely)
})

/**
 * Refract Client with pre-compiled operations
 * Database dialect: postgresql
 * No runtime schema parsing - all model operations are embedded at generation time
 */
export class RefractClient extends RefractClientBase<DatabaseSchema> {
  declare readonly user: UserOperations
  declare readonly profile: ProfileOperations
  declare readonly post: PostOperations
  constructor(dialect: Dialect) {
    super(dialect, { modelFactory: createModelOperations })
  }
}

/**
 * Factory function for creating RefractClient instances
 */
export function createRefractClient(dialect: Dialect): RefractClient {
  return new RefractClient(dialect)
}

/**
 * Convenience factory function that automatically loads configuration
 * This is the main entry point used by the generated client
 */
export async function createClient(): Promise<RefractClient> {
  const { config } = await loadRefractConfig()
  const dialect = await createKyselyDialect(config)
  return new RefractClient(dialect)
}