/**
 * Ork Basic Example - PostgreSQL with Testcontainers
 *
 * This demo showcases:
 * - Setting up PostgreSQL with Testcontainers
 * - Creating a Ork client with Kysely dialect
 * - Running migrations
 * - CRUD operations
 * - Relation loading with include
 * - Direct Kysely access via $kysely
 * - Transactions with $transaction
 */

import { OrkClientBase } from '@ork-orm/client'
import { OrkMigrate } from '@ork-orm/migrate'
import { PostgreSqlContainer } from '@testcontainers/postgresql'
import { type Generated, PostgresDialect } from 'kysely'
import pg from 'pg'

// Define the database schema types manually for this demo
// In a real app, these would be generated by `ork generate`
// Note: Table names match the Prisma model names (PascalCase)
// Generated<T> marks columns as auto-generated (optional on insert, present on select)
interface DatabaseSchema {
  User: {
    id: Generated<number>
    email: string
    name: string | null
    createdAt: Date
    updatedAt: Date
  }
  Profile: {
    id: Generated<number>
    bio: string | null
    userId: number
  }
  Post: {
    id: Generated<number>
    title: string
    content: string | null
    published: boolean
    authorId: number
    createdAt: Date
    updatedAt: Date
  }
  // Index signature required by OrkClientBase
  [modelName: string]: Record<string, any>
}

async function main() {
  console.log('üöÄ Starting Ork Basic Example\n')

  // Step 1: Start PostgreSQL container
  console.log('üì¶ Starting PostgreSQL container...')
  const container = await new PostgreSqlContainer('postgres:16-alpine').withExposedPorts(5432).start()

  const connectionString = container.getConnectionUri()
  console.log(`‚úÖ PostgreSQL running at: ${connectionString}\n`)

  try {
    // Step 2: Create Kysely dialect
    console.log('üîß Creating Kysely dialect...')
    const dialect = new PostgresDialect({
      pool: new pg.Pool({
        connectionString,
        max: 10,
      }),
    })
    console.log('‚úÖ Kysely dialect created\n')

    // Step 3: Create Ork client
    console.log('üîß Creating Ork client...')
    const client = new OrkClientBase<DatabaseSchema>(dialect)
    await client.$connect()
    console.log('‚úÖ Ork client connected\n')

    // Step 4: Run migrations
    console.log('üìù Running migrations...')
    const schemaPath = './schema.prisma'

    const migrate = new OrkMigrate({
      useTransaction: true,
      validateSchema: true,
    })

    try {
      const migrationDiff = await migrate.diff(client.$kysely, schemaPath)
      console.log('Generated migration SQL:')
      console.log(migrationDiff.statements.join('\n'))
      console.log()

      const result = await migrate.apply(client.$kysely, schemaPath)
      if (!result.success) {
        throw new Error(`Migration failed: ${result.errors.map((e) => e.message).join(', ')}`)
      }
      console.log('‚úÖ Migrations applied\n')
    } catch (migrationError) {
      console.error('‚ùå Migration error:', migrationError)
      throw migrationError
    }

    // Step 5: CRUD operations via $kysely (since we don't have generated client yet)
    console.log('üìä Creating sample data...')

    // Create a user
    const user = await client.$kysely
      .insertInto('User')
      .values({
        email: 'alice@example.com',
        name: 'Alice',
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning(['id', 'email', 'name'])
      .executeTakeFirstOrThrow()

    console.log('‚úÖ Created user:', user)

    // Create a profile
    const profile = await client.$kysely
      .insertInto('Profile')
      .values({
        bio: 'Software engineer and TypeScript enthusiast',
        userId: user.id,
      })
      .returning(['id', 'bio', 'userId'])
      .executeTakeFirstOrThrow()

    console.log('‚úÖ Created profile:', profile)

    // Create posts
    const post1 = await client.$kysely
      .insertInto('Post')
      .values({
        title: 'Getting Started with Ork',
        content: 'Ork is a TypeScript-native ORM built on Kysely...',
        published: true,
        authorId: user.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning(['id', 'title', 'published'])
      .executeTakeFirstOrThrow()

    console.log('‚úÖ Created post:', post1)

    const post2 = await client.$kysely
      .insertInto('Post')
      .values({
        title: 'Advanced Kysely Patterns',
        content: 'Learn how to leverage Kysely for complex queries...',
        published: false,
        authorId: user.id,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning(['id', 'title', 'published'])
      .executeTakeFirstOrThrow()

    console.log('‚úÖ Created post:', post2)
    console.log()

    // Step 6: Query with relations using Kysely
    console.log('üîç Querying user with relations...')
    const userWithPosts = await client.$kysely
      .selectFrom('User')
      .selectAll()
      .where('id', '=', user.id)
      .executeTakeFirst()

    console.log('User:', userWithPosts)

    // Get posts separately (in a generated client, this would be via include)
    const posts = await client.$kysely.selectFrom('Post').selectAll().where('authorId', '=', user.id).execute()

    console.log('Posts:', posts)
    console.log()

    // Step 7: Update operations
    console.log('üìù Updating post...')
    const updatedPost = await client.$kysely
      .updateTable('Post')
      .set({ published: true, updatedAt: new Date() })
      .where('id', '=', post2.id)
      .returning(['id', 'title', 'published'])
      .executeTakeFirstOrThrow()

    console.log('‚úÖ Updated post:', updatedPost)
    console.log()

    // Step 8: Transaction example
    console.log('üí∞ Testing transaction...')
    await client.$transaction(async (trx) => {
      // Create another user
      const newUser = await trx.$kysely
        .insertInto('User')
        .values({
          email: 'bob@example.com',
          name: 'Bob',
          createdAt: new Date(),
          updatedAt: new Date(),
        })
        .returning(['id', 'email'])
        .executeTakeFirstOrThrow()

      console.log('‚úÖ Created user in transaction:', newUser)

      // Create their profile
      const newProfile = await trx.$kysely
        .insertInto('Profile')
        .values({
          bio: 'Database enthusiast',
          userId: newUser.id,
        })
        .returning(['id', 'userId'])
        .executeTakeFirstOrThrow()

      console.log('‚úÖ Created profile in transaction:', newProfile)
    })
    console.log('‚úÖ Transaction completed\n')

    // Step 9: Count records
    console.log('üìä Final counts:')
    const userCount = await client.$kysely
      .selectFrom('User')
      .select(({ fn }) => fn.count<number>('id').as('count'))
      .executeTakeFirst()

    const postCount = await client.$kysely
      .selectFrom('Post')
      .select(({ fn }) => fn.count<number>('id').as('count'))
      .executeTakeFirst()

    console.log(`Users: ${userCount?.count}`)
    console.log(`Posts: ${postCount?.count}`)
    console.log()

    // Cleanup
    console.log('üßπ Cleaning up...')
    await client.$disconnect()
    console.log('‚úÖ Client disconnected')
  } finally {
    await container.stop()
    console.log('‚úÖ Container stopped')
  }

  console.log('\nüéâ Demo completed successfully!')
}

main().catch((error) => {
  console.error('‚ùå Demo failed:', error)
  process.exit(1)
})
